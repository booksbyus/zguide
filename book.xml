<?xml version="1.0"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book>
<title>ZeroMQ - Connecting your Code</title>
<bookinfo>
  <othercredit role='proofreader'>
    <firstname>FIX</firstname>
    <surname>ME!</surname>
  </othercredit>
  <othercredit role='interiordesigner'>
    <firstname>David</firstname>
    <surname>Futato</surname>
  </othercredit>
  <othercredit role='illustrator'>
    <firstname>Robert</firstname>
    <surname>Romano</surname>
  </othercredit>
  <othercredit role='coverdesigner'>
    <firstname>Karen</firstname>
    <surname>Montgomery</surname>
  </othercredit>

  <!-- All rights reserved. -->
  <publisher>
    <publishername>O&#x2019;Reilly Media, Inc.    </publishername>
    <address format='linespecific'>
      <street>1005 Gravenstein Highway North</street>
      <city>Sebastopol</city>
      <state>CA</state>
      <postcode>95472</postcode>
    </address>
  </publisher>

  <legalnotice role='printlocation'>
    <para>Printed in the United States of America.</para>
  </legalnotice>

  <legalnotice role='printer'>
    <para>[?]</para>
  </legalnotice>

  <legalnotice role='use'>
    <para>O&#x2019;Reilly books may be purchased for educational, business, or sales promotional use. Online editions are also available for most 
          titles (<ulink role='orm:hideurl:ital' url='http://my.safaribooksonline.com/?portal=oreilly'>http://my.safaribooksonline.com</ulink>). For more information, contact our corporate/institutional sales department:
          800-998-9938 or <email>corporate@oreilly.com</email>.  </para>
  </legalnotice>

  <legalnotice role='trademarks'>
    <para>Nutshell Handbook, the Nutshell Handbook logo, and the O&#x2019;Reilly logo
          are registered trademarks of O&#x2019;Reilly Media, Inc. !!FILL THIS IN!!
          and related trade dress are trademarks of O&#x2019;Reilly Media, Inc.    </para>
    <para>Many of the designations used by manufacturers and sellers to distinguish
          their products are claimed as trademarks. Where those designations appear
          in this book, and O&#x2019;Reilly Media, Inc., was aware of a trademark claim,
          the designations have been printed in caps or initial caps.    </para>
  </legalnotice>

  <legalnotice role='damages'>
    <para>While every precaution has been taken in the preparation of this book,
        the publisher and authors assume no responsibility for errors or omissions, 
        or for damages resulting from the use of the information contained herein.</para>
  </legalnotice>
<isbn>9781449334062</isbn><edition>1</edition><author><firstname>Pieter</firstname><surname>Hintjens</surname><authorblurb><para>Pieter Hintjens started his first business making video games 30 years
ago and has been building software products since then. Taking as his
principle, &quot;the real physics of software is the physics of people&quot;, he
focuses now on building communities through &quot;Social Architecture&quot;,
writing, and helping others use ZeroMQ profitably.&lt;br /&gt;
&lt;br /&gt;
For two years he was president of the FFII, a European NGO that fights
software patents. He was CEO of Wikidot Inc., founder of the European
Patent Conference, and founder of the Digital Standards Organization.&lt;br /&gt;
&lt;br /&gt;
Pieter speaks English, French, Dutch, and bits of a dozen other languages.
He plays with a West African drum group in Brussels and is a certified
pistol instructor in Texas. Pieter lives with his beautiful wife and three
lovely children in Brussels, Belgium and travels extensively.</para></authorblurb></author><editor><firstname>Andy</firstname><surname>Oram</surname></editor><copyright><year>2010</year><holder>O&#x2019;Reilly Media    </holder></copyright><editor role='production'><firstname/><surname/></editor><editor role='copy'><firstname/><surname/></editor><othercredit role='indexer'><firstname/><surname/></othercredit><printhistory><formalpara><title>First Edition</title><para>October, 2012</para></formalpara></printhistory>
<revhistory>
<revision><date>2012-06-25</date><revremark>Early release revision 1</revremark></revision>
</revhistory>
</bookinfo>
<dedication>
<para><emphasis role="bold">By Pieter Hintjens</emphasis></para>

</dedication>
<preface>
<title>Preface</title>
<sect1>
<title>&Oslash;MQ in a Hundred Words</title>
<para>&Oslash;MQ (also seen as ZeroMQ, &Oslash;MQ, zmq) looks like an embeddable networking library but acts like a concurrency framework. It gives you sockets that carry atomic messages across various transports like in-process, inter-process, TCP, and multicast. You can connect sockets N-to-N with patterns like fanout, pub-sub, task distribution, and request-reply. It's fast enough to be the fabric for clustered products. Its asynchronous I/O model gives you scalable multicore applications, built as asynchronous message-processing tasks. It has a score of language APIs and runs on most operating systems. &Oslash;MQ is from <ulink url="http://www.imatix.com">iMatix</ulink> and is LGPLv3 open source.</para>

</sect1>
<sect1>
<title>The Zen of Zero</title>
<para>The &Oslash; in &Oslash;MQ is all about tradeoffs. On the one hand this strange name lowers &Oslash;MQ's visibility on Google and Twitter. On the other hand it annoys the heck out of some Danish folk who write us things like "&Oslash;MG r&oslash;tfl", and "&Oslash; is not a funny looking zero!" and "<emphasis>R&oslash;dgr&oslash;d med Fl&oslash;de!</emphasis>", which is apparently an insult that means "may your neighbours be the direct descendants of Grendel!"  Seems like a fair trade.</para>

<para>Originally the zero in &Oslash;MQ was meant as "zero broker" and (as close to) "zero latency" (as possible). In the meantime it has come to cover different goals: zero administration, zero cost, zero waste. More generally, "zero" refers to the culture of minimalism that permeates the project. We add power by removing complexity rather than exposing new functionality.</para>

</sect1>
<sect1>
<title>How the Guide Happened</title>
<para>In the summer of 2010, &Oslash;MQ was still a little-known niche library described by its rather terse man pages and a living but sparse wiki. Martin Sustrik and myself (Pieter Hintjens) were sitting in the bar of the Hotel Kyjev in Bratislava plotting how to make &Oslash;MQ more widely popular. Martin had written most of the &Oslash;MQ code, and I'd put up the funding and organized the community. Over some Zlaty Bazants, we agreed that &Oslash;MQ needed a new, simpler web site, and a basic guide to new users.</para>

<para>Martin collected some ideas for topics to explain. I'd never written a line of &Oslash;MQ code before this, so it became a live learning documentary. As I worked through simple examples to more complex ones I tried to answer many of the questions I'd seen on the mailing list. Since I've been building large-scale architectures for 30 years, there were a lot of problems I was keen to throw &Oslash;MQ at. Amazingly the results were mostly simple and elegant, even working in C. I felt a pure joy learning &Oslash;MQ and using it to solve real problems, which brought me back to programming after a few years' pause. And often, not knowing how it was "supposed" to be done, we improved &Oslash;MQ as we went along.</para>

<para>From the start I wanted the Guide to be a community project, so I put it onto github and let others contribute with pull requests. This was considered a radical, even vulgar approach by some. We came to a division of labor: I'd do the writing and make the original C examples, and others would help fix the text and translate the examples into other languages.</para>

<para>This worked better than I dared hope: you can now find all the examples in several languages and many in a dozen languages. It's a kind of programming language Rosetta stone and a valuable outcome in itself. We set-up a high-score: reach 80% translation and your language got its own Guide. PHP, Python, Lua, and Haxe reached this goal. People asked for PDFs, and we made that. People asked for ebooks, and got those. About a hundred people contributed to the Guide to date.</para>

<para>The Guide achieved its goal of popularizing &Oslash;MQ. The style pleases most and annoys some, which is how it should be. In December 2010 my work on &Oslash;MQ and the Guide stopped, as I found myself going through late-stage cancer, heavy surgery, and six months of chemotherapy. When I picked up work again in mid-2011, it was to start using &Oslash;MQ in anger for one of the largest use-cases imagineable: on the mobile phones and tablets of the world's biggest electronics company.</para>

<para>But the goal of the Guide was, from the start, a printed book. So it was exciting to get an email from Bill Lubanovic in January 2012 introducing me to his editor Andy Oram at O'Reilly, suggesting a &Oslash;MQ book. Of course! Where do I sign? How much do I have to pay? Oh, I <emphasis>get money</emphasis> for this? All I have to do is finish it?</para>

<para>Of course as soon as O'Reilly announced a &Oslash;MQ book, other publishers started sending out emails to potential authors. You'll probably see a rash of &Oslash;MQ books coming out next year. That's good: our niche library has hit the mainstream and deserves its six inches of shelf space. My apologies to the other &Oslash;MQ authors: we've set the bar horribly high, and my advice is to make your books complimentary. Perhaps focus on a specific language, platform, or pattern.</para>

<para>This is the magic and power of communities: be the first community in a space, stay healthy, and you own that space for ever.</para>

</sect1>
<sect1>
<title>Audience</title>
<para>This book is written for professional programmers who want to learn how to make the massively distributed software that will dominate the future of computing. We assume you can read C code, because most of the examples here are in C even though &Oslash;MQ is used in many languages. We assume you care about scale, because &Oslash;MQ solves that problem above all others. We assume you need the best possible results with the least possible cost, because otherwise you won't appreciate the trade-offs that &Oslash;MQ makes. Other than that basic background, we try to present all the concepts in networking and distributed computing you will need to use &Oslash;MQ.</para>

</sect1>
<sect1>
<title>Conventions Used in This Book</title>
<para>We tried to be as unconventional as possible. Nevertheless, you'll tend to find the following typographical uses in this book:</para>

<itemizedlist>
  <listitem><para><emphasis>Italic</emphasis> - Indicates new terms, URLs, email addresses, filenames, and file extensions.</para></listitem>
  <listitem><para><literal>Constant width</literal> - Used for program listings, as well as within paragraphs to refer to program elements such as variable or function names, data types, and environment variables.</para></listitem>
  <listitem><para>[NOTE] - This signifies a tip, suggestion, or general note.</para></listitem>
</itemizedlist>
</sect1>
<sect1>
<title>Using the Code Examples</title>
    <para>The code examples are all online in the Guide repository at
    _https://github.com/imatix/zguide/tree/master/examples/_. You'll find each
    example translated into several, often a dozen other languages. The examples
    are licensed under MIT/X11; see the LICENSE file in that directory. The text
    of the Guide explains in each case how to run each example.</para>

    <para>We appreciate, but do not require, attribution. An attribution
    usually includes the title, author, publisher, and ISBN. For example:
    "<emphasis>ZeroMQ</emphasis> by Pieter Hintjens and the ZeroMQ community
    (O'Reilly). Copyright 2012 Pieter Hintjens, 978-1-449-33406-2."</para>

    <para>If you feel your use of code examples falls outside fair use or the
    permission given above, feel free to contact us at
    <email>permissions@oreilly.com</email>.</para>
  </sect1>

  <sect1>
    <title>SafariÂ® Books Online</title>

    <note role="safarienabled">
      <para>Safari Books Online (<ulink role="orm:hideurl:ital"
      url="http://my.safaribooksonline.com/?portal=oreilly">www.safaribooksonline.com</ulink>)
      is an on-demand digital library that delivers expert <ulink
      role="orm:hideurl"
      url="http://www.safaribooksonline.com/content">content</ulink> in both
      book and video form from the world's leading authors in technology and
      business.</para>
    </note>

    <para>Technology professionals, software developers, web designers, and
    business and creative professionals use Safari Books Online as their
    primary resource for research, problem solving, learning, and
    certification training.</para>

    <para>Safari Books Online offers a range of <ulink role="orm:hideurl"
    url="http://www.safaribooksonline.com/subscriptions">product mixes</ulink>
    and pricing programs for <ulink role="orm:hideurl"
    url="http://www.safaribooksonline.com/organizations-teams">organizations</ulink>,
    <ulink role="orm:hideurl"
    url="http://www.safaribooksonline.com/government">government
    agencies</ulink>, and <ulink role="orm:hideurl"
    url="http://www.safaribooksonline.com/individuals">individuals</ulink>.
    Subscribers have access to thousands of books, training videos, and
    prepublication manuscripts in one fully searchable database from
    publishers like O'Reilly Media, Prentice Hall Professional, Addison-Wesley
    Professional, Microsoft Press, Sams, Que, Peachpit Press, Focal Press,
    Cisco Press, John Wiley &amp; Sons, Syngress, Morgan Kaufmann, IBM
    Redbooks, Packt, Adobe Press, FT Press, Apress, Manning, New Riders,
    McGraw-Hill, Jones &amp; Bartlett, Course Technology, and dozens <ulink
    role="orm:hideurl"
    url="http://www.safaribooksonline.com/publishers">more</ulink>. For more
    information about Safari Books Online, please visit us <ulink
    role="orm:hideurl"
    url="http://www.safaribooksonline.com/">online</ulink>.</para>
  </sect1>

  <sect1>
    <title>How to Contact Us</title>

    <para>Please address comments and questions concerning this book to the
    publisher:</para>

    <simplelist type="vert">
      <member>O'Reilly Media, Inc.</member>
      <member>1005 Gravenstein Highway North</member>
      <member>Sebastopol, CA 95472</member>
      <member>800-998-9938 (in the United States or Canada)</member>
      <member>707-829-0515 (international or local)</member>
      <member>707-829-0104 (fax)</member>
    </simplelist>

    <para>We have a web page for this book, where we list errata, examples,
    and any additional information. You can access this page at:</para>

    <simplelist type="vert">
      <member><ulink
      url="http://www.oreilly.com/catalog/9781449334062"></ulink></member>
    </simplelist>

    <para>To comment or ask technical questions about this book, send email
    to:</para>

    <simplelist type="vert">
      <member><email>bookquestions@oreilly.com</email></member>
    </simplelist>

    <para>For more information about our books, courses, conferences, and
    news, see our website at <ulink
    url="http://www.oreilly.com"></ulink>.</para>

    <para>Find us on Facebook: <ulink
    url="http://facebook.com/oreilly"></ulink></para>

    <para>Follow us on Twitter: <ulink
    url="http://twitter.com/oreillymedia"></ulink></para>

    <para>Watch us on YouTube: <ulink
    url="http://www.youtube.com/oreillymedia"></ulink></para>
</sect1>
<sect1>
<title>Acknowledgements</title>
<para>Thanks to Andy Oram for making <ulink url="http://shop.oreilly.com/product/0636920026136.do">this happen at O'Reilly</ulink> and editing the book.</para>

<para>Thanks to Bill Desmarais, Brian Dorsey, Daniel Lin, Eric Desgranges, Gonzalo Diethelm, Guido Goldstein, Hunter Ford, Kamil Shakirov, Martin Sustrik, Mike Castleman, Naveen Chawla, Nicola Peduzzi, Oliver Smith, Olivier Chamoux, Peter Alexander, Pierre Rouleau, Randy Dryburgh, John Unwin, Alex Thomas, Mihail Minkov, Jeremy Avnet, Michael Compton, Kamil Kisiel, Mark Kharitonov, Guillaume Aubert, Ian Barber, Mike Sheridan, Faruk Akgul, Oleg Sidorov, Lev Givon, Allister MacLeod, Alexander D'Archangel, Andreas Hoelzlwimmer, Han Holl, Robert G. Jakabosky, Felipe Cruz, Marcus McCurdy, Mikhail Kulemin, Dr. Gerg&ouml; &Eacute;rdi, Pavel Zhukov, Alexander Else, Giovanni Ruggiero, Rick "Technoweenie", Daniel Lundin, Dave Hoover, Simon Jefford, Benjamin Peterson, Justin Case, Devon Weller, Richard Smith, Alexander Morland, Wadim Grasza, Michael Jakl, Uwe Dauernheim, Sebastian Nowicki, Simone Deponti, Aaron Raddon, Dan Colish, Markus Schirp, Benoit Larroque, Jonathan Palardy, Isaiah Peng, Arkadiusz Orzechowski, Umut Aydin, Matthew Horsfall, Jeremy W. Sherman, Eric Pugh, Tyler Sellon, John E. Vincent, Pavel Mitin, Min RK, Igor Wiedler, Olof &Aring;kesson, Patrick Lucas, Heow Goodman, Senthil Palanisami, John Gallagher, Tomas Roos, Stephen McQuay, Erik Allik, Arnaud Cogolu&egrave;gnes, Rob Gagnon, Dan Williams, Edward Smith, James Tucker, Kristian Kristensen, Vadim Shalts, Martin Trojer, Tom van Leeuwen, Pandya Hiten, Harm Aarts, Marc Harter, Iskren Ivov Chernev, Jay Han, Sonia Hamilton, Nathan Stocks, Naveen Palli, and Zed Shaw for their contributions.</para>

<para>Thanks to Stathis Sideris for <ulink url="http://www.ditaa.org">Ditaa</ulink>.</para>

</sect1>
</preface>
<chapter id="basics">
<title>Basics</title>
<sect1>
<title>Fixing the World</title>
<para>How to explain &Oslash;MQ? Some of us start by saying all the wonderful things it does. <emphasis>It's sockets on steroids. It's like mailboxes with routing. It's fast!</emphasis>  Others try to share their moment of enlightenment, that zap-pow-kaboom satori paradigm-shift moment when it all became obvious. <emphasis>Things just become simpler. Complexity goes away. It opens the mind.</emphasis>  Others try to explain by comparison. <emphasis>It's smaller, simpler, but still looks familiar.</emphasis>  Personally, I like to remember why we made &Oslash;MQ at all, because that's most likely where you, the reader, still are today.</para>

<para>Programming is a science dressed up as art, because most of us don't understand the physics of software, and it's rarely if ever taught. The physics of software is not algorithms, data structures, languages and abstractions. These are just tools we make, use, throw away. The real physics of software is the physics of people.</para>

<para>Specifically, our limitations when it comes to complexity, and our desire to work together to solve large problems in pieces. This is the science of programming: make building blocks that people can understand and use <emphasis>easily</emphasis>, and people will work together to solve the very largest problems.</para>

<para>We live in a connected world, and modern software has to navigate this world. So the building blocks for tomorrow's very largest solutions are connected and massively parallel. It's not enough for code to be "strong and silent" any more. Code has to talk to code. Code has to be chatty, sociable, well-connected. Code has to run like the human brain, trillions of individual neurons firing off messages to each other, a massively parallel network with no central control, no single point of failure, yet able to solve immensely difficult problems. And it's no accident that the future of code looks like the human brain, because the endpoints of every network are, at some level, human brains.</para>

<para>If you've done any work with threads, protocols, or networks, you'll realize this is pretty much impossible. It's a dream. Even connecting a few programs across a few sockets is plain nasty, when you start to handle real life situations. Trillions? The cost would be unimaginable. Connecting computers is so difficult that software and services to do this is a multi-billion dollar business.</para>

<para>So we live in a world where the wiring is years ahead of our ability to use it. We had a software crisis in the 1980s, when leading software engineers like Fred Brooks believed <ulink url="http://en.wikipedia.org/wiki/No-Silver-Bullet">there was no "Silver Bullet"</ulink> to "promise even one order of magnitude of improvement in productivity, reliability, or simplicity".</para>

<para>Brooks missed free and open source software, which solved that crisis, enabling us to share knowledge efficiently. Today we face another software crisis, but it's one we don't talk about much. Only the largest, richest firms can afford to create connected applications. There is a cloud, but it's proprietary. Our data, our knowledge is disappearing from our personal computers into clouds that we cannot access, cannot compete with. Who owns our social networks? It is like the mainframe-PC revolution in reverse.</para>

<para>We can leave the political philosophy <ulink url="http://swsi.info">for another book</ulink>. The point is that while the Internet offers the potential of massively connected code, the reality is that this is out of reach for most of us, and so, large interesting problems (in health, education, economics, transport, and so on) remain unsolved because there is no way to connect the code, and thus no way to connect the brains that could work together to solve these problems.</para>

<para>There have been many attempts to solve the challenge of connected software. There are thousands of IETF specifications, each solving part of the puzzle. For application developers, HTTP is perhaps the one solution to have been simple enough to work, but it arguably makes the problem worse, by encouraging developers and architects to think in terms of big servers and thin, stupid clients.</para>

<para>So today people are still connecting applications using raw UDP and TCP, proprietary protocols, HTTP, Websockets. It remains painful, slow, hard to scale, and essentially centralized. Distributed P2P architectures are mostly for play, not work. How many applications use Skype or Bittorrent to exchange data?</para>

<para>Which brings us back to the science of programming. To fix the world, we needed to do two things. One, to solve the general problem of "how to connect any code to any code, anywhere". Two, to wrap that up in the simplest possible building blocks that people could understand and use <emphasis>easily</emphasis>.</para>

<para>It sounds ridiculously simple. And maybe it is. That's kind of the whole point.</para>

</sect1>
<sect1>
<title>Audience for This Book</title>
<para>We assume you are using the latest 3.2 release of &Oslash;MQ. We assume you are using a Linux box or something similar. We assume you can read C code, more or less, that's the default language for the examples. We assume that when we write constants like PUSH or SUBSCRIBE you can imagine they are really called <literal>ZMQ-PUSH</literal> or <literal>ZMQ-SUBSCRIBE</literal> if the programming language needs it.</para>

</sect1>
<sect1>
<title>Getting the Examples</title>
<para>The Guide examples live in the Guide's <ulink url="https://github.com/imatix/zguide">git repository</ulink>. The simplest way to get all the examples is to clone this repository:</para>

<screen>git clone --depth=1 git://github.com/imatix/zguide.git
</screen>

<para>And then browse the examples subdirectory. You'll find examples by language. If there are examples missing in a language you use, you're encouraged to <ulink url="http://zguide.zeromq.org/main:translate">submit a translation</ulink>. This is how the Guide became so useful, thanks to the work of many people. All examples are licensed under MIT/X11.</para>

</sect1>
<sect1>
<title>Ask and Ye Shall Receive</title>
<para>So let's start with some code. We start of course with a Hello World example. We'll make a client and a server. The client sends "Hello" to the server, which replies with "World"(<xref linkend="figure-1"/>). Here's the server in C, which opens a &Oslash;MQ socket on port 5555, reads requests on it, and replies with "World" to each request:</para>

<example id="hwserver-c">
<title>Hello World server (hwserver.c)</title>
<programlisting language="c">
//
//  Hello World server
//  Binds REP socket to tcp://*:5555
//  Expects "Hello" from client, replies with "World"
//
#include &lt;zmq.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

int main (void)
{
    void *context = zmq_ctx_new ();

    //  Socket to talk to clients
    void *responder = zmq_socket (context, ZMQ_REP);
    zmq_bind (responder, "tcp://*:5555");

    while (true) {
        //  Wait for next request from client
        zmq_msg_t request;
        zmq_msg_init (&amp;request);
        zmq_msg_recv (&amp;request, responder, 0);
        printf ("Received Hello\n");
        zmq_msg_close (&amp;request);

        //  Do some 'work'
        sleep (1);

        //  Send reply back to client
        zmq_msg_t reply;
        zmq_msg_init_size (&amp;reply, 5);
        memcpy (zmq_msg_data (&amp;reply), "World", 5);
        zmq_msg_send (&amp;reply, responder, 0);
        zmq_msg_close (&amp;reply);
    }
    //  We never get here but if we did, this would be how we end
    zmq_close (responder);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<figure id="figure-1">
    <title>Request-Reply</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig1.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>The REQ-REP socket pair is in lockstep. The client issues <literal>zmq-msg-send[3]</literal> and then <literal>zmq-msg-recv[3]</literal>, in a loop (or once if that's all it needs). Doing any other sequence (e.g. sending two messages in a row) will result in a return code of -1 from the <literal>send</literal> or <literal>recv</literal> call. Similarly, the service issues <literal>zmq-msg-recv[3]</literal> and then <literal>zmq-msg-send[3]</literal> in that order, as often as it needs to.</para>

<para>&Oslash;MQ uses C as its reference language and this is the main language we'll use for examples. If you're reading this on-line, the link below the example takes you to translations into other programming languages. Let's compare the same server in C++:</para>

<example id="hwserver-cpp">
<title>Hello World server (hwserver.cpp)</title>
<programlisting language="cpp">
//
//  Hello World server in C++
//  Binds REP socket to tcp://*:5555
//  Expects "Hello" from client, replies with "World"
//
#include &lt;zmq.hpp&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt;

int main () {
    //  Prepare our context and socket
    zmq::context_t context (1);
    zmq::socket_t socket (context, ZMQ_REP);
    socket.bind ("tcp://*:5555");

    while (true) {
        zmq::message_t request;

        //  Wait for next request from client
        socket.recv (&amp;request);
        std::cout &lt;&lt; "Received Hello" &lt;&lt; std::endl;

        //  Do some 'work'
        sleep (1);

        //  Send reply back to client
        zmq::message_t reply (5);
        memcpy ((void *) reply.data (), "World", 5);
        socket.send (reply);
    }
    return 0;
}
</programlisting>

</example>
<para>You can see that the &Oslash;MQ API is similar in C and C++. In a language like PHP, we can hide even more and the code becomes even easier to read:</para>

<example id="hwserver-php">
<title>Hello World server (hwserver.php)</title>
<programlisting language="php">
&lt;?php
/*
 *  Hello World server
 *  Binds REP socket to tcp://*:5555
 *  Expects "Hello" from client, replies with "World"
 * @author Ian Barber &lt;ian(dot)barber(at)gmail(dot)com&gt;
 */

$context = new ZMQContext(1);

//  Socket to talk to clients
$responder = new ZMQSocket($context, ZMQ::SOCKET_REP);
$responder-&gt;bind("tcp://*:5555");

while(true) {
	//  Wait for next request from client
	$request = $responder-&gt;recv();
	printf ("Received request: [%s]\n", $request);

	//  Do some 'work'
	sleep (1);

	//  Send reply back to client
	$responder-&gt;send("World");    
</programlisting>

</example>
<para>Here's the client code:</para>

<example id="hwclient-c">
<title>Hello World client (hwclient.c)</title>
<programlisting language="c">
//
//  Hello World client
//  Connects REQ socket to tcp://localhost:5555
//  Sends "Hello" to server, expects "World" back
//
#include &lt;zmq.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main (void)
{
    void *context = zmq_ctx_new ();

    //  Socket to talk to server
    printf ("Connecting to hello world server...\n");
    void *requester = zmq_socket (context, ZMQ_REQ);
    zmq_connect (requester, "tcp://localhost:5555");

    int request_nbr;
    for (request_nbr = 0; request_nbr != 10; request_nbr++) {
        zmq_msg_t request;
        zmq_msg_init_size (&amp;request, 5);
        memcpy (zmq_msg_data (&amp;request), "Hello", 5);
        printf ("Sending Hello %d...\n", request_nbr);
        zmq_msg_send (&amp;request, requester, 0);
        zmq_msg_close (&amp;request);

        zmq_msg_t reply;
        zmq_msg_init (&amp;reply);
        zmq_msg_recv (&amp;reply, requester, 0);
        printf ("Received World %d\n", request_nbr);
        zmq_msg_close (&amp;reply);
    }
    zmq_close (requester);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<para>Now this looks too simple to be realistic, but a &Oslash;MQ socket is what you get when you take a normal TCP socket, inject it with a mix of radioactive isotopes stolen from a secret Soviet atomic research project, bombard it with 1950-era cosmic rays, and put it into the hands of a drug-addled comic book author with a badly-disguised fetish for bulging muscles clad in spandex(<xref linkend="figure-2"/>). Yes, &Oslash;MQ sockets are the world-saving superheroes of the networking world.</para>

<figure id="figure-2">
    <title>A terrible accident...</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig2.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>You could throw thousands of clients at this server, all at once, and it would continue to work happily and quickly. For fun, try starting the client and <emphasis>then</emphasis> starting the server, see how it all still works, then think for a second what this means.</para>

<para>Let us explain briefly what these two programs are actually doing. They create a &Oslash;MQ context to work with, and a socket. Don't worry what the words mean. You'll pick it up. The server binds its REP (reply) socket to port 5555. The server waits for a request, in a loop, and responds each time with a reply. The client sends a request and reads the reply back from the server.</para>

<para>If you kill the server (Ctrl-C) and restart it, the client won't recover properly. Recovering from crashing processes isn't quite that easy. Making a reliable request-reply flow is complex enough that we won't cover it until Reliable Request-Reply Patterns<xref linkend="reliable-request-reply"/>.</para>

<para>There is a lot happening behind the scenes but what matters to us programmers is how short and sweet the code is, and how often it doesn't crash, even under heavy load. This is the request-reply pattern, probably the simplest way to use &Oslash;MQ. It maps to RPC and the classic client-server model.</para>

</sect1>
<sect1>
<title>A Minor Note on Strings</title>
<para>&Oslash;MQ doesn't know anything about the data you send except its size in bytes. That means you are responsible for formatting it safely so that applications can read it back. Doing this for objects and complex data types is a job for specialized libraries like Protocol Buffers. But even for strings you need to take care.</para>

<para>In C and some other languages, strings are terminated with a null byte. We could send a string like "HELLO" with that extra null byte:</para>

<programlisting language="c">
zmq-msg-init-data (&amp;request, "Hello", 6, NULL, NULL);
</programlisting>

<para>However if you send a string from another language it probably will not include that null byte. For example, when we send that same string in Python, we do this:</para>

<programlisting language="python">
socket.send ("Hello")
</programlisting>

<para>Then what goes onto the wire is a length (one byte for shorter strings) and the string contents, as individual characters(<xref linkend="figure-3"/>).</para>

<figure id="figure-3">
    <title>A &Oslash;MQ string</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig3.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>And if you read this from a C program, you will get something that looks like a string, and might by accident act like a string (if by luck the five bytes find themselves followed by an innocently lurking null), but isn't a proper string. When your client and server don't agree on the string format, you will get weird results.</para>

<para>When you receive string data from &Oslash;MQ, in C, you simply cannot trust that it's safely terminated. Every single time you read a string you should allocate a new buffer with space for an extra byte, copy the string, and terminate it properly with a null.</para>

<para>So let's establish the rule that <emphasis role="bold">&Oslash;MQ strings are length-specified, and are sent on the wire <emphasis>without</emphasis> a trailing null</emphasis>. In the simplest case (and we'll do this in our examples) a &Oslash;MQ string maps neatly to a &Oslash;MQ message frame, which looks like the above figure, a length and some bytes.</para>

<para>Here is what we need to do, in C, to receive a &Oslash;MQ string and deliver it to the application as a valid C string:</para>

<programlisting language="c">
//  Receive 0MQ string from socket and convert into C string
static char *
s-recv (void *socket) {
    zmq-msg-t message;
    zmq-msg-init (&amp;message);
    int size = zmq-msg-recv (&amp;message, socket, 0);
    if (size == -1)
        return NULL;
    char *string = malloc (size + 1);
    memcpy (string, zmq-msg-data (&amp;message), size);
    zmq-msg-close (&amp;message);
    string [size] = 0;
    return (string);
}
</programlisting>

<para>This makes a very handy helper function and in the spirit of making things we can reuse profitably, let's write a similar 's-send' function that sends strings in the correct &Oslash;MQ format, and package this into a header file we can reuse.</para>

<para>The result is <literal>zhelpers.h</literal>, which lets us write sweeter and shorter &Oslash;MQ applications in C. It is a fairly long source, and only fun for C developers, so <ulink url="https://github.com/imatix/zguide/blob/master/examples/C/zhelpers.h">read it at leisure</ulink>.</para>

</sect1>
<sect1>
<title>Version Reporting</title>
<para>&Oslash;MQ does come in several versions and quite often, if you hit a problem, it'll be something that's been fixed in a later version. So it's a useful trick to know <emphasis>exactly</emphasis> what version of &Oslash;MQ you're actually linking with. Here is a tiny program that does that:</para>

<example id="version-c">
<title>&Oslash;MQ version reporting (version.c)</title>
<programlisting language="c">
//
//  Report 0MQ version
//
#include "zhelpers.h"

int main (void)
{
    int major, minor, patch;
    zmq_version (&amp;major, &amp;minor, &amp;patch);
    printf ("Current 0MQ version is %d.%d.%d\n", major, minor, patch);

    return EXIT_SUCCESS;
}
</programlisting>

</example>
</sect1>
<sect1>
<title>Getting the Message Out</title>
<para>The second classic pattern is one-way data distribution, in which a server pushes updates to a set of clients. Let's see an example that pushes out weather updates consisting of a zip code, temperature, and relative humidity. We'll generate random values, just like the real weather stations do.</para>

<para>Here's the server. We'll use port 5556 for this application:</para>

<example id="wuserver-c">
<title>Weather update server (wuserver.c)</title>
<programlisting language="c">
//
//  Weather update server
//  Binds PUB socket to tcp://*:5556
//  Publishes random weather updates
//
#include "zhelpers.h"

int main (void)
{
    //  Prepare our context and publisher
    void *context = zmq_ctx_new ();
    void *publisher = zmq_socket (context, ZMQ_PUB);
    int rc = zmq_bind (publisher, "tcp://*:5556");
    assert (rc == 0);
    rc = zmq_bind (publisher, "ipc://weather.ipc");
    assert (rc == 0);

    //  Initialize random number generator
    srandom ((unsigned) time (NULL));
    while (true) {
        //  Get values that will fool the boss
        int zipcode, temperature, relhumidity;
        zipcode     = randof (100000);
        temperature = randof (215) - 80;
        relhumidity = randof (50) + 10;

        //  Send message to all subscribers
        char update [20];
        sprintf (update, "%05d %d %d", zipcode, temperature, relhumidity);
        s_send (publisher, update);
    }
    zmq_close (publisher);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<para>There's no start, and no end to this stream of updates, it's like a never ending broadcast(<xref linkend="figure-4"/>).</para>

<figure id="figure-4">
    <title>Publish-Subscribe</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig4.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>Here is client application, which listens to the stream of updates and grabs anything to do with a specified zip code, by default New York City because that's a great place to start any adventure:</para>

<example id="wuclient-c">
<title>Weather update client (wuclient.c)</title>
<programlisting language="c">
//
//  Weather update client
//  Connects SUB socket to tcp://localhost:5556
//  Collects weather updates and finds avg temp in zipcode
//
#include "zhelpers.h"

int main (int argc, char *argv [])
{
    void *context = zmq_ctx_new ();

    //  Socket to talk to server
    printf ("Collecting updates from weather server...\n");
    void *subscriber = zmq_socket (context, ZMQ_SUB);
    int rc = zmq_connect (subscriber, "tcp://localhost:5556");
    assert (rc == 0);

    //  Subscribe to zipcode, default is NYC, 10001
    char *filter = (argc &gt; 1)? argv [1]: "10001 ";
    rc = zmq_setsockopt (subscriber, ZMQ_SUBSCRIBE, filter, strlen (filter));
    assert (rc == 0);

    //  Process 100 updates
    int update_nbr;
    long total_temp = 0;
    for (update_nbr = 0; update_nbr &lt; 100; update_nbr++) {
        char *string = s_recv (subscriber);

        int zipcode, temperature, relhumidity;
        sscanf (string, "%d %d %d",
            &amp;zipcode, &amp;temperature, &amp;relhumidity);
        total_temp += temperature;
        free (string);
    }
    printf ("Average temperature for zipcode '%s' was %dF\n",
        filter, (int) (total_temp / update_nbr));

    zmq_close (subscriber);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<para>Note that when you use a SUB socket you <emphasis role="bold">must</emphasis> set a subscription using <literal>zmq-setsockopt[3]</literal> and SUBSCRIBE, as in this code. If you don't set any subscription, you won't get any messages. It's a common mistake for beginners. The subscriber can set many subscriptions, which are added together. That is, if a update matches ANY subscription, the subscriber receives it. The subscriber can also cancel specific subscriptions. A subscription is often but not necessarily a printable string. See <literal>zmq-setsockopt[3]</literal> for how this works.</para>

<para>The PUB-SUB socket pair is asynchronous. The client does <literal>zmq-msg-recv[3]</literal>, in a loop (or once if that's all it needs). Trying to send a message to a SUB socket will cause an error. Similarly the service does <literal>zmq-msg-send[3]</literal> as often as it needs to, but must not do <literal>zmq-msg-recv[3]</literal> on a PUB socket.</para>

<para>In theory with &Oslash;MQ sockets, it does not matter which end connects, and which end binds. However in practice there are undocumented differences that I'll come to later. For now, bind the PUB and connect the SUB, unless your network design makes that impossible.</para>

<para>There is one more important thing to know about PUB-SUB sockets: you do not know precisely when a subscriber starts to get messages. Even if you start a subscriber, wait a while, and then start the publisher, <emphasis role="bold">the subscriber will always miss the first messages that the publisher sends</emphasis>. This is because as the subscriber connects to the publisher (something that takes a small but non-zero time), the publisher may already be sending messages out.</para>

<para>This "slow joiner" symptom hits enough people, often enough, that we're going to explain it in detail. Remember that &Oslash;MQ does asynchronous I/O, i.e. in the background. Say you have two nodes doing this, in this order:</para>

<itemizedlist>
  <listitem><para>Subscriber connects to an endpoint and receives and counts messages.</para></listitem>
  <listitem><para>Publisher binds to an endpoint and immediately sends 1,000 messages.</para></listitem>
</itemizedlist>
<para>Then the subscriber will most likely not receive anything. You'll blink, check that you set a correct filter, and try again, and the subscriber will still not receive anything.</para>

<para>Making a TCP connection involves to and fro handshaking that takes several milliseconds depending on your network and the number of hops between peers. In that time, &Oslash;MQ can send very many messages. For sake of argument assume it takes 5 msecs to establish a connection, and that same link can handle 1M messages per second. During the 5 msecs that the subscriber is connecting to the publisher, it takes the publisher only 1 msec to send out those 1K messages.</para>

<para>In Sockets and Patterns<xref linkend="sockets-and-patterns"/> we'll explain how to synchronize a publisher and subscribers so that you don't start to publish data until the subscriber(s) really are connected and ready. There is a simple and stupid way to delay the publisher, which is to sleep. Don't do this in a real application, though, because it is extremely fragile as well as inelegant and slow. Use sleeps to prove to yourself what's happening, and then wait for Sockets and Patterns<xref linkend="sockets-and-patterns"/> to see how to do this right.</para>

<para>The alternative to synchronization is to simply assume that the published data stream is infinite and has no start, and no end. One also assumes that the subscriber doesn't care what transpired before it started up. This is how we built our weather client example.</para>

<para>So the client subscribes to its chosen zip code and collects a thousand updates for that zip code. That means about ten million updates from the server, if zip codes are randomly distributed. You can start the client, and then the server, and the client will keep working. You can stop and restart the server as often as you like, and the client will keep working. When the client has collected its thousand updates, it calculates the average, prints it, and exits.</para>

<para>Some points about the publish-subscribe pattern:</para>

<itemizedlist>
  <listitem><para>A subscriber can connect to more than one publisher, using one 'connect' call each time. Data will then arrive and be interleaved ("fair-queued") so that no single publisher drowns out the others.</para></listitem>
  <listitem><para>If a publisher has no connected subscribers, then it will simply drop all messages.</para></listitem>
  <listitem><para>If you're using TCP, and a subscriber is slow, messages will queue up on the publisher. We'll look at how to protect publishers against this, using the "high-water mark" later.</para></listitem>
  <listitem><para>From &Oslash;MQ 3.x, filtering happens at the publisher side, when using a connected protocol (<literal>tcp://</literal> or <literal>ipc://</literal>). Using the <literal>epgm://</literal> protocol, filtering happens at the subscriber side. In &Oslash;MQ/2.x, all filtering happened at the subscriber side.</para></listitem>
</itemizedlist>
<para>This is how long it takes to receive and filter 10M messages on my laptop, which is an 2011-era Intel I7, fast but nothing special:</para>

<screen>ph@nb201103:~/work/git/zguide/examples/c$ time wuclient
Collecting updates from weather server...
Average temperature for zipcode '10001 ' was 28F

real    0m4.470s
user    0m0.000s
sys     0m0.008s
</screen>

</sect1>
<sect1>
<title>Divide and Conquer</title>
<para>As a final example (you are surely getting tired of juicy code and want to delve back into philological discussions about comparative abstractive norms), let's do a little supercomputing. Then coffee. Our supercomputing application is a fairly typical parallel processing model(<xref linkend="figure-5"/>). We have:</para>

<itemizedlist>
  <listitem><para>A ventilator that produces tasks that can be done in parallel</para></listitem>
  <listitem><para>A set of workers that process tasks</para></listitem>
  <listitem><para>A sink that collects results back from the worker processes</para></listitem>
</itemizedlist>
<para>In reality, workers run on superfast boxes, perhaps using GPUs (graphic processing units) to do the hard math. Here is the ventilator. It generates 100 tasks, each is a message telling the worker to sleep for some number of milliseconds:</para>

<example id="taskvent-c">
<title>Parallel task ventilator (taskvent.c)</title>
<programlisting language="c">
//
//  Task ventilator
//  Binds PUSH socket to tcp://localhost:5557
//  Sends batch of tasks to workers via that socket
//
#include "zhelpers.h"

int main (void) 
{
    void *context = zmq_ctx_new ();

    //  Socket to send messages on
    void *sender = zmq_socket (context, ZMQ_PUSH);
    zmq_bind (sender, "tcp://*:5557");

    //  Socket to send start of batch message on
    void *sink = zmq_socket (context, ZMQ_PUSH);
    zmq_connect (sink, "tcp://localhost:5558");

    printf ("Press Enter when the workers are ready: ");
    getchar ();
    printf ("Sending tasks to workers...\n");

    //  The first message is "0" and signals start of batch
    s_send (sink, "0");

    //  Initialize random number generator
    srandom ((unsigned) time (NULL));

    //  Send 100 tasks
    int task_nbr;
    int total_msec = 0;     //  Total expected cost in msecs
    for (task_nbr = 0; task_nbr &lt; 100; task_nbr++) {
        int workload;
        //  Random workload from 1 to 100msecs
        workload = randof (100) + 1;
        total_msec += workload;
        char string [10];
        sprintf (string, "%d", workload);
        s_send (sender, string);
    }
    printf ("Total expected cost: %d msec\n", total_msec);
    sleep (1);              //  Give 0MQ time to deliver

    zmq_close (sink);
    zmq_close (sender);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<figure id="figure-5">
    <title>Parallel Pipeline</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig5.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>Here is the worker application. It receives a message, sleeps for that number of seconds, then signals that it's finished:</para>

<example id="taskwork-c">
<title>Parallel task worker (taskwork.c)</title>
<programlisting language="c">
//
//  Task worker
//  Connects PULL socket to tcp://localhost:5557
//  Collects workloads from ventilator via that socket
//  Connects PUSH socket to tcp://localhost:5558
//  Sends results to sink via that socket
//
#include "zhelpers.h"

int main (void) 
{
    void *context = zmq_ctx_new ();

    //  Socket to receive messages on
    void *receiver = zmq_socket (context, ZMQ_PULL);
    zmq_connect (receiver, "tcp://localhost:5557");

    //  Socket to send messages to
    void *sender = zmq_socket (context, ZMQ_PUSH);
    zmq_connect (sender, "tcp://localhost:5558");

    //  Process tasks forever
    while (true) {
        char *string = s_recv (receiver);
        //  Simple progress indicator for the viewer
        fflush (stdout);
        printf ("%s.", string);

        //  Do the work
        s_sleep (atoi (string));
        free (string);

        //  Send results to sink
        s_send (sender, "");
    }
    zmq_close (receiver);
    zmq_close (sender);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<para>Here is the sink application. It collects the 100 tasks, then calculates how long the overall processing took, so we can confirm that the workers really were running in parallel, if there are more than one of them:</para>

<example id="tasksink-c">
<title>Parallel task sink (tasksink.c)</title>
<programlisting language="c">
//
//  Task sink
//  Binds PULL socket to tcp://localhost:5558
//  Collects results from workers via that socket
//
#include "zhelpers.h"

int main (void) 
{
    //  Prepare our context and socket
    void *context = zmq_ctx_new ();
    void *receiver = zmq_socket (context, ZMQ_PULL);
    zmq_bind (receiver, "tcp://*:5558");

    //  Wait for start of batch
    char *string = s_recv (receiver);
    free (string);

    //  Start our clock now
    int64_t start_time = s_clock ();

    //  Process 100 confirmations
    int task_nbr;
    for (task_nbr = 0; task_nbr &lt; 100; task_nbr++) {
        char *string = s_recv (receiver);
        free (string);
        if ((task_nbr / 10) * 10 == task_nbr)
            printf (":");
        else
            printf (".");
        fflush (stdout);
    }
    //  Calculate and report duration of batch
    printf ("Total elapsed time: %d msec\n", 
        (int) (s_clock () - start_time));

    zmq_close (receiver);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<para>The average cost of a batch is 5 seconds. When we start 1, 2, 4 workers we get results like this from the sink:</para>

<screen>#   1 worker
Total elapsed time: 5034 msec
#   2 workers
Total elapsed time: 2421 msec
#   4 workers
Total elapsed time: 1018 msec
</screen>

<para>Let's look at some aspects of this code in more detail:</para>

<itemizedlist>
  <listitem><para>The workers connect upstream to the ventilator, and downstream to the sink. This means you can add workers arbitrarily. If the workers bound to their endpoints, you would need (a) more endpoints and (b) to modify the ventilator and/or the sink each time you added a worker. We say that the ventilator and sink are 'stable' parts of our architecture and the workers are 'dynamic' parts of it.</para></listitem>
  <listitem><para>We have to synchronize the start of the batch with all workers being up and running. This is a fairly common gotcha in &Oslash;MQ and there is no easy solution. The 'connect' method takes a certain time. So when a set of workers connect to the ventilator, the first one to successfully connect will get a whole load of messages in that short time while the others are also connecting. If you don't synchronize the start of the batch somehow, the system won't run in parallel at all. Try removing the wait, and see.</para></listitem>
  <listitem><para>The ventilator's PUSH socket distributes tasks to workers (assuming they are all connected <emphasis>before</emphasis> the batch starts going out) evenly. This is called <emphasis>load-balancing</emphasis> and it's something we'll look at again in more detail.</para></listitem>
  <listitem><para>The sink's PULL socket collects results from workers evenly. This is called <emphasis>fair-queuing</emphasis>(<xref linkend="figure-6"/>).</para></listitem>
</itemizedlist>
<figure id="figure-6">
    <title>Fair Queuing</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig6.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>The pipeline pattern also exhibits the "slow joiner" syndrome, leading to accusations that PUSH sockets don't load balance properly. If you are using PUSH and PULL, and one of your workers gets way more messages than the others, it's because that PULL socket has joined faster than the others, and grabs a lot of messages before the others manage to connect.</para>

</sect1>
<sect1>
<title>Programming with &Oslash;MQ</title>
<para>Having seen some examples, you're eager to start using &Oslash;MQ in some apps. Before you start that, take a deep breath, chillax, and reflect on some basic advice that will save you stress and confusion.</para>

<itemizedlist>
  <listitem><para>Learn &Oslash;MQ step by step. It's just one simple API but it hides a world of possibilities. Take the possibilities slowly, master each one.</para></listitem>
  <listitem><para>Write nice code. Ugly code hides problems and makes it hard for others to help you. You might get used to meaningless variable names, but people reading your code won't. Use names that are real words, that say something other than "I'm too careless to tell you what this variable is really for". Use consistent indentation, clean layout. Write nice code and your world will be more comfortable.</para></listitem>
  <listitem><para>Test what you make as you make it. When your program doesn't work, you should know what five lines are to blame. This is especially true when you do &Oslash;MQ magic, which just <emphasis>won't</emphasis> work the first few times you try it.</para></listitem>
  <listitem><para>When you find that things don't work as expected, break your code into pieces, test each one, see which one is not working. &Oslash;MQ lets you make essentially modular code, use that to your advantage.</para></listitem>
  <listitem><para>Make abstractions (classes, methods, whatever) as you need them. If you copy/paste a lot of code you're going to copy/paste errors too.</para></listitem>
</itemizedlist>
<para>To illustrate, here is a fragment of code someone asked me to help fix:</para>

<programlisting language="c">
//  NOTE: do NOT reuse this example code!
static char *topic-str = "msg.x|";

void* pub-worker(void* arg){
    void *ctx = arg;
    assert(ctx);

    void *qskt = zmq-socket(ctx, ZMQ-REP);
    assert(qskt);

    int rc = zmq-connect(qskt, "inproc://querys");
    assert(rc == 0);

    void *pubskt = zmq-socket(ctx, ZMQ-PUB);
    assert(pubskt);

    rc = zmq-bind(pubskt, "inproc://publish");
    assert(rc == 0);

    uint8-t cmd;
    uint32-t nb;
    zmq-msg-t topic-msg, cmd-msg, nb-msg, resp-msg;

    zmq-msg-init-data(&amp;topic-msg, topic-str, strlen(topic-str) , NULL, NULL);

    fprintf(stdout,"WORKER: ready to receive messages\n");
    //  NOTE: do NOT reuse this example code, It's broken.
    //  e.g. topic-msg will be invalid the second time through
    while (1){
    zmq-msg-send(pubskt, &amp;topic-msg, ZMQ-SNDMORE);

    zmq-msg-init(&amp;cmd-msg);
    zmq-msg-recv(qskt, &amp;cmd-msg, 0);
    memcpy(&amp;cmd, zmq-msg-data(&amp;cmd-msg), sizeof(uint8-t));
    zmq-msg-send(pubskt, &amp;cmd-msg, ZMQ-SNDMORE);
    zmq-msg-close(&amp;cmd-msg);

    fprintf(stdout, "received cmd %u\n", cmd);

    zmq-msg-init(&amp;nb-msg);
    zmq-msg-recv(qskt, &amp;nb-msg, 0);
    memcpy(&amp;nb, zmq-msg-data(&amp;nb-msg), sizeof(uint32-t));
    zmq-msg-send(pubskt, &amp;nb-msg, 0);
    zmq-msg-close(&amp;nb-msg);

    fprintf(stdout, "received nb %u\n", nb);

    zmq-msg-init-size(&amp;resp-msg, sizeof(uint8-t));
    memset(zmq-msg-data(&amp;resp-msg), 0, sizeof(uint8-t));
    zmq-msg-send(qskt, &amp;resp-msg, 0);
    zmq-msg-close(&amp;resp-msg);

    }
    return NULL;
}
</programlisting>

<para>This is what I rewrote it to, as part of finding the bug:</para>

<programlisting language="c">
static void *
worker-thread (void *arg) {
    void *context = arg;
    void *worker = zmq-socket (context, ZMQ-REP);
    assert (worker);
    int rc;
    rc = zmq-connect (worker, "ipc://worker");
    assert (rc == 0);

    void *broadcast = zmq-socket (context, ZMQ-PUB);
    assert (broadcast);
    rc = zmq-bind (broadcast, "ipc://publish");
    assert (rc == 0);

    while (1) {
        char *part1 = s-recv (worker);
        char *part2 = s-recv (worker);
        printf ("Worker got [%s][%s]\n", part1, part2);
        s-sendmore (broadcast, "msg");
        s-sendmore (broadcast, part1);
        s-send     (broadcast, part2);
        free (part1);
        free (part2);

        s-send (worker, "OK");
    }
    return NULL;
}
</programlisting>

<para>In the end, the problem was that the application was passing sockets between threads, which crashes weirdly. Sockets are not threadsafe. It became legal behavior to migrate sockets from one thread to another in &Oslash;MQ/2.1, but this remains dangerous unless you use a "full memory barrier". If you don't know what that means, don't attempt socket migration.</para>

<sect2>
<title>Getting the Context Right</title>
<para>&Oslash;MQ applications always start by creating a <emphasis>context</emphasis>, and then using that for creating sockets. In C, it's the <literal>zmq-ctx-new[3]</literal> call. You should create and use exactly one context in your process. Technically, the context is the container for all sockets in a single process, and acts as the transport for <literal>inproc</literal> sockets, which are the fastest way to connect threads in one process. If at runtime a process has two contexts, these are like separate &Oslash;MQ instances. If that's explicitly what you want, OK, but otherwise remember:</para>

<para><emphasis role="bold">Do one <literal>zmq-ctx-new[3]</literal> at the start of your main line code, and one <literal>zmq-ctx-destroy[3]</literal> at the end.</emphasis></para>

<para>If you're using the <literal>fork()</literal> system call, each process needs its own context. If you do <literal>zmq-ctx-new[3]</literal> in the main process before calling <literal>fork()</literal>, the child processes get their own contexts. In general you want to do the interesting stuff in the child processes, and just manage these from the parent process.</para>

</sect2>
<sect2>
<title>Making a Clean Exit</title>
<para>Classy programmers share the same motto as classy hit men: always clean-up when you finish the job. When you use &Oslash;MQ in a language like Python, stuff gets automatically freed for you. But when using C you have to carefully free objects when you're finished with them, or you get memory leaks, unstable applications, and generally bad karma.</para>

<para>Memory leaks are one thing, but &Oslash;MQ is quite finicky about how you exit an application. The reasons are technical and painful but the upshot is that if you leave any sockets open, the <literal>zmq-ctx-destroy[3]</literal> function will hang forever. And even if you close all sockets, <literal>zmq-ctx-destroy[3]</literal> will by default wait forever if there are pending connects or sends. Unless you set the LINGER to zero on those sockets before closing them.</para>

<para>The &Oslash;MQ objects we need to worry about are messages, sockets, and contexts. Luckily it's quite simple, at least in simple programs:</para>

<itemizedlist>
  <listitem><para>Always close a message the moment you are done with it, using <literal>zmq-msg-close[3]</literal>.</para></listitem>
  <listitem><para>If you are opening and closing a lot of sockets, that's probably a sign you need to redesign your application.</para></listitem>
  <listitem><para>When you exit the program, close your sockets and then call <literal>zmq-ctx-destroy[3]</literal>. This destroys the context.</para></listitem>
</itemizedlist>
<para>This is at least for C development. In a language with automatic object destruction, sockets and contexts will be destroyed as you leave the scope. If you use exceptions you'll have to do the clean-up in something like a "final" block, the same as for any resource.</para>

<para>If you're doing multithreaded work, it gets rather more complex than this. We'll get to multithreading in the next chapter, but because some of you will, despite warnings, will try to run before you can safely walk, below is the quick and dirty guide to making a clean exit in a <emphasis>multithreaded</emphasis> &Oslash;MQ application.</para>

<para>First, do not try to use the same socket from multiple threads. No, don't explain why you think this would be excellent fun, just please don't do it. Next, you need to shut down each socket that has ongoing requests. The proper way is to set a low LINGER value (1 second), then close the socket. If your language binding doesn't do this for you automatically when you destroy a context, I'd suggest sending a patch.</para>

<para>Finally, destroy the context. This will cause any blocking receives or polls or sends in attached threads (i.e. which share the same context) to return with an error. Catch that error, and then set linger on, and close sockets in <emphasis>that</emphasis> thread, and exit. Do not destroy the same context twice. The zmq-ctx-destroy in the main thread will block until all sockets it knows about are safely closed.</para>

<para>Voila! It's complex and painful enough that any language binding author worth his or her salt will do this automatically and make the socket closing dance unnecessary.</para>

</sect2>
</sect1>
<sect1>
<title>Why We Needed &Oslash;MQ</title>
<para>Now that you've seen &Oslash;MQ in action, let's go back to the "why".</para>

<para>Many applications these days consist of components that stretch across some kind of network, either a LAN or the Internet. So many application developers end up doing some kind of messaging. Some developers use message queuing products, but most of the time they do it themselves, using TCP or UDP. These protocols are not hard to use, but there is a great difference between sending a few bytes from A to B, and doing messaging in any kind of reliable way.</para>

<para>Let's look at the typical problems we face when we start to connect pieces using raw TCP. Any reusable messaging layer would need to solve all or most these:</para>

<itemizedlist>
  <listitem><para>How do we handle I/O? Does our application block, or do we handle I/O in the background? This is a key design decision. Blocking I/O creates architectures that do not scale well. But background I/O can be very hard to do right.</para></listitem>
  <listitem><para>How do we handle dynamic components, i.e. pieces that go away temporarily? Do we formally split components into "clients" and "servers" and mandate that servers cannot disappear? What then if we want to connect servers to servers? Do we try to reconnect every few seconds?</para></listitem>
  <listitem><para>How do we represent a message on the wire? How do we frame data so it's easy to write and read, safe from buffer overflows, efficient for small messages, yet adequate for the very largest videos of dancing cats wearing party hats?</para></listitem>
  <listitem><para>How do we handle messages that we can't deliver immediately? Particularly, if we're waiting for a component to come back on-line? Do we discard messages, put them into a database, or into a memory queue?</para></listitem>
  <listitem><para>Where do we store message queues? What happens if the component reading from a queue is very slow, and causes our queues to build up? What's our strategy then?</para></listitem>
  <listitem><para>How do we handle lost messages? Do we wait for fresh data, request a resend, or do we build some kind of reliability layer that ensures messages cannot be lost? What if that layer itself crashes?</para></listitem>
  <listitem><para>What if we need to use a different network transport. Say, multicast instead of TCP unicast? Or IPv6? Do we need to rewrite the applications, or is the transport abstracted in some layer?</para></listitem>
  <listitem><para>How do we route messages? Can we send the same message to multiple peers? Can we send replies back to an original requester?</para></listitem>
  <listitem><para>How do we write an API for another language? Do we re-implement a wire-level protocol or do we repackage a library? If the former, how can we guarantee efficient and stable stacks? If the latter, how can we guarantee interoperability?</para></listitem>
  <listitem><para>How do we represent data so that it can be read between different architectures? Do we enforce a particular encoding for data types? How far is this the job of the messaging system rather than a higher layer?</para></listitem>
  <listitem><para>How do we handle network errors? Do we wait and retry, ignore them silently, or abort?</para></listitem>
</itemizedlist>
<para>Take a typical open source project like <ulink url="http://hadoop.apache.org/zookeeper/">Hadoop Zookeeper</ulink> and read the C API code in <ulink url="http://github.com/apache/zookeeper/blob/trunk/src/c/src/zookeeper.c">src/c/src/zookeeper.c</ulink>. As I write this, in 2010, the code is 3,200 lines of mystery and in there is an undocumented, client-server network communication protocol. I see it's efficient because it uses poll() instead of select(). But really, Zookeeper should be using a generic messaging layer and an explicitly documented wire level protocol. It is incredibly wasteful for teams to be building this particular wheel over and over.</para>

<para>But how to make a reusable messaging layer? Why, when so many projects need this technology, are people still doing it the hard way, by driving TCP sockets in their code, and solving the problems in that long list, over and over(<xref linkend="figure-7"/>)?</para>

<figure id="figure-7">
    <title>Messaging as it Starts</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig7.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>It turns out that building reusable messaging systems is really difficult, which is why few FOSS projects ever tried, and why commercial messaging products are complex, expensive, inflexible, and brittle. In 2006 iMatix designed <ulink url="http://www.amqp.org">AMQP</ulink> which started to give FOSS developers perhaps the first reusable recipe for a messaging system. AMQP works better than many other designs <ulink url="http://www.imatix.com/articles:whats-wrong-with-amqp">but remains relatively complex, expensive, and brittle</ulink>. It takes weeks to learn to use, and months to create stable architectures that don't crash when things get hairy.</para>

<para>Most messaging projects, like AMQP, that try to solve this long list of problems in a reusable way do so by inventing a new concept, the "broker", that does addressing, routing, and queuing. This results in a client-server protocol or a set of APIs on top of some undocumented protocol, that let applications speak to this broker. Brokers are an excellent thing in reducing the complexity of large networks. But adding broker-based messaging to a product like Zookeeper would make it worse, not better. It would mean adding an additional big box, and a new single point of failure. A broker rapidly becomes a bottleneck and a new risk to manage. If the software supports it, we can add a second, third, fourth broker and make some fail-over scheme. People do this. It creates more moving pieces, more complexity, more things to break.</para>

<para>And a broker-centric set-up needs its own operations team. You literally need to watch the brokers day and night, and beat them with a stick when they start misbehaving. You need boxes, and you need backup boxes, and you need people to manage those boxes. It is only worth doing for large applications with many moving pieces, built by several teams of people, over several years.</para>

<para>So small to medium application developers are trapped. Either they avoid network programming, and make monolithic applications that do not scale. Or they jump into network programming and make brittle, complex applications that are hard to maintain. Or they bet on a messaging product, and end up with scalable applications that depend on expensive, easily broken technology. There has been no really good choice, which is maybe why messaging is largely stuck in the last century and stirs strong emotions. Negative ones for users, gleeful joy for those selling support and licenses(<xref linkend="figure-8"/>).</para>

<figure id="figure-8">
    <title>Messaging as it Becomes</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig8.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>What we need is something that does the job of messaging but does it in such a simple and cheap way that it can work in any application, with close to zero cost. It should be a library that you just link with, without any other dependencies. No additional moving pieces, so no additional risk. It should run on any OS and work with any programming language.</para>

<para>And this is &Oslash;MQ: an efficient, embeddable library that solves most of the problems an application needs to become nicely elastic across a network, without much cost.</para>

<para>Specifically:</para>

<itemizedlist>
  <listitem><para>It handles I/O asynchronously, in background threads. These communicate with application threads using lock-free data structures, so concurrent &Oslash;MQ applications need no locks, semaphores, or other wait states.</para></listitem>
  <listitem><para>Components can come and go dynamically and &Oslash;MQ will automatically reconnect. This means you can start components in any order. You can create "service-oriented architectures" (SOAs) where services can join and leave the network at any time.</para></listitem>
  <listitem><para>It queues messages automatically when needed. It does this intelligently, pushing messages as close as possible to the receiver before queuing them.</para></listitem>
  <listitem><para>It has ways of dealing with over-full queues (called "high water mark"). When a queue is full, &Oslash;MQ automatically blocks senders, or throws away messages, depending on the kind of messaging you are doing (the so-called "pattern").</para></listitem>
  <listitem><para>It lets your applications talk to each other over arbitrary transports: TCP, multicast, in-process, inter-process. You don't need to change your code to use a different transport.</para></listitem>
  <listitem><para>It handles slow/blocked readers safely, using different strategies that depend on the messaging pattern.</para></listitem>
  <listitem><para>It lets you route messages using a variety of patterns such as request-reply and publish-subscribe. These patterns are how you create the topology, the structure of your network.</para></listitem>
  <listitem><para>It lets you create proxies to queue, forward, or capture messages with a single call. Proxies can reduce the interconnection complexity of a network.</para></listitem>
  <listitem><para>It delivers whole messages exactly as they were sent, using a simple framing on the wire. If you write a 10k message, you will receive a 10k message.</para></listitem>
  <listitem><para>It does not impose any format on messages. They are blobs of zero to gigabytes large. When you want to represent data you choose some other product on top, such as Google's protocol buffers, XDR, and others.</para></listitem>
  <listitem><para>It handles network errors intelligently. Sometimes it retries, sometimes it tells you an operation failed.</para></listitem>
  <listitem><para>It reduces your carbon footprint. Doing more with less CPU means your boxes use less power, and you can keep your old boxes in use for longer. Al Gore would love &Oslash;MQ.</para></listitem>
</itemizedlist>
<para>Actually &Oslash;MQ does rather more than this. It has a subversive effect on how you develop network-capable applications. Superficially it's a socket-inspired API on which you do <literal>zmq-msg-recv[3]</literal> and <literal>zmq-msg-send[3]</literal>. But message processing rapidly becomes the central loop, and your application soon breaks down into a set of message processing tasks. It is elegant and natural. And it scales: each of these tasks maps to a node, and the nodes talk to each other across arbitrary transports. Two nodes in one process (node is a thread), two nodes on one box (node is a process), or two boxes on one network (node is a box) - it's all the same, with no application code changes.</para>

</sect1>
<sect1>
<title>Socket Scalability</title>
<para>Let's see &Oslash;MQ's scalability in action. Here is a shell script that starts the weather server and then a bunch of clients in parallel:</para>

<screen>wuserver &amp;
wuclient 12345 &amp;
wuclient 23456 &amp;
wuclient 34567 &amp;
wuclient 45678 &amp;
wuclient 56789 &amp;
</screen>

<para>As the clients run, we take a look at the active processes using 'top', and we see something like (on a 4-core box):</para>

<screen>  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
 7136 ph        20   0 1040m 959m 1156 R  157 12.0  16:25.47 wuserver
 7966 ph        20   0 98608 1804 1372 S   33  0.0   0:03.94 wuclient
 7963 ph        20   0 33116 1748 1372 S   14  0.0   0:00.76 wuclient
 7965 ph        20   0 33116 1784 1372 S    6  0.0   0:00.47 wuclient
 7964 ph        20   0 33116 1788 1372 S    5  0.0   0:00.25 wuclient
 7967 ph        20   0 33072 1740 1372 S    5  0.0   0:00.35 wuclient
</screen>

<para>Let's think for a second about what is happening here. The weather server has a single socket, and yet here we have it sending data to five clients in parallel. We could have thousands of concurrent clients. The server application doesn't see them, doesn't talk to them directly. So the &Oslash;MQ socket is acting like a little server, silently accepting client requests and shoving data out to them as fast as the network can handle it. And it's a multithreaded server, squeezing more juice out of your CPU.</para>

</sect1>
<sect1>
<title>Upgrading from &Oslash;MQ/2.2 to &Oslash;MQ/3.2</title>
<para>In early 2012, &Oslash;MQ/3.2 became stable enough for live use and by the time you're reading this, it's what you really should be using. If you are still using 2.2, here's a quick summary of the changes, and how to migrate your code.</para>

<para>The main change in 3.x is that PUB-SUB works properly, as in, the publisher only sends subscribers stuff they actually want. In 2.x, publishers send everything and the subscribers filter. Simple, but not ideal for performance on a TCP network.</para>

<para>Most of the API is backwards compatible, except a few changes that went into 3.0 with little regard to the cost of breaking existing code. The syntax of <literal>zmq-send[3]</literal> and <literal>zmq-recv[3]</literal> changed, and <literal>ZMQ-NOBLOCK</literal> got rebaptized to <literal>ZMQ-DONTWAIT</literal>. So although I'd love to say, "you just recompile your code with the latest libzmq and everything will work", that's not how it is. For what it's worth, we banned such API breakage afterwards.</para>

<para>So the minimal change for C/C++ apps that use the low-level libzmq API is to replace all calls to <literal>zmq-send[3]</literal> with <literal>zmq-msg-send[3]</literal>, and <literal>zmq-recv[3]</literal> with <literal>zmq-msg-recv[3]</literal>. In other languages, your binding author may have done the work already. Note that these two functions now return -1 in case of error, and zero or more according to how many bytes were sent or received.</para>

<para>Other parts of the libzmq API became more consistent. We deprecated <literal>zmq-init[3]</literal> and <literal>zmq-term[3]</literal>, replacing them with <literal>zmq-ctx-new[3]</literal> and <literal>zmq-ctx-destroy[3]</literal>. We added <literal>zmq-ctx-set[3]</literal> to let you configure a context before starting to work with it.</para>

<para>Finally, we added context monitoring via the <literal>zmq-ctx-set-monitor[3]</literal> call, which lets you track connections and disconnections, and other events on sockets.</para>

</sect1>
<sect1>
<title>Warning - Unstable Paradigms!</title>
<para>Traditional network programming is built on the general assumption that one socket talks to one connection, one peer. There are multicast protocols but these are exotic. When we assume "one socket = one connection", we scale our architectures in certain ways. We create threads of logic where each thread work with one socket, one peer. We place intelligence and state in these threads.</para>

<para>In the &Oslash;MQ universe, sockets are doorways to fast little background communications engines that manage a whole set of connections automagically for you. You can't see, work with, open, close, or attach state to these connections. Whether you use blocking send or receive, or poll, all you can talk to is the socket, not the connections it manages for you. The connections are private and invisible, and this is the key to &Oslash;MQ's scalability.</para>

<para>Because your code, talking to a socket, can then handle any number of connections across whatever network protocols are around, without change. A messaging pattern sitting in &Oslash;MQ can scale more cheaply than a messaging pattern sitting in your application code.</para>

<para>So the general assumption no longer applies. As you read the code examples, your brain will try to map them to what you know. You will read "socket" and think "ah, that represents a connection to another node". That is wrong. You will read "thread" and your brain will again think, "ah, a thread represents a connection to another node", and again your brain will be wrong.</para>

<para>If you're reading this Guide for the first time, realize that until you actually write &Oslash;MQ code for a day or two (and maybe three or four days), you may feel confused, especially by how simple &Oslash;MQ makes things for you, and you may try to impose that general assumption on &Oslash;MQ, and it won't work. And then you will experience your moment of enlightenment and trust, that <emphasis>zap-pow-kaboom</emphasis> satori paradigm-shift moment when it all becomes clear.</para>

</sect1>
</chapter>
<chapter id="sockets-and-patterns">
<title>Sockets and Patterns</title>
<para>In Basics<xref linkend="basics"/> we took &Oslash;MQ for a drive, with some basic examples of the main &Oslash;MQ patterns: request-reply, publish-subscribe, and pipeline. In this chapter we're going to get our hands dirty and start to learn how to use these tools in real programs.</para>

<para>We'll cover:</para>

<itemizedlist>
  <listitem><para>How to create and work with &Oslash;MQ sockets.</para></listitem>
  <listitem><para>How to send and receive messages on sockets.</para></listitem>
  <listitem><para>How to build your apps around &Oslash;MQ's asynchronous I/O model.</para></listitem>
  <listitem><para>How to handle multiple sockets in one thread.</para></listitem>
  <listitem><para>How to handle fatal and non-fatal errors properly.</para></listitem>
  <listitem><para>How to handle interrupt signals like Ctrl-C.</para></listitem>
  <listitem><para>How to shutdown a &Oslash;MQ application cleanly.</para></listitem>
  <listitem><para>How to check a &Oslash;MQ application for memory leaks.</para></listitem>
  <listitem><para>How to send and receive multi-part messages.</para></listitem>
  <listitem><para>How to forward messages across networks.</para></listitem>
  <listitem><para>How to build a simple message queuing broker.</para></listitem>
  <listitem><para>How to write multithreaded applications with &Oslash;MQ.</para></listitem>
  <listitem><para>How to use &Oslash;MQ to signal between threads.</para></listitem>
  <listitem><para>How to use &Oslash;MQ to coordinate a network of nodes.</para></listitem>
  <listitem><para>How to create and use message envelopes for publish-subscribe.</para></listitem>
  <listitem><para>Using the high-water mark (HWM) to protect against memory overflows.</para></listitem>
</itemizedlist>
<sect1>
<title>The Socket API</title>
<para>To be perfectly honest, &Oslash;MQ does a kind of switch-and-bait on you. Which we don't apologize for, it's for your own good and hurts us more than it hurts you. It presents a familiar socket-based API, which requires great effort for us to hide a bunch of message-processing engines. However, the result will slowly fix your world-view about how to design and write distributed software.</para>

<para>Sockets are the de-facto standard API for network programming, as well as being useful for stopping your eyes from falling onto your cheeks. One thing that makes &Oslash;MQ especially tasty to developers is that it uses sockets and messages instead of some other arbitrary set of concepts. Kudos to Martin Sustrik for pulling this off. It turns "Message Oriented Middleware", a phrase guaranteed to send the whole room off to Catatonia, into "Extra Spicy Sockets!" which leaves us with a strange craving for pizza, and a desire to know more.</para>

<para>Like a favorite dish, &Oslash;MQ sockets are easy to digest. Sockets have a life in four parts, just like BSD sockets:</para>

<itemizedlist>
  <listitem><para>Creating and destroying sockets, which go together to form a karmic circle of socket life (see <literal>zmq-socket[3]</literal>, {{zmq-close[3]).</para></listitem>
  <listitem><para>Configuring sockets by setting options on them and checking them if necessary (see <literal>zmq-setsockopt[3]</literal>, {{zmq-getsockopt[3]).</para></listitem>
  <listitem><para>Plugging sockets onto the network topology by creating &Oslash;MQ connections to and from them (see <literal>zmq-bind[3]</literal>, {{zmq-connect[3]).</para></listitem>
  <listitem><para>Using the sockets to carry data by writing and receiving messages on them (see <literal>zmq-msg-send[3]</literal>, {{zmq-msg-recv[3]).</para></listitem>
</itemizedlist>
<para>Note that sockets are always void pointers, and messages (which we'll come to very soon) are structures. So in C you pass sockets as-such, but you pass addresses of messages in all functions that work with messages, like <literal>zmq-msg-send[3]</literal> and <literal>zmq-msg-recv[3]</literal>. As a mnemonic, realize that "in &Oslash;MQ all your sockets are belong to us", but messages are things you actually own in your code.</para>

<para>Creating, destroying, and configuring sockets works as you'd expect for any object. But remember that &Oslash;MQ is an asynchronous, elastic fabric. This has some impact on how we plug sockets into the network topology, and how we use the sockets after that.</para>

<sect2>
<title>Plugging Sockets Into the Topology</title>
<para>To create a connection between two nodes you use <literal>zmq-bind[3]</literal> in one node, and <literal>zmq-connect[3]</literal> in the other.  As a general rule of thumb, the node which does <literal>zmq-bind[3]</literal> is a "server", sitting on a well-known network address, and the node which does <literal>zmq-connect[3]</literal> is a "client", with unknown or arbitrary network addresses. Thus we say that we "bind a socket to an endpoint" and "connect a socket to an endpoint", the endpoint being that well-known network address.</para>

<para>&Oslash;MQ connections are somewhat different from old-fashioned TCP connections. The main notable differences are:</para>

<itemizedlist>
  <listitem><para>They go across an arbitrary transport (<literal>inproc</literal>, <literal>ipc</literal>, <literal>tcp</literal>, <literal>pgm</literal> or <literal>epgm</literal>). See <literal>zmq-inproc[7]</literal>, <literal>zmq-ipc[7]</literal>, <literal>zmq-tcp[7]</literal>, <literal>zmq-pgm[7]</literal>, and <literal>zmq-epgm[7]</literal>.</para></listitem>
  <listitem><para>One socket may have many outgoing and many incoming connections.</para></listitem>
  <listitem><para>There is no {{zmq-accept() method. When a socket is bound to an endpoint it automatically starts accepting connections.</para></listitem>
  <listitem><para>The network connection itself happens in the background, and &Oslash;MQ will automatically re-connect if the network connection is broken (e.g. if the peer disappears and then comes back).</para></listitem>
  <listitem><para>Your application code cannot work with these connections directly; they are encapsulated under the socket.</para></listitem>
</itemizedlist>
<para>Many architectures follow some kind of client-server model, where the server is the component that is most static, and the clients are the components that are most dynamic, i.e. they come and go the most. There are sometimes issues of addressing: servers will be visible to clients, but not necessarily vice-versa. So mostly it's obvious which node should be doing <literal>zmq-bind[3]</literal> (the server) and which should be doing <literal>zmq-connect[3]</literal> (the client). It also depends on the kind of sockets you're using, with some exceptions for unusual network architectures. We'll look at socket types later.</para>

<para>Now, imagine we start the client <emphasis>before</emphasis> we start the server. In traditional networking we get a big red Fail flag. But &Oslash;MQ lets us start and stop pieces arbitrarily. As soon as the client node does <literal>zmq-connect[3]</literal> the connection exists and that node can start to write messages to the socket. At some stage (hopefully before messages queue up so much that they start to get discarded, or the client blocks), the server comes alive, does a <literal>zmq-bind[3]</literal> and &Oslash;MQ starts to deliver messages.</para>

<para>A server node can bind to many endpoints (that is, a combination of protocol and address) and it can do this using a single socket. This means it will accept connections across different transports:</para>

<programlisting language="c">
zmq-bind (socket, "tcp://*:5555");
zmq-bind (socket, "tcp://*:9999");
zmq-bind (socket, "inproc://somename");
</programlisting>

<para>With most transports you cannot bind to the same endpoint twice, unlike for example in UDP. The <literal>ipc</literal> transport does however let one process bind to an endpoint already used by a first process. It's meant to allow a process to recover after a crash.</para>

<para>Although &Oslash;MQ tries to be neutral about which side binds, and which side connects, there are differences. We'll see these in more detail later. The upshot is that you should usually think in terms of "servers" as static parts of your topology, that bind to more-or-less fixed endpoints, and "clients" as dynamic parts that come and go and connect to these endpoints. Then, design your application around this model. The chances that it will "just work" are much better like that.</para>

<para>Sockets have types. The socket type defines the semantics of the socket, its policies for routing messages inwards and outwards, queuing, etc. You can connect certain types of socket together, e.g. a publisher socket and a subscriber socket. Sockets work together in "messaging patterns". We'll look at this in more detail later.</para>

<para>It's the ability to connect sockets in these different ways that gives &Oslash;MQ its basic power as a message queuing system. There are layers on top of this, such as proxies, which we'll get to later. But essentially, with &Oslash;MQ you define your network architecture by plugging pieces together like a child's construction toy.</para>

</sect2>
<sect2>
<title>Using Sockets to Carry Data</title>
<para>To send and receive messages you use the <literal>zmq-msg-send[3]</literal> and <literal>zmq-msg-recv[3]</literal> methods. The names are conventional but &Oslash;MQ's I/O model is different enough from the TCP model(<xref linkend="figure-9"/>) that you will need time to get your head around it.</para>

<figure id="figure-9">
    <title>TCP sockets are 1 to 1</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig9.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>Let's look at the main differences between TCP sockets and &Oslash;MQ sockets when it comes to working with data:</para>

<itemizedlist>
  <listitem><para>&Oslash;MQ sockets carry messages, rather than bytes (as in TCP) or frames (as in UDP). A message is length-specified binary data. We'll come to messages shortly, their design is optimized for performance and so a little tricky.</para></listitem>
  <listitem><para>&Oslash;MQ sockets do their I/O in a background thread. This means that messages arrive in local input queues, and are sent from local output queues, no matter what your application is busy doing.</para></listitem>
  <listitem><para>&Oslash;MQ sockets have one-to-N routing behavior built-in, according to the socket type.</para></listitem>
</itemizedlist>
<para>The <literal>zmq-msg-send[3]</literal> method does not actually send the message to the socket connection(s). It queues the message so that the I/O thread can send it asynchronously. It does not block except in some exception cases. So the message is not necessarily sent when <literal>zmq-msg-send[3]</literal> returns to your application. If you created a message using <literal>zmq-msg-init-data[3]</literal> you cannot reuse the data or free it, otherwise the I/O thread will rapidly find itself writing overwritten or unallocated garbage. This is a common mistake for beginners. We'll see a little later how to properly work with messages.</para>

</sect2>
<sect2>
<title>Unicast Transports</title>
<para>&Oslash;MQ provides a set of unicast transports (<literal>inproc</literal>, <literal>ipc</literal>, and <literal>tcp</literal>) and multicast transports (epgm, pgm). Multicast is an advanced technique that we'll come to later. Don't even start using it unless you know that your fanout ratios will make 1-to-N unicast impossible.</para>

<para>For most common cases, use <emphasis role="bold"><literal>tcp</literal></emphasis>, which is a <emphasis>disconnected TCP</emphasis> transport. It is elastic, portable, and fast enough for most cases. We call this 'disconnected' because &Oslash;MQ's <literal>tcp</literal> transport doesn't require that the endpoint exists before you connect to it. Clients and servers can connect and bind at any time, can go and come back, and it remains transparent to applications.</para>

<para>The inter-process <literal>ipc</literal> transport is disconnected, like <literal>tcp</literal>. It has one limitation: it does not yet work on Windows. By convention we use endpoint names with an ".ipc" extension to avoid potential conflict with other file names. On UNIX systems, if you use <literal>ipc</literal> endpoints you need to create these with appropriate permissions otherwise they may not be shareable between processes running under different user IDs. You must also make sure all processes can access the files, e.g. by running in the same working directory.</para>

<para>The inter-thread transport, <emphasis role="bold"><literal>inproc</literal></emphasis>, is a connected signaling transport. It is much faster than <literal>tcp</literal> or <literal>ipc</literal>. This transport has a specific limitation compared to <literal>ipc</literal> and <literal>tcp</literal>: <emphasis role="bold">the server must issue a bind before any client issues a connect</emphasis>. This is something future versions of &Oslash;MQ may fix, but at present this defines you use <literal>inproc</literal> sockets. We create and bind one socket, start the child threads, which create and connect the other sockets.</para>

</sect2>
<sect2>
<title>&Oslash;MQ is Not a Neutral Carrier</title>
<para>A common question that newcomers to &Oslash;MQ ask (it's one I asked myself) is, "how do I write an XYZ server in &Oslash;MQ?" For example, "how do I write an HTTP server in &Oslash;MQ?"</para>

<para>The implication is that if we use normal sockets to carry HTTP requests and responses, we should be able to use &Oslash;MQ sockets to do the same, only much faster and better.</para>

<para>Sadly the answer is "this is not how it works". &Oslash;MQ is not a neutral carrier, it imposes a framing on the transport protocols it uses. This framing is not compatible with existing protocols, which tend to use their own framing. For example, compare an HTTP request(<xref linkend="figure-10"/>), and a &Oslash;MQ request(<xref linkend="figure-10"/>), both over TCP/IP.</para>

<para>The HTTP request uses CR-LF as its simplest framing delimiter, whereas &Oslash;MQ uses a length-specified frame</para>

<figure id="figure-10">
    <title>HTTP On the Wire</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig10.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<figure id="figure-11">
    <title>&Oslash;MQ On the Wire</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig11.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>So you could write a HTTP-like protocol using &Oslash;MQ, using for example the request-reply socket pattern. But it would not be HTTP.</para>

<para>There is however a good answer to the question, "How can I make profitable use of &Oslash;MQ when making my new XYZ server?"  You need to implement whatever protocol you want to speak in any case, but you can connect that protocol server (which can be extremely thin) to a &Oslash;MQ backend that does the real work. The beautiful part here is that you can then extend your backend with code in any language, running locally or remotely, as you wish. Zed Shaw's <ulink url="http://www.mongrel2.org">Mongrel2</ulink> web server is a great example of such an architecture.</para>

</sect2>
<sect2>
<title>I/O Threads</title>
<para>We said that &Oslash;MQ does I/O in a background thread. One I/O thread (for all sockets) is sufficient for all but the most extreme applications. When you create a new context it starts with one I/O thread. The general rule of thumb is to allow one I/O thread per gigabyte of data in or out per second. To raise the number of I/O threads, use the <literal>zmq-ctx-set[3]</literal> call <emphasis>before</emphasis> creating any sockets:</para>

<programlisting language="c">
int io-threads = 4;
void *context = zmq-ctx-new ();
zmq-ctx-set (context, ZMQ-IO-THREADS, io-threads);
assert (zmq-ctx-get (context, ZMQ-IO-THREADS) == io-threads);
</programlisting>

<para>We've seen that one socket can handle many (dozens, thousands of) connections at once. This has a fundamental impact on how you write applications. A traditional networked application has one process or one thread per remote connection, and that process or thread handles one socket. &Oslash;MQ lets you collapse this entire structure into a single process, and then break it up as necessary for scaling.</para>

<para>If you are using &Oslash;MQ for inter-thread communications only, i.e. a multithreaded application that does no external socket I/O, you can set the I/O threads to zero. It's not a significant optimization though, more of a curiosity.</para>

</sect2>
</sect1>
<sect1>
<title>Messaging Patterns</title>
<para>Underneath the brown paper wrapping of &Oslash;MQ's socket API lies the world of messaging patterns. If you have a background in enterprise messaging, or know UDP well, these will be vaguely familiar. But to most &Oslash;MQ newcomers they are a surprise, we're so used to the TCP paradigm where a socket maps one-to-one to another node.</para>

<para>Let's recap briefly what &Oslash;MQ does for you. It delivers blobs of data (messages) to nodes, quickly and efficiently. You can map nodes to threads, processes, or nodes. &Oslash;MQ gives your applications a single socket API to work with, no matter what the actual transport (like in-process, inter-process, TCP, or multicast). It automatically reconnects to peers as they come and go. It queues messages at both sender and receiver, as needed. It manages these queues carefully to ensure processes don't run out of memory, overflowing to disk when appropriate. It handles socket errors. It does all I/O in background threads. It uses lock-free techniques for talking between nodes, so there are never locks, waits, semaphores, or deadlocks.</para>

<para>But cutting through that, it routes and queues messages according to precise recipes called <emphasis>patterns</emphasis>. It is these patterns that provide &Oslash;MQ's intelligence. They encapsulate our hard-earned experience of the best ways to distribute data and work. &Oslash;MQ's patterns are hard-coded but future versions may allow user-definable patterns.</para>

<para>&Oslash;MQ patterns are implemented by pairs of sockets with matching types. In other words, to understand &Oslash;MQ patterns you need to understand socket types and how they work together. Mostly this just takes study, there is little that is obvious at this level.</para>

<para>The built-in core &Oslash;MQ patterns are:</para>

<itemizedlist>
  <listitem><para><emphasis role="bold">Request-reply</emphasis>, which connects a set of clients to a set of services. This is a remote procedure call and task distribution pattern.</para></listitem>
  <listitem><para><emphasis role="bold">Publish-subscribe</emphasis>, which connects a set of publishers to a set of subscribers. This is a data distribution pattern.</para></listitem>
  <listitem><para><emphasis role="bold">Pipeline</emphasis>, which connects nodes in a fan-out / fan-in pattern that can have multiple steps, and loops. This is a parallel task distribution and collection pattern.</para></listitem>
</itemizedlist>
<para>We looked at each of these in the first chapter. There's one more pattern that people tend to try to use when they still think of &Oslash;MQ in terms of traditional TCP sockets: <emphasis role="bold">Exclusive pair</emphasis>, which connects two sockets exclusively. This is a pattern you should use only to connect two threads in a process. We'll see an example at the end of this chapter.</para>

<para>The <literal>zmq-socket[3]</literal> man page is fairly clear about the patterns, it's worth reading several times until it starts to make sense. These are the socket combinations that are valid for a connect-bind pair (either side can bind):</para>

<itemizedlist>
  <listitem><para>PUB and SUB</para></listitem>
  <listitem><para>REQ and REP</para></listitem>
  <listitem><para>REQ and ROUTER</para></listitem>
  <listitem><para>DEALER and REP</para></listitem>
  <listitem><para>DEALER and ROUTER</para></listitem>
  <listitem><para>DEALER and DEALER</para></listitem>
  <listitem><para>ROUTER and ROUTER</para></listitem>
  <listitem><para>PUSH and PULL</para></listitem>
  <listitem><para>PAIR and PAIR</para></listitem>
</itemizedlist>
<para>You'll also see references to XPUB and XSUB sockets, which we'll come to later (they're like raw versions of PUB and SUB). Any other combination will produce undocumented and unreliable results and future versions of &Oslash;MQ will probably return errors if you try them. You can and will of course bridge other socket types <emphasis>via code</emphasis>, i.e. read from one socket type and write to another.</para>

<sect2>
<title>High-level Messaging Patterns</title>
<para>These four core patterns are cooked-in to &Oslash;MQ. They are part of the &Oslash;MQ API, implemented in the core C++ library, and guaranteed to be available in all fine retail stores.</para>

<para>On top, we add <emphasis>high-level patterns</emphasis>. We build these high-level patterns on top of &Oslash;MQ and implement them in whatever language we're using for our application. They are not part of the core library, do not come with the &Oslash;MQ package, and exist in their own space, as part of the &Oslash;MQ community. For example the Majordomo pattern, which we explore in Reliable Request-Reply Patterns<xref linkend="reliable-request-reply"/>, sits in the GitHub Majordomo project in the ZeroMQ organization.</para>

<para>One of the things we aim to provide you with this guide are a set of such high-level patterns, both small (how to handle messages sanely) to large (how to make a reliable publish-subscribe architecture).</para>

</sect2>
<sect2>
<title>Working with Messages</title>
<para>On the wire, &Oslash;MQ messages are blobs of any size from zero upwards, fitting in memory. You do your own serialization using protobufs, msgpack, JSON, or whatever else your applications need to speak. It's wise to choose a data representation that is portable and fast, but you can make your own decisions about trade-offs.</para>

<para>In memory, &Oslash;MQ messages are <literal>zmq-msg-t</literal> structures (or classes depending on your language). Here are the basic ground rules for using &Oslash;MQ messages in C:</para>

<itemizedlist>
  <listitem><para>You create and pass around <literal>zmq-msg-t</literal> objects, not blocks of data.</para></listitem>
  <listitem><para>To read a message you use <literal>zmq-msg-init[3]</literal> to create an empty message, and then you pass that to <literal>zmq-msg-recv[3]</literal>.</para></listitem>
  <listitem><para>To write a message from new data, you use <literal>zmq-msg-init-size[3]</literal> to create a message and at the same time allocate a block of data of some size. You then fill that data using <literal>memcpy</literal>, and pass the message to <literal>zmq-msg-send[3]</literal>.</para></listitem>
  <listitem><para>To release (not destroy) a message you call <literal>zmq-msg-close[3]</literal>. This drops a reference, and eventually &Oslash;MQ will destroy the message.</para></listitem>
  <listitem><para>To access the message content you use <literal>zmq-msg-data[3]</literal>. To know how much data the message contains, use <literal>zmq-msg-size[3]</literal>.</para></listitem>
  <listitem><para>Do not use <literal>zmq-msg-move[3]</literal>, <literal>zmq-msg-copy[3]</literal>, or <literal>zmq-msg-init-data[3]</literal> unless you read the man pages and know precisely why you need these.</para></listitem>
</itemizedlist>
<para>Here is a typical chunk of code working with messages, which should be familiar if you have been paying attention. This is from the <literal>zhelpers.h</literal> file we use in all the examples:</para>

<programlisting language="c">
//  Receive 0MQ string from socket and convert into C string
static char *
s-recv (void *socket) {
    zmq-msg-t message;
    zmq-msg-init (&amp;message);
    int size = zmq-msg-recv (&amp;message, socket, 0);
    if (size == -1)
        return NULL;
    char *string = malloc (size + 1);
    memcpy (string, zmq-msg-data (&amp;message), size);
    zmq-msg-close (&amp;message);
    string [size] = 0;
    return (string);
}

//  Convert C string to 0MQ string and send to socket
static int
s-send (void *socket, char *string) {
    zmq-msg-t message;
    zmq-msg-init-size (&amp;message, strlen (string));
    memcpy (zmq-msg-data (&amp;message), string, strlen (string));
    int size = zmq-msg-send (&amp;message, socket, 0);
    zmq-msg-close (&amp;message);
    return (size);
}
</programlisting>

<para>You can easily extend this code to send and receive blobs of arbitrary length.</para>

<para>NOTE:</para>

<para>After you pass a message to <literal>zmq-msg-send[3]</literal>, &Oslash;MQ will clear the message, i.e., set the size to zero. You cannot send the same message twice, and you cannot access the message data after sending it.</para>

<para>If you want to send the same message more than once, create a second message, initialize it using <literal>zmq-msg-init[3]</literal> and then use <literal>zmq-msg-copy[3]</literal> to create a copy of the first message. This does not copy the data but the reference. You can then send the message twice (or more, if you create more copies) and the message will only be finally destroyed when the last copy is sent or closed.</para>

<para>&Oslash;MQ also supports <emphasis>multi-part</emphasis> messages, which let you send or receive a list of frames as a single on-the-wire message. This is widely used in real applications and we'll look at that later in this chapter and in Advanced Request-Reply Patterns<xref linkend="advanced-request-reply"/>.</para>

<para>Some other things that are worth knowing about messages:</para>

<itemizedlist>
  <listitem><para>&Oslash;MQ sends and receives them atomically, i.e. you get a whole message, or you don't get it at all. This is also true for multi-part messages.</para></listitem>
  <listitem><para>&Oslash;MQ does not send a message right away but at some indeterminate later time.</para></listitem>
  <listitem><para>You may send zero-length messages, e.g. for sending a signal from one thread to another.</para></listitem>
  <listitem><para>A message must fit in memory. If you want to send files of arbitrary sizes, you should break them into pieces and send each piece as a separate message.</para></listitem>
  <listitem><para>You must call <literal>zmq-msg-close[3]</literal> when finished with a message, in languages that don't automatically destroy objects when a scope closes.</para></listitem>
</itemizedlist>
<para>And to be necessarily repetitive, do not use <literal>zmq-msg-init-data[3]</literal>, yet. This is a zero-copy method and guaranteed to create trouble for you. There are far more important things to learn about &Oslash;MQ before you start to worry about shaving off microseconds.</para>

</sect2>
<sect2>
<title>Handling Multiple Sockets</title>
<para>In all the examples so far, the main loop of most examples has been:</para>

<orderedlist>
  <listitem><para>wait for message on socket</para></listitem>
  <listitem><para>process message</para></listitem>
  <listitem><para>repeat</para></listitem>
</orderedlist>
<para>What if we want to read from multiple endpoints at the same time? The simplest way is to connect one socket to all the endpoints and get &Oslash;MQ to do the fan-in for us. This is legal if the remote endpoints are in the same pattern but it would be wrong to e.g. connect a PULL socket to a PUB endpoint.</para>

<para>To actually read from multiple sockets at once, use <literal>zmq-poll[3]</literal>. An even better way might be to wrap <literal>zmq-poll[3]</literal> in a framework that turns it into a nice event-driven <emphasis>reactor</emphasis>, but it's significantly more work than we want to cover here.</para>

<para>Let's start with a dirty hack, partly for the fun of not doing it right, but mainly because it lets me show you how to do non-blocking socket reads. Here is a simple example of reading from two sockets using non-blocking reads. This rather confused program acts both as a subscriber to weather updates, and a worker for parallel tasks:</para>

<example id="msreader-c">
<title>Multiple socket reader (msreader.c)</title>
<programlisting language="c">
//
//  Reading from multiple sockets
//  This version uses a simple recv loop
//
#include "zhelpers.h"

int main (void) 
{
    //  Prepare our context and sockets
    void *context = zmq_ctx_new ();

    //  Connect to task ventilator
    void *receiver = zmq_socket (context, ZMQ_PULL);
    zmq_connect (receiver, "tcp://localhost:5557");

    //  Connect to weather server
    void *subscriber = zmq_socket (context, ZMQ_SUB);
    zmq_connect (subscriber, "tcp://localhost:5556");
    zmq_setsockopt (subscriber, ZMQ_SUBSCRIBE, "10001 ", 6);

    //  Process messages from both sockets
    //  We prioritize traffic from the task ventilator
    while (true) {
        //  Process any waiting tasks
        int rc;
        for (rc = 0; !rc; ) {
            zmq_msg_t task;
            zmq_msg_init (&amp;task);
            if ((rc = zmq_msg_recv (&amp;task, receiver, ZMQ_DONTWAIT)) != -1) {
                //  process task
            }
            zmq_msg_close (&amp;task);
        }
        //  Process any waiting weather updates
        for (rc = 0; !rc; ) {
            zmq_msg_t update;
            zmq_msg_init (&amp;update);
            if ((rc = zmq_msg_recv (&amp;update, subscriber, ZMQ_DONTWAIT)) != -1) {
                //  process weather update
            }
            zmq_msg_close (&amp;update);
        }
        //  No activity, so sleep for 1 msec
        s_sleep (1);
    }
    //  We never get here but clean up anyhow
    zmq_close (receiver);
    zmq_close (subscriber);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<para>The cost of this approach is some additional latency on the first message (the sleep at the end of the loop, when there are no waiting messages to process). This would be a problem in applications where sub-millisecond latency was vital. Also, you need to check the documentation for nanosleep() or whatever function you use to make sure it does not busy-loop.</para>

<para>You can treat the sockets fairly by reading first from one, then the second rather than prioritizing them as we did in this example.</para>

<para>Now let's see the same little senseless application done right, using <literal>zmq-poll[3]</literal>:</para>

<example id="mspoller-c">
<title>Multiple socket poller (mspoller.c)</title>
<programlisting language="c">
//
//  Reading from multiple sockets
//  This version uses zmq_poll()
//
#include "zhelpers.h"

int main (void) 
{
    void *context = zmq_ctx_new ();

    //  Connect to task ventilator
    void *receiver = zmq_socket (context, ZMQ_PULL);
    zmq_connect (receiver, "tcp://localhost:5557");

    //  Connect to weather server
    void *subscriber = zmq_socket (context, ZMQ_SUB);
    zmq_connect (subscriber, "tcp://localhost:5556");
    zmq_setsockopt (subscriber, ZMQ_SUBSCRIBE, "10001 ", 6);

    //  Initialize poll set
    zmq_pollitem_t items [] = {
        { receiver, 0, ZMQ_POLLIN, 0 },
        { subscriber, 0, ZMQ_POLLIN, 0 }
    };
    //  Process messages from both sockets
    while (true) {
        zmq_msg_t message;
        zmq_poll (items, 2, -1);
        if (items [0].revents &amp; ZMQ_POLLIN) {
            zmq_msg_init (&amp;message);
            zmq_msg_recv (&amp;message, receiver, 0);
            //  Process task
            zmq_msg_close (&amp;message);
        }
        if (items [1].revents &amp; ZMQ_POLLIN) {
            zmq_msg_init (&amp;message);
            zmq_msg_recv (&amp;message, subscriber, 0);
            //  Process weather update
            zmq_msg_close (&amp;message);
        }
    }
    //  We never get here
    zmq_close (receiver);
    zmq_close (subscriber);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<para>The items structure has these four members:</para>

<programlisting language="c">
typedef struct {
    void *socket;       //  0MQ socket to poll on
    int fd;             //  OR, native file handle to poll on
    short events;       //  Events to poll on
    short revents;      //  Events returned after poll
} zmq-pollitem-t;
</programlisting>

</sect2>
<sect2>
<title>Multi-part Messages</title>
<para>&Oslash;MQ lets us compose a message out of several frames, giving us a "multi-part message". Realistic applications use multi-part messages heavily, both for wrapping messages with address information, and for simple serialization. We'll look at address envelopes later.</para>

<para>What we'll learn now is simply how to safely (but blindly) read and write multi-part messages in any application (like a proxy) that needs to forward messages without inspecting them.</para>

<para>When you work with multi-part messages, each part is a <literal>zmq-msg</literal> item. E.g. if you are sending a message with five parts, you must construct, send, and destroy five <literal>zmq-msg</literal> items. You can do this in advance (and store the <literal>zmq-msg</literal> items in an array or structure), or as you send them, one by one.</para>

<para>Here is how we send the frames in a multi-part message (we receive each frame into a message object):</para>

<programlisting language="c">
zmq-msg-send (socket, &amp;message, ZMQ-SNDMORE);
...
zmq-msg-send (socket, &amp;message, ZMQ-SNDMORE);
...
zmq-msg-send (socket, &amp;message, 0);
</programlisting>

<para>Here is how we receive and process all the parts in a message, be it single part or multi-part:</para>

<programlisting language="c">
while (1) {
    zmq-msg-t message;
    zmq-msg-init (&amp;message);
    zmq-msg-recv (socket, &amp;message, 0);
    //  Process the message frame
    zmq-msg-close (&amp;message);
    int-t more;
    size-t more-size = sizeof (more);
    zmq-getsockopt (socket, ZMQ-RCVMORE, &amp;more, &amp;more-size);
    if (!more)
        break;      //  Last message frame
}
</programlisting>

<para>Some things to know about multi-part messages:</para>

<itemizedlist>
  <listitem><para>When you send a multi-part message, the first part (and all following parts) are only actually sent on the wire when you send the final part.</para></listitem>
  <listitem><para>If you are using <literal>zmq-poll[3]</literal>, when you receive the first part of a message, all the rest has also arrived.</para></listitem>
  <listitem><para>You will receive all parts of a message, or none at all.</para></listitem>
  <listitem><para>Each part of a message is a separate <literal>zmq-msg</literal> item.</para></listitem>
  <listitem><para>You will receive all parts of a message whether or not you check the RCVMORE option.</para></listitem>
  <listitem><para>On sending, &Oslash;MQ queues message frames in memory until the last is received, then sends them all.</para></listitem>
  <listitem><para>There is no way to cancel a partially sent message, except by closing the socket.</para></listitem>
</itemizedlist>
</sect2>
<sect2>
<title>Intermediaries and Proxies</title>
<para>&Oslash;MQ aims for decentralized intelligence but that doesn't mean your network is empty space in the middle. It's filled with message-aware infrastructure and quite often, we build that infrastructure with &Oslash;MQ. The &Oslash;MQ plumbing can range from tiny pipes to full-blown service-oriented brokers. The messaging industry calls this "intermediation", meaning that the stuff in the middle deals with either side. In &Oslash;MQ we call these proxies, queues, forwarders, device, or brokers, depending on the context.</para>

<para>This pattern is extremely common in the real world and is why our societies and economies are filled with intermediaries who have no other real function than to reduce the complexity and scaling costs of larger networks. Real-world intermediaries are typically called wholesalers, distributors, managers, etc.</para>

</sect2>
<sect2>
<title>The Dynamic Discovery Problem</title>
<para>One of the problems you will hit as you design larger distributed architectures is discovery. That is, how do pieces know about each other? It's especially difficult if pieces come and go, thus we can call this the "dynamic discovery problem".</para>

<para>There are several solutions to dynamic discovery. The simplest is to entirely avoid it by hard-coding (or configuring) the network architecture so discovery is done by hand. That is, when you add a new piece, you reconfigure the network to know about it.</para>

<para>In practice this leads to increasingly fragile and hard-to-manage architectures. Let's say you have one publisher and a hundred subscribers. You connect each subscriber to the publisher by configuring a publisher endpoint in each subscriber. That's easy(<xref linkend="figure-12"/>). Subscribers are dynamic, the publisher is static. Now say you add more publishers. Suddenly it's not so easy any more. If you continue to connect each subscriber to each publisher, the cost of avoiding dynamic discovery gets higher and higher.</para>

<figure id="figure-12">
    <title>Small-scale Pub-Sub Network</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig12.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>There are quite a few answers to this but the very simplest answer is to add an intermediary, that is, a static point in the network to which all other nodes connect. In classic messaging, this is the job of the "message broker". &Oslash;MQ doesn't come with a message broker as such, but it lets us build intermediaries quite easily.</para>

<para>You might wonder, if all networks eventually get large enough to need intermediaries, why don't we simply have a message broker in place for all applications? For beginners, it's a fair compromise. Just always use a star topology, forget about performance, and things will usually work. However message brokers are greedy things; in their role as central intermediaries, they become too complex, too stateful, and eventually a problem.</para>

<para>It's better to think of intermediaries as simple stateless message switches. The best analogy is an HTTP proxy; it's there but doesn't have any special role. Adding a pub-sub proxy solves the dynamic discovery problem in our example. We set the proxy in the "middle" of the network(<xref linkend="figure-13"/>). The proxy opens an XSUB socket, an XPUB socket, and binds each to well-known IP addresses and ports. Then all other processes connect to the proxy, instead of to each other. It becomes trivial to add more subscribers or publishers.</para>

<figure id="figure-13">
    <title>Pub-Sub Network with a Proxy</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig13.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>We need XPUB and XSUB sockets because &Oslash;MQ does subscription forwarding: SUB sockets actually send subscriptions to PUB sockets as special messages. The proxy has to forward these as well, by reading them from the XPUB socket and writing them to the XSUB socket. This is the main use-case for XSUB and XPUB(<xref linkend="figure-14"/>).</para>

<figure id="figure-14">
    <title>Extended Publish-Subscribe</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig14.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

</sect2>
<sect2>
<title>Shared Queue (DEALER and ROUTER sockets)</title>
<para>In the Hello World client-server application we have one client that talks to one service. However in real cases we usually need to allow multiple services as well as multiple clients. This lets us scale up the power of the service (many threads or processes or nodes rather than just one). The only constraint is that services must be stateless, all state being in the request or in some shared storage such as a database.</para>

<para>There are two ways to connect multiple clients to multiple servers. The brute-force way is to connect each client socket to multiple service endpoints. One client socket can connect to multiple service sockets, and the REQ socket will then load-balance requests among these services. Let's say you connect a client socket to three service endpoints, A, B, and C. The client makes requests R1, R2, R3, R4. R1 and R4 go to service A, R2 goes to B, and R3 goes to service C(<xref linkend="figure-15"/>).</para>

<figure id="figure-15">
    <title>Load-balancing of Requests</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig15.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>This design lets you add more clients cheaply. You can also add more services. Each client will load-balance its requests to the services. But each client has to know the service topology. If you have 100 clients and then you decide to add three more services, you need to reconfigure and restart 100 clients in order for the clients to know about the three new services.</para>

<para>That's clearly not the kind of thing we want to be doing at 3am when our supercomputing cluster has run out of resources and we desperately need to add a couple of hundred new service nodes. Too many static pieces are like liquid concrete: knowledge is distributed and the more static pieces you have, the more effort it is to change the topology. What we want is something sitting in between clients and services that centralizes all knowledge of the topology. Ideally, we should be able to add and remove services or clients at any time without touching any other part of the topology.</para>

<para>So we'll write a little message queuing broker that gives us this flexibility. The broker binds to two endpoints, a frontend for clients and a backend for services. It then uses <literal>zmq-poll[3]</literal> to monitor these two sockets for activity and when it has some, it shuttles messages between its two sockets. It doesn't actually manage any queues explicitly -- &Oslash;MQ does that automatically on each socket.</para>

<para>When you use REQ to talk to REP you get a strictly synchronous request-reply dialog. The client sends a request. The service reads the request and sends a reply. The client then reads the reply. If either the client or the service try to do anything else (e.g. sending two requests in a row without waiting for a response) they will get an error.</para>

<para>But our broker has to be non-blocking. Obviously we can use <literal>zmq-poll[3]</literal> to wait for activity on either socket, but we can't use REP and REQ.</para>

<para>Luckily there are two sockets called DEALER and ROUTER that let you do non-blocking request-response. You'll see in Advanced Request-Reply Patterns<xref linkend="advanced-request-reply"/> how DEALER and ROUTER sockets let you build all kinds of asynchronous request-reply flows. For now, we're just going to see how DEALER and ROUTER let us extend REQ-REP across an intermediary, that is, our little broker.</para>

<para>In this simple stretched request-reply pattern, REQ talks to ROUTER and DEALER talks to REP. In between the DEALER and ROUTER we have to have code (like our broker) that pulls messages off the one socket and shoves them onto the other(<xref linkend="figure-16"/>).</para>

<figure id="figure-16">
    <title>Extended Request-reply</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig16.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>The request-reply broker binds to two endpoints, one for clients to connect to (the frontend socket) and one for workers to connect to (the backend). To test this broker, you will want to change your workers so they connect to the backend socket. Here is a client that shows what I mean:</para>

<example id="rrclient-c">
<title>Request-reply client (rrclient.c)</title>
<programlisting language="c">
//
//  Hello World client
//  Connects REQ socket to tcp://localhost:5559
//  Sends "Hello" to server, expects "World" back
//
#include "zhelpers.h"

int main (void) 
{
    void *context = zmq_ctx_new ();

    //  Socket to talk to server
    void *requester = zmq_socket (context, ZMQ_REQ);
    zmq_connect (requester, "tcp://localhost:5559");

    int request_nbr;
    for (request_nbr = 0; request_nbr != 10; request_nbr++) {
        s_send (requester, "Hello");
        char *string = s_recv (requester);
        printf ("Received reply %d [%s]\n", request_nbr, string);
        free (string);
    }
    zmq_close (requester);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<para>Here is the worker:</para>

<example id="rrworker-c">
<title>Request-reply worker (rrworker.c)</title>
<programlisting language="c">
//
//  Hello World worker
//  Connects REP socket to tcp://*:5560
//  Expects "Hello" from client, replies with "World"
//
#include "zhelpers.h"

int main (void) 
{
    void *context = zmq_ctx_new ();

    //  Socket to talk to clients
    void *responder = zmq_socket (context, ZMQ_REP);
    zmq_connect (responder, "tcp://localhost:5560");

    while (true) {
        //  Wait for next request from client
        char *string = s_recv (responder);
        printf ("Received request: [%s]\n", string);
        free (string);

        //  Do some 'work'
        sleep (1);

        //  Send reply back to client
        s_send (responder, "World");
    }
    //  We never get here but clean up anyhow
    zmq_close (responder);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<para>And here is the broker, which properly handles multi-part messages:</para>

<example id="rrbroker-c">
<title>Request-reply broker (rrbroker.c)</title>
<programlisting language="c">
//
//  Simple request-reply broker
//
#include "zhelpers.h"

int main (void) 
{
    //  Prepare our context and sockets
    void *context = zmq_ctx_new ();
    void *frontend = zmq_socket (context, ZMQ_ROUTER);
    void *backend  = zmq_socket (context, ZMQ_DEALER);
    zmq_bind (frontend, "tcp://*:5559");
    zmq_bind (backend,  "tcp://*:5560");

    //  Initialize poll set
    zmq_pollitem_t items [] = {
        { frontend, 0, ZMQ_POLLIN, 0 },
        { backend,  0, ZMQ_POLLIN, 0 }
    };
    //  Switch messages between sockets
    while (true) {
        zmq_msg_t message;
        int more;           //  Multipart detection

        zmq_poll (items, 2, -1);
        if (items [0].revents &amp; ZMQ_POLLIN) {
            while (true) {
                //  Process all parts of the message
                zmq_msg_init (&amp;message);
                zmq_msg_recv (&amp;message, frontend, 0);
                size_t more_size = sizeof (more);
                zmq_getsockopt (frontend, ZMQ_RCVMORE, &amp;more, &amp;more_size);
                zmq_msg_send (&amp;message, backend, more? ZMQ_SNDMORE: 0);
                zmq_msg_close (&amp;message);
                if (!more)
                    break;      //  Last message part
            }
        }
        if (items [1].revents &amp; ZMQ_POLLIN) {
            while (true) {
                //  Process all parts of the message
                zmq_msg_init (&amp;message);
                zmq_msg_recv (&amp;message, backend, 0);
                size_t more_size = sizeof (more);
                zmq_getsockopt (backend, ZMQ_RCVMORE, &amp;more, &amp;more_size);
                zmq_msg_send (&amp;message, frontend, more? ZMQ_SNDMORE: 0);
                zmq_msg_close (&amp;message);
                if (!more)
                    break;      //  Last message part
            }
        }
    }
    //  We never get here but clean up anyhow
    zmq_close (frontend);
    zmq_close (backend);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<para>Using a request-reply broker makes your client-server architectures easier to scale since clients don't see workers, and workers don't see clients. The only static node is the broker in the middle(<xref linkend="figure-17"/>).</para>

<figure id="figure-17">
    <title>Request-reply Broker</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig17.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

</sect2>
<sect2>
<title>&Oslash;MQ's Built-in Proxy Function</title>
<para>It turns out that the core loop in the previous section's rrbroker is very useful, and reusable. It lets us build pub-sub forwarders and shared queues and other little intermediaries, with very little effort. &Oslash;MQ wraps this up in a single method, <literal>zmq-proxy[3]</literal>:</para>

<programlisting language="c">
zmq-proxy (frontend, backend, capture);
</programlisting>

<para>The two (or three sockets, if we want to capture data) must be properly connected, bound, configured. When we call the <literal>zmq-proxy</literal> method it's exactly like starting the main loop of rrbroker. Let's rewrite the request-reply broker to call <literal>zmq-proxy</literal>, and re-badge this as an expensive-sounding "message queue" (people have charged houses for code that did less):</para>

<example id="msgqueue-c">
<title>Message queue broker (msgqueue.c)</title>
<programlisting language="c">
//
//  Simple message queuing broker
//  Same as request-reply broker but using QUEUE device
//
#include "zhelpers.h"

int main (void) 
{
    void *context = zmq_ctx_new ();

    //  Socket facing clients
    void *frontend = zmq_socket (context, ZMQ_ROUTER);
    int rc = zmq_bind (frontend, "tcp://*:5559");
    assert (rc == 0);

    //  Socket facing services
    void *backend = zmq_socket (context, ZMQ_DEALER);
    rc = zmq_bind (backend, "tcp://*:5560");
    assert (rc == 0);

    //  Start the proxy
    zmq_proxy (frontend, backend, NULL);

    //  We never get here...
    zmq_close (frontend);
    zmq_close (backend);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<para>If you're like most &Oslash;MQ users, at this stage your mind is starting to think, "what kind of evil stuff can I do if I plug random socket types into the proxy?"  The short answer is: try it and work out what is happening. In practice you would usually stick to ROUTER/DEALER, XSUB/XPUB, or PULL/PUSH.</para>

</sect2>
<sect2>
<title>Transport Bridging</title>
<para>A frequent request from &Oslash;MQ users is "how do I connect my &Oslash;MQ network with technology X?" where X is some other networking or messaging technology. The simple answer is to build a "bridge". A bridge is a small application that speaks one protocol at one socket, and converts to/from a second protocol at another socket. A protocol interpreter, if you like. A common bridging problem in &Oslash;MQ is to bridge two transports or networks.</para>

<para>As an example, we're going to write a little proxy that sits in between a publisher and a set of subscribers, bridging two networks. The frontend socket (SUB) faces the internal network, where the weather server is sitting, and the backend (PUB) faces subscribers on the external network. It subscribes to the weather service on the frontend socket, and republishes its data on the backend socket(<xref linkend="figure-18"/>).</para>

<example id="wuproxy-c">
<title>Weather update proxy (wuproxy.c)</title>
<programlisting language="c">
//
//  Weather proxy device
//
#include "zhelpers.h"

int main (void)
{
    void *context = zmq_ctx_new ();

    //  This is where the weather server sits
    void *frontend = zmq_socket (context, ZMQ_XSUB);
    zmq_connect (frontend, "tcp://192.168.55.210:5556");

    //  This is our public endpoint for subscribers
    void *backend = zmq_socket (context, ZMQ_XPUB);
    zmq_bind (backend, "tcp://10.1.1.0:8100");

    //  Run the proxy until the user interrupts us
    zmq_proxy (frontend, backend, NULL);
    
    zmq_close (frontend);
    zmq_close (backend);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<para>It looks very similar to the earlier proxy example but the key part is that the frontend and backend sockets are on two different networks. We can use this model for example to connect a multicast network (<literal>pgm</literal> transport) to a TCP publisher.</para>

<figure id="figure-18">
    <title>Pub-Sub Forwarder Proxy</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig18.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

</sect2>
</sect1>
<sect1>
<title>Handling Errors and ETERM</title>
<para>&Oslash;MQ's error handling philosophy is a mix of fail-fast and resilience. Processes, we believe, should be as vulnerable as possible to internal errors, and as robust as possible against external attacks and errors. To give an analogy, a living cell will self-destruct if it detects a single internal error, yet it will resist attack from the outside by all means possible.</para>

<para>Assertions, which pepper the &Oslash;MQ code, are absolutely vital to robust code, they just have to be on the right side of the cellular wall. And there should be such a wall. If it is unclear whether a fault is internal or external, that is a design flaw to be fixed. In C/C++, assertions stop the application immediately with an error. In other languages you may get exceptions or halts.</para>

<para>When &Oslash;MQ detects an external fault it returns an error to the calling code. In some rare cases it drops messages silently, if there is no obvious strategy for recovering from the error.</para>

<para>In most of the C examples we've seen so far there's been no error handling. <emphasis role="bold">Real code should do error handling on every single &Oslash;MQ call</emphasis>. If you're using a language binding other than C, the binding may handle errors for you. In C you do need to do this yourself. There are some simple rules, starting with POSIX conventions:</para>

<itemizedlist>
  <listitem><para>Methods that create objects return NULL if they fail.</para></listitem>
  <listitem><para>Methods that process data may return the number of bytes processed, or -1 on an error or failure.</para></listitem>
  <listitem><para>Other methods return 0 on success and -1 on an error or failure.</para></listitem>
  <listitem><para>The error code is provided in <literal>errno</literal> or <literal>zmq-errno[3]</literal>.</para></listitem>
  <listitem><para>A descriptive error text for logging is provided by <literal>zmq-strerror[3]</literal>.</para></listitem>
</itemizedlist>
<para>For example:</para>

<programlisting language="c">
void *context = zmq-ctx-new ();
assert (context);
void *socket = zmq-socket (context, ZMQ-REP);
assert (socket);
int rc = zmq-bind (socket, "tcp://*:5555");
if (rc != 0) {
    printf ("E: bind failed: %s\n", strerror (errno));
    return -1;
}
</programlisting>

<para>There are two main exceptional conditions that you may want to handle as non-fatal:</para>

<itemizedlist>
  <listitem><para>When a thread calls <literal>zmq-msg-recv[3]</literal> with the <literal>ZMQ-DONTWAIT</literal> option and there is no waiting data. &Oslash;MQ will return -1 and set <literal>errno</literal> to <literal>EAGAIN</literal>.</para></listitem>
  <listitem><para>When a thread calls <literal>zmq-ctx-destroy[3]</literal> and other threads are doing blocking work. The <literal>zmq-ctx-destroy[3]</literal> call closes the context and all blocking calls exit with -1, and errno set to <literal>ETERM</literal>.</para></listitem>
</itemizedlist>
<para>In C/C++, asserts can be removed entirely in optimized code, so don't make the mistake of wrapping the whole &Oslash;MQ call in an assert(). It looks neat, then the optimizer removes all the asserts and the calls you want to make, and your application breaks in impressive ways.</para>

<para>Let's see how to shut down a process cleanly. We'll take the parallel pipeline example from the previous section. If we've started a whole lot of workers in the background, we now want to kill them when the batch is finished. Let's do this by sending a kill message to the workers. The best place to do this is the sink, since it really knows when the batch is done.</para>

<para>How do we connect the sink to the workers? The PUSH/PULL sockets are one-way only. The standard &Oslash;MQ answer is: create a new socket flow for each type of problem you need to solve. We'll use a publish-subscribe model to send kill messages to the workers(<xref linkend="figure-19"/>):</para>

<itemizedlist>
  <listitem><para>The sink creates a PUB socket on a new endpoint.</para></listitem>
  <listitem><para>Workers bind their input socket to this endpoint.</para></listitem>
  <listitem><para>When the sink detects the end of the batch it sends a kill to its PUB socket.</para></listitem>
  <listitem><para>When a worker detects this kill message, it exits.</para></listitem>
</itemizedlist>
<para>It doesn't take much new code in the sink:</para>

<programlisting language="c">
void *control = zmq-socket (context, ZMQ-PUB);
zmq-bind (control, "tcp://*:5559");
...
//  Send kill signal to workers
zmq-msg-init-data (&amp;message, "KILL", 5);
zmq-msg-send (control, &amp;message, 0);
zmq-msg-close (&amp;message);
</programlisting>

<figure id="figure-19">
    <title>Parallel Pipeline with Kill Signaling</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig19.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>Here is the worker process, which manages two sockets (a PULL socket getting tasks, and a SUB socket getting control commands) using the <literal>zmq-poll[3]</literal> technique we saw earlier:</para>

<example id="taskwork2-c">
<title>Parallel task worker with kill signaling (taskwork2.c)</title>
<programlisting language="c">
//
//  Task worker - design 2
//  Adds pub-sub flow to receive and respond to kill signal
//
#include "zhelpers.h"

int main (void) 
{
    void *context = zmq_ctx_new ();

    //  Socket to receive messages on
    void *receiver = zmq_socket (context, ZMQ_PULL);
    zmq_connect (receiver, "tcp://localhost:5557");

    //  Socket to send messages to
    void *sender = zmq_socket (context, ZMQ_PUSH);
    zmq_connect (sender, "tcp://localhost:5558");

    //  Socket for control input
    void *controller = zmq_socket (context, ZMQ_SUB);
    zmq_connect (controller, "tcp://localhost:5559");
    zmq_setsockopt (controller, ZMQ_SUBSCRIBE, "", 0);

    //  Process messages from receiver and controller
    zmq_pollitem_t items [] = {
        { receiver, 0, ZMQ_POLLIN, 0 },
        { controller, 0, ZMQ_POLLIN, 0 }
    };
    //  Process messages from both sockets
    while (true) {
        zmq_msg_t message;
        zmq_poll (items, 2, -1);
        if (items [0].revents &amp; ZMQ_POLLIN) {
            zmq_msg_init (&amp;message);
            zmq_msg_recv (&amp;message, receiver, 0);

            //  Do the work
            s_sleep (atoi ((char *) zmq_msg_data (&amp;message)));

            //  Send results to sink
            zmq_msg_init (&amp;message);
            zmq_msg_send (&amp;message, sender, 0);

            //  Simple progress indicator for the viewer
            printf (".");
            fflush (stdout);

            zmq_msg_close (&amp;message);
        }
        //  Any waiting controller command acts as 'KILL'
        if (items [1].revents &amp; ZMQ_POLLIN)
            break;                      //  Exit loop
    }
    //  Finished
    zmq_close (receiver);
    zmq_close (sender);
    zmq_close (controller);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<para>Here is the modified sink application. When it's finished collecting results it broadcasts a kill message to all workers:</para>

<example id="tasksink2-c">
<title>Parallel task sink with kill signaling (tasksink2.c)</title>
<programlisting language="c">
//
//  Task sink - design 2
//  Adds pub-sub flow to send kill signal to workers
//
#include "zhelpers.h"

int main (void) 
{
    void *context = zmq_ctx_new ();

    //  Socket to receive messages on
    void *receiver = zmq_socket (context, ZMQ_PULL);
    zmq_bind (receiver, "tcp://*:5558");

    //  Socket for worker control
    void *controller = zmq_socket (context, ZMQ_PUB);
    zmq_bind (controller, "tcp://*:5559");

    //  Wait for start of batch
    char *string = s_recv (receiver);
    free (string);

    //  Start our clock now
    int64_t start_time = s_clock ();

    //  Process 100 confirmations
    int task_nbr;
    for (task_nbr = 0; task_nbr &lt; 100; task_nbr++) {
        char *string = s_recv (receiver);
        free (string);
        if ((task_nbr / 10) * 10 == task_nbr)
            printf (":");
        else
            printf (".");
        fflush (stdout);
    }
    printf ("Total elapsed time: %d msec\n", 
        (int) (s_clock () - start_time));

    //  Send kill signal to workers
    s_send (controller, "KILL");

    //  Finished
    sleep (1);              //  Give 0MQ time to deliver

    zmq_close (receiver);
    zmq_close (controller);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
</sect1>
<sect1>
<title>Handling Interrupt Signals</title>
<para>Realistic applications need to shut down cleanly when interrupted with Ctrl-C or another signal such as SIGTERM. By default, these simply kill the process, meaning messages won't be flushed, files won't be closed cleanly, etc.</para>

<para>Here is how we handle a signal in various languages:</para>

<example id="interrupt-c">
<title>Handling Ctrl-C cleanly (interrupt.c)</title>
<programlisting language="c">
//
//  Shows how to handle Ctrl-C
//
#include &lt;zmq.h&gt;
#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;

//  ---------------------------------------------------------------------
//  Signal handling
//
//  Call s_catch_signals() in your application at startup, and then exit 
//  your main loop if s_interrupted is ever 1. Works especially well with 
//  zmq_poll.

static int s_interrupted = 0;
static void s_signal_handler (int signal_value)
{
    s_interrupted = 1;
}

static void s_catch_signals (void)
{
    struct sigaction action;
    action.sa_handler = s_signal_handler;
    action.sa_flags = 0;
    sigemptyset (&amp;action.sa_mask);
    sigaction (SIGINT, &amp;action, NULL);
    sigaction (SIGTERM, &amp;action, NULL);
}

int main (void)
{
    void *context = zmq_ctx_new ();
    void *socket = zmq_socket (context, ZMQ_REP);
    zmq_bind (socket, "tcp://*:5555");

    s_catch_signals ();
    while (true) {
        //  Blocking read will exit on a signal
        zmq_msg_t message;
        zmq_msg_init (&amp;message);
        zmq_msg_recv (&amp;message, socket, 0);

        if (s_interrupted) {
            printf ("W: interrupt received, killing server...\n");
            break;
        }
    }
    zmq_close (socket);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<para>The program provides <literal>s-catch-signals()</literal>, which traps Ctrl-C (<literal>SIGINT</literal>) and <literal>SIGTERM</literal>. When either of these signals arrive, the <literal>s-catch-signals()</literal> handler sets the global variable <literal>s-interrupted</literal>. Thanks to your signal handler, your application will not die automatically. Instead, you have a chance to clean up and exit gracefully. You have to now explicitly check for an interrupt, and handle it properly. Do this by calling <literal>s-catch-signals()</literal> (copy this from <literal>interrupt.c</literal>) at the start of your main code. This sets-up the signal handling. The interrupt will affect &Oslash;MQ calls as follows:</para>

<itemizedlist>
  <listitem><para>If your code is blocking in <literal>zmq-msg-recv[3]</literal>, <literal>zmq-poll[3]</literal>, or <literal>zmq-msg-send[3]</literal>, when a signal arrives, the call will return with <literal>EINTR</literal>.</para></listitem>
  <listitem><para>Wrappers like <literal>s-recv()</literal> return NULL if they are interrupted.</para></listitem>
</itemizedlist>
<para>So check for an <literal>EINTR</literal> return code, a NULL return, and/or <literal>s-interrupted</literal>.</para>

<para>Here is a typical code fragment:</para>

<screen>s-catch-signals ();
client = zmq-socket (...);
while (!s-interrupted) {
    char *message = s-recv (client);
    if (!message)
        break;          //  Ctrl-C used
}
zmq-close (client);
</screen>

<para>If you call <literal>s-catch-signals()</literal> and don't test for interrupts, the your application will become immune to Ctrl-C and SIGTERM, which may be useful, but is usually not.</para>

</sect1>
<sect1>
<title>Detecting Memory Leaks</title>
<para>Any long-running application has to manage memory correctly, or eventually it'll use up all available memory and crash. If you use a language that handles this automatically for you, congratulations. If you program in C or C++ or any other language where you're responsible for memory management, here's a short tutorial on using valgrind, which among other things will report on any leaks your programs have.</para>

<itemizedlist>
  <listitem><para>To install valgrind, e.g. on Ubuntu or Debian issue:</para></listitem>
</itemizedlist>
<screen>sudo apt-get install valgrind
</screen>

<itemizedlist>
  <listitem><para>By default, &Oslash;MQ will cause valgrind to complain a lot. To remove these warnings, create a file called <literal>valgrind.supp</literal> that contains this:</para></listitem>
</itemizedlist>
<screen>{
   &lt;socketcall-sendto&gt;
   Memcheck:Param
   socketcall.sendto(msg)
   fun:send
   ...
}
{
   &lt;socketcall-sendto&gt;
   Memcheck:Param
   socketcall.send(msg)
   fun:send
   ...
}
</screen>

<itemizedlist>
  <listitem><para>Fix your applications to exit cleanly after Ctrl-C. For any application that exits by itself, that's not needed, but for long-running applications, this is essential, otherwise valgrind will complain about all currently allocated memory.</para></listitem>
  <listitem><para>Build your application with -DDEBUG, if it's not your default setting. That ensures valgrind can tell you exactly where memory is being leaked.</para></listitem>
  <listitem><para>Finally, run valgrind thus:</para></listitem>
</itemizedlist>
<screen>valgrind --tool=memcheck --leak-check=full --suppressions=valgrind.supp someprog
</screen>

<para>And after fixing any errors it reported, you should get the pleasant message:</para>

<screen>==30536== ERROR SUMMARY: 0 errors from 0 contexts...
</screen>

</sect1>
<sect1>
<title>Multithreading with &Oslash;MQ</title>
<para>&Oslash;MQ is perhaps the nicest way ever to write multithreaded (MT) applications. Whereas as &Oslash;MQ sockets require some readjustment if you are used to traditional sockets, &Oslash;MQ multithreading will take everything you know about writing MT applications, throw it into a heap in the garden, pour gasoline over it, and set it alight. It's a rare book that deserves burning, but most books on concurrent programming do.</para>

<para>To make utterly perfect MT programs (and I mean that literally) <emphasis role="bold">we don't need mutexes, locks, or any other form of inter-thread communication except messages sent across &Oslash;MQ sockets.</emphasis></para>

<para>By "perfect" MT programs I mean code that's easy to write and understand, that works with the same design approach in any programming language, and on any operating system, and that scales across any number of CPUs with zero wait states and no point of diminishing returns.</para>

<para>If you've spent years learning tricks to make your MT code work at all, let alone rapidly, with locks and semaphores and critical sections, you will be disgusted when you realize it was all for nothing. If there's one lesson we've learned from 30+ years of concurrent programming it is: <emphasis>just don't share state</emphasis>. It's like two drunkards trying to share a beer. It doesn't matter if they're good buddies. Sooner or later they're going to get into a fight. And the more drunkards you add to the table, the more they fight each other over the beer. The tragic majority of MT applications look like drunken bar fights.</para>

<para>The list of weird problems that you need to fight as you write classic shared-state MT code would be hilarious if it didn't translate directly into stress and risk, as code that seems to work suddenly fails under pressure. A large firm with world-beating experience in buggy code released its list of "11 Likely Problems In Your Multithreaded Code", which covers forgotten synchronization, incorrect granularity, read and write tearing, lock-free reordering, lock convoys, two-step dance, and priority inversion.</para>

<para>Yeah, we also counted seven problems, not eleven. That's not the point though. The point is, do you really want that code running the power grid or stock market to start getting two-step lock convoys at 3pm on a busy Thursday? Who cares what the terms actually mean. This is not what turned us on to programming, fighting ever more complex side-effects with ever more complex hacks.</para>

<para>Some widely used models, despite being the basis for entire industries, are fundamentally broken, and shared state concurrency is one of them. Code that wants to scale without limit does it like the Internet does, by sending messages and sharing nothing except a common contempt for broken programming models.</para>

<para>You should follow some rules to write happy multithreaded code with &Oslash;MQ:</para>

<itemizedlist>
  <listitem><para>You must not access the same data from multiple threads. Using classic MT techniques like mutexes are an anti-pattern in &Oslash;MQ applications. The only exception to this is a &Oslash;MQ context object, which is threadsafe.</para></listitem>
  <listitem><para>You must create a &Oslash;MQ context for your process, and pass that to all threads that you want to connect via <literal>inproc</literal> sockets.</para></listitem>
  <listitem><para>You may treat threads as separate tasks, with their own context, but these threads cannot communicate over <literal>inproc</literal>. However they will be easier to break into standalone processes afterwards.</para></listitem>
  <listitem><para>You must not share &Oslash;MQ sockets between threads. &Oslash;MQ sockets are not threadsafe. Technically it's possible to do this, but it demands semaphores, locks, or mutexes. This will make your application slow and fragile. The only place where it's remotely sane to share sockets between threads are in language bindings that need to do magic like garbage collection on sockets.</para></listitem>
</itemizedlist>
<para>If you need to start more than one proxy in an application, for example, you will want to run each in their own thread. It is easy to make the error of creating the proxy frontend and backend sockets in one thread, and then passing the sockets to the proxy in another thread. This may appear to work but will fail randomly. Remember: <emphasis>Do not use or close sockets except in the thread that created them.</emphasis></para>

<para>If you follow these rules, you can quite easily split threads into separate processes, when you need to. Application logic can sit in threads, processes, nodes: whatever your scale needs.</para>

<para>&Oslash;MQ uses native OS threads rather than virtual "green" threads. The advantage is that you don't need to learn any new threading API, and that &Oslash;MQ threads map cleanly to your operating system. You can use standard tools like Intel's ThreadChecker to see what your application is doing. The disadvantages are that your code, when it for instance starts new threads, won't be portable, and that if you have a huge number of threads (thousands), some operating systems will get stressed.</para>

<para>Let's see how this works in practice. We'll turn our old Hello World server into something more capable. The original server ran in a single thread. If the work per request is low, that's fine: one &Oslash;MQ thread can run at full speed on a CPU core, with no waits, doing an awful lot of work. But realistic servers have to do non-trivial work per request. A single core may not be enough when 10,000 clients hit the server all at once. So a realistic server must start multiple worker threads. It then accepts requests as fast as it can, and distributes these to its worker threads. The worker threads grind through the work, and eventually send their replies back.</para>

<para>You can of course do all this using a proxy broker and external worker processes, but often it's easier to start one process that gobbles up sixteen cores than sixteen processes, each gobbling up one core. Further, running workers as threads will cut out a network hop, latency, and network traffic.</para>

<para>The MT version of the Hello World service basically collapses the broker and workers into a single process. We use pthreads because it's the most widespread standard for multithreading:</para>

<example id="mtserver-c">
<title>Multithreaded service (mtserver.c)</title>
<programlisting language="c">
//
//  Multithreaded Hello World server
//
#include "zhelpers.h"
#include &lt;pthread.h&gt;

static void *
worker_routine (void *context) {
    //  Socket to talk to dispatcher
    void *receiver = zmq_socket (context, ZMQ_REP);
    zmq_connect (receiver, "inproc://workers");

    while (true) {
        char *string = s_recv (receiver);
        printf ("Received request: [%s]\n", string);
        free (string);
        //  Do some 'work'
        sleep (1);
        //  Send reply back to client
        s_send (receiver, "World");
    }
    zmq_close (receiver);
    return NULL;
}

int main (void)
{
    void *context = zmq_ctx_new ();

    //  Socket to talk to clients
    void *clients = zmq_socket (context, ZMQ_ROUTER);
    zmq_bind (clients, "tcp://*:5555");

    //  Socket to talk to workers
    void *workers = zmq_socket (context, ZMQ_DEALER);
    zmq_bind (workers, "inproc://workers");

    //  Launch pool of worker threads
    int thread_nbr;
    for (thread_nbr = 0; thread_nbr &lt; 5; thread_nbr++) {
        pthread_t worker;
        pthread_create (&amp;worker, NULL, worker_routine, context);
    }
    //  Connect work threads to client threads via a queue proxy
    zmq_proxy (clients, workers, NULL);

    //  We never get here but clean up anyhow
    zmq_close (clients);
    zmq_close (workers);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<para>All the code should be recognizable to you by now. How it works:</para>

<itemizedlist>
  <listitem><para>The server starts a set of worker threads. Each worker thread creates a REP socket and then processes requests on this socket. Worker threads are just like single-threaded servers. The only differences are the transport (<literal>inproc</literal> instead of <literal>tcp</literal>), and the bind-connect direction.</para></listitem>
  <listitem><para>The server creates a ROUTER socket to talk to clients and binds this to its external interface (over <literal>tcp</literal>).</para></listitem>
  <listitem><para>The server creates a DEALER socket to talk to the workers and binds this to its internal interface (over <literal>inproc</literal>).</para></listitem>
  <listitem><para>The server starts a proxy that connects the two sockets. The proxy pulls incoming requests fairly from all clients, and distributes those out to workers. It also routes replies back to their origin.</para></listitem>
</itemizedlist>
<para>Note that creating threads is not portable in most programming languages. The POSIX library is pthreads, but on Windows you have to use a different API. In our example, the <literal>pthread-create</literal> call starts up a new thread running the <literal>worker-routine</literal> function we defined. We'll see in Advanced Request-Reply Patterns<xref linkend="advanced-request-reply"/> how to wrap this in a portable API.</para>

<para>Here the 'work' is just a one-second pause. We could do anything in the workers, including talking to other nodes. This is what the MT server looks like in terms of &Oslash;MQ sockets and nodes. Note how the request-reply chain is <literal>REQ-ROUTER-queue-DEALER-REP</literal>(<xref linkend="figure-20"/>).</para>

<figure id="figure-20">
    <title>Multithreaded Server</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig20.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

</sect1>
<sect1>
<title>Signaling between Threads (PAIR sockets)</title>
<para>When you start making multithreaded applications with &Oslash;MQ, you'll encounter the question of how to coordinate your threads. Though you might be tempted to insert 'sleep' statements, or use multithreading techniques such as semaphores or mutexes, <emphasis role="bold">the only mechanism that you should use are &Oslash;MQ messages</emphasis>. Remember the story of The Drunkards and the Beer Bottle.</para>

<para>Let's make three threads that signal each other when they are ready(<xref linkend="figure-21"/>). In this example we use PAIR sockets over the <literal>inproc</literal> transport:</para>

<example id="mtrelay-c">
<title>Multithreaded relay (mtrelay.c)</title>
<programlisting language="c">
//
//  Multithreaded relay
//
#include "zhelpers.h"
#include &lt;pthread.h&gt;

static void *
step1 (void *context) {
    //  Connect to step2 and tell it we're ready
    void *xmitter = zmq_socket (context, ZMQ_PAIR);
    zmq_connect (xmitter, "inproc://step2");
    printf ("Step 1 ready, signaling step 2\n");
    s_send (xmitter, "READY");
    zmq_close (xmitter);

    return NULL;
}

static void *
step2 (void *context) {
    //  Bind inproc socket before starting step1
    void *receiver = zmq_socket (context, ZMQ_PAIR);
    zmq_bind (receiver, "inproc://step2");
    pthread_t thread;
    pthread_create (&amp;thread, NULL, step1, context);

    //  Wait for signal and pass it on
    char *string = s_recv (receiver);
    free (string);
    zmq_close (receiver);

    //  Connect to step3 and tell it we're ready
    void *xmitter = zmq_socket (context, ZMQ_PAIR);
    zmq_connect (xmitter, "inproc://step3");
    printf ("Step 2 ready, signaling step 3\n");
    s_send (xmitter, "READY");
    zmq_close (xmitter);

    return NULL;
}

int main (void)
{
    void *context = zmq_ctx_new ();

    //  Bind inproc socket before starting step2
    void *receiver = zmq_socket (context, ZMQ_PAIR);
    zmq_bind (receiver, "inproc://step3");
    pthread_t thread;
    pthread_create (&amp;thread, NULL, step2, context);

    //  Wait for signal
    char *string = s_recv (receiver);
    free (string);
    zmq_close (receiver);

    printf ("Test successful!\n");
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<figure id="figure-21">
    <title>The Relay Race</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig21.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>This is a classic pattern for multithreading with &Oslash;MQ:</para>

<orderedlist>
  <listitem><para>Two threads communicate over <literal>inproc</literal>, using a shared context.</para></listitem>
  <listitem><para>The parent thread creates one socket, binds it to an inproc:// endpoint, and <emphasis>then</emphasis> starts the child thread, passing the context to it.</para></listitem>
  <listitem><para>The child thread creates the second socket, connects it to that inproc:// endpoint, and <emphasis>then</emphasis> signals to the parent thread that it's ready.</para></listitem>
</orderedlist>
<para>Note that multithreading code using this pattern is not scalable out to processes. If you use <literal>inproc</literal> and socket pairs, you are building a tightly-bound application, i.e. one where your threads are structurally interdependent. Do this when low latency is really vital. The other design pattern is a loosely-bound application, where threads have their own context and communicate over <literal>ipc</literal> or <literal>tcp</literal>. You can easily break loosely-bound threads into separate processes.</para>

<para>This is the first time we've shown an example using PAIR sockets. Why use PAIR? Other socket combinations might seem to work but they all have side-effects that could interfere with signaling:</para>

<itemizedlist>
  <listitem><para>You can use PUSH for the sender and PULL for the receiver. This looks simple and will work, but remember that PUSH will load-balance messages to all available receivers. If you by accident start two receivers (e.g. you already have one running and you start a second), you'll "lose" half of your signals. PAIR has the advantage of refusing more than one connection; the pair is <emphasis>exclusive</emphasis>.</para></listitem>
  <listitem><para>You can use DEALER for the sender and ROUTER for the receiver. ROUTER however wraps your message in an "envelope", meaning your zero-size signal turns into a multi-part message. If you don't care about the data, and treat anything as a valid signal, and if you don't read more than once from the socket, that won't matter. If however you decide to send real data, you will suddenly find ROUTER providing you with "wrong" messages. DEALER also load-balances, giving the same risk as PUSH.</para></listitem>
  <listitem><para>You can use PUB for the sender and SUB for the receiver. This will correctly deliver your messages exactly as you sent them and PUB does not load-balance as PUSH or DEALER do. However you need to configure the subscriber with an empty subscription, which is annoying. Worse, the reliability of the PUB-SUB link is timing dependent and messages can get lost if the SUB socket is connecting while the PUB socket is sending its messages.</para></listitem>
</itemizedlist>
<para>For these reasons, PAIR makes the best choice for coordination between pairs of threads.</para>

</sect1>
<sect1>
<title>Node Coordination</title>
<para>When you want to coordinate nodes, PAIR sockets won't work well any more. This is one of the few areas where the strategies for threads and nodes are different. Principally nodes come and go whereas threads are static. PAIR sockets do not automatically reconnect if the remote node goes away and comes back.</para>

<para>The second significant difference between threads and nodes is that you typically have a fixed number of threads but a more variable number of nodes. Let's take one of our earlier scenarios (the weather server and clients) and use node coordination to ensure that subscribers don't lose data when starting up.</para>

<para>This is how the application will work:</para>

<itemizedlist>
  <listitem><para>The publisher knows in advance how many subscribers it expects. This is just a magic number it gets from somewhere.</para></listitem>
  <listitem><para>The publisher starts up and waits for all subscribers to connect. This is the node coordination part. Each subscriber subscribes and then tells the publisher it's ready via another socket.</para></listitem>
  <listitem><para>When the publisher has all subscribers connected, it starts to publish data.</para></listitem>
</itemizedlist>
<para>In this case we'll use a REQ-REP socket flow to synchronize subscribers and publisher(<xref linkend="figure-22"/>). Here is the publisher:</para>

<example id="syncpub-c">
<title>Synchronized publisher (syncpub.c)</title>
<programlisting language="c">
//
//  Synchronized publisher
//
#include "zhelpers.h"

//  We wait for 10 subscribers
#define SUBSCRIBERS_EXPECTED  10

int main (void)
{
    void *context = zmq_ctx_new ();

    //  Socket to talk to clients
    void *publisher = zmq_socket (context, ZMQ_PUB);
    zmq_bind (publisher, "tcp://*:5561");

    //  Socket to receive signals
    void *syncservice = zmq_socket (context, ZMQ_REP);
    zmq_bind (syncservice, "tcp://*:5562");

    //  Get synchronization from subscribers
    printf ("Waiting for subscribers\n");
    int subscribers = 0;
    while (subscribers &lt; SUBSCRIBERS_EXPECTED) {
        //  - wait for synchronization request
        char *string = s_recv (syncservice);
        free (string);
        //  - send synchronization reply
        s_send (syncservice, "");
        subscribers++;
    }
    //  Now broadcast exactly 1M updates followed by END
    printf ("Broadcasting messages\n");
    int update_nbr;
    for (update_nbr = 0; update_nbr &lt; 1000000; update_nbr++)
        s_send (publisher, "Rhubarb");

    s_send (publisher, "END");

    zmq_close (publisher);
    zmq_close (syncservice);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<figure id="figure-22">
    <title>Pub-Sub Synchronization</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig22.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>And here is the subscriber:</para>

<example id="syncsub-c">
<title>Synchronized subscriber (syncsub.c)</title>
<programlisting language="c">
//
//  Synchronized subscriber
//
#include "zhelpers.h"

int main (void)
{
    void *context = zmq_ctx_new ();

    //  First, connect our subscriber socket
    void *subscriber = zmq_socket (context, ZMQ_SUB);
    zmq_connect (subscriber, "tcp://localhost:5561");
    zmq_setsockopt (subscriber, ZMQ_SUBSCRIBE, "", 0);

    //  0MQ is so fast, we need to wait a while...
    sleep (1);

    //  Second, synchronize with publisher
    void *syncclient = zmq_socket (context, ZMQ_REQ);
    zmq_connect (syncclient, "tcp://localhost:5562");

    //  - send a synchronization request
    s_send (syncclient, "");

    //  - wait for synchronization reply
    char *string = s_recv (syncclient);
    free (string);

    //  Third, get our updates and report how many we got
    int update_nbr = 0;
    while (true) {
        char *string = s_recv (subscriber);
        if (strcmp (string, "END") == 0) {
            free (string);
            break;
        }
        free (string);
        update_nbr++;
    }
    printf ("Received %d updates\n", update_nbr);

    zmq_close (subscriber);
    zmq_close (syncclient);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<para>This Bash shell script will start ten subscribers and then the publisher:</para>

<screen>echo "Starting subscribers..."
for ((a=0; a&lt;10; a++)); do
    syncsub &amp;
done
echo "Starting publisher..."
syncpub
</screen>

<para>Which gives us this satisfying output:</para>

<screen>Starting subscribers...
Starting publisher...
Received 1000000 updates
Received 1000000 updates
Received 1000000 updates
Received 1000000 updates
Received 1000000 updates
Received 1000000 updates
Received 1000000 updates
Received 1000000 updates
Received 1000000 updates
Received 1000000 updates
</screen>

<para>We can't assume that the SUB connect will be finished by the time the REQ/REP dialog is complete. There are no guarantees that outbound connects will finish in any order whatsoever, if you're using any transport except <literal>inproc</literal>. So, the example does a brute-force sleep of one second between subscribing, and sending the REQ/REP synchronization.</para>

<para>A more robust model could be:</para>

<itemizedlist>
  <listitem><para>Publisher opens PUB socket and starts sending "Hello" messages (not data).</para></listitem>
  <listitem><para>Subscribers connect SUB socket and when they receive a Hello message they tell the publisher via a REQ/REP socket pair.</para></listitem>
  <listitem><para>When the publisher has had all the necessary confirmations, it starts to send real data.</para></listitem>
</itemizedlist>
</sect1>
<sect1>
<title>Zero Copy</title>
<para>&Oslash;MQ's message API lets you can send and receive messages directly from and to application buffers without copying data. We call "zero-copy", and it can improve performance in some applications. Like all optimizations, use this when you know it helps, and measure before and after. Zero-copy makes your code more complex.</para>

<para>To do zero-copy you use <literal>zmq-msg-init-data[3]</literal> to create a message that refers to a block of data already allocated on the heap with <literal>malloc()</literal>, and then you pass that to <literal>zmq-msg-send[3]</literal>. When you create the message you also pass a function that &Oslash;MQ will call to free the block of data, when it has finished sending the message. This is the simplest example, assuming 'buffer' is a block of 1000 bytes allocated on the heap:</para>

<programlisting language="c">
void my-free (void *data, void *hint) {
    free (data);
}
//  Send message from buffer, which we allocate and 0MQ will free for us
zmq-msg-t message;
zmq-msg-init-data (&amp;message, buffer, 1000, my-free, NULL);
zmq-msg-send (socket, &amp;message, 0);
</programlisting>

<para>There is no way to do zero-copy on receive: &Oslash;MQ delivers you a buffer that you can store as long as you wish but it will not write data directly into application buffers.</para>

<para>On writing, &Oslash;MQ's multi-part messages work nicely together with zero-copy. In traditional messaging you need to marshal different buffers together into one buffer that you can send. That means copying data. With &Oslash;MQ, you can send multiple buffers coming from different sources as individual message frames. Send each field as a length-delimited frame. To the application it looks like a series of send and recv calls. But internally the multiple parts get written to the network and read back with single system calls, so it's very efficient.</para>

</sect1>
<sect1>
<title>Pub-Sub Message Envelopes</title>
<para>In the pub-sub pattern we can split the key into a separate message frame that we call an "envelope". If you want to use pub-sub envelopes, make them yourself. It's optional, and in previous pub-sub examples we didn't do this. Using a pub-sub envelope is a little more work for simple cases but it's cleaner especially for real cases, where the key and the data are naturally separate things.</para>

<para>Here is what a publish-subscribe message with an envelope looks like:</para>

<figure id="figure-23">
    <title>Pub-Sub Envelope with Separate Key</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig23.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>Recall that subscriptions do a prefix match. That is, "all messages starting with XYZ". The obvious question is: how to delimit keys from data so that the prefix match doesn't accidentally match data. The best answer is to use an envelope, since the match won't cross a frame boundary.</para>

<para>Here is a minimalist example of how pub-sub envelopes look in code. This publisher sends messages of two types, A and B. The envelope holds the message type:</para>

<example id="psenvpub-c">
<title>Pub-Sub envelope publisher (psenvpub.c)</title>
<programlisting language="c">
//
//  Pubsub envelope publisher
//  Note that the zhelpers.h file also provides s_sendmore
//
#include "zhelpers.h"

int main (void)
{
    //  Prepare our context and publisher
    void *context = zmq_ctx_new ();
    void *publisher = zmq_socket (context, ZMQ_PUB);
    zmq_bind (publisher, "tcp://*:5563");

    while (true) {
        //  Write two messages, each with an envelope and content
        s_sendmore (publisher, "A");
        s_send (publisher, "We don't want to see this");
        s_sendmore (publisher, "B");
        s_send (publisher, "We would like to see this");
        sleep (1);
    }
    //  We never get here but clean up anyhow
    zmq_close (publisher);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<para>The subscriber wants only messages of type B:</para>

<example id="psenvsub-c">
<title>Pub-Sub envelope subscriber (psenvsub.c)</title>
<programlisting language="c">
//
//  Pubsub envelope subscriber
//
#include "zhelpers.h"

int main (void)
{
    //  Prepare our context and subscriber
    void *context = zmq_ctx_new ();
    void *subscriber = zmq_socket (context, ZMQ_SUB);
    zmq_connect (subscriber, "tcp://localhost:5563");
    zmq_setsockopt (subscriber, ZMQ_SUBSCRIBE, "B", 1);

    while (true) {
        //  Read envelope with address
        char *address = s_recv (subscriber);
        //  Read message contents
        char *contents = s_recv (subscriber);
        printf ("[%s] %s\n", address, contents);
        free (address);
        free (contents);
    }
    //  We never get here but clean up anyhow
    zmq_close (subscriber);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<para>When you run the two programs, the subscriber should show you this:</para>

<screen>[B] We would like to see this
[B] We would like to see this
[B] We would like to see this
[B] We would like to see this
...
</screen>

<para>This examples shows that the subscription filter rejects or accepts the entire multi-part message (key plus data). You won't get part of a multi-part message, ever.</para>

<para>If you subscribe to multiple publishers and you want to know their identity so that you can send them data via another socket (and this is a fairly typical use-case), create a three-part message:</para>

<figure id="figure-24">
    <title>Pub-Sub Envelope with Sender Address</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig24.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

</sect1>
<sect1>
<title>High Water Marks</title>
<para>When you can send messages rapidly from process to process, you soon discover that memory is a precious resource, and one that can be trivially filled up. A few seconds of delay somewhere in a process can turn into a backlog that blows up a server, unless you understand the problem and take precautions.</para>

<para>The problem is this: if you have process A sending messages to process B, which suddenly gets very busy (garbage collection, CPU overload, whatever), then what happens to the messages that process A wants to send? Some will sit in B's network buffers. Some will sit on the Ethernet wire itself. Some will sit in A's network buffers. And the rest will accumulate in A's memory. If you don't take some precaution, A can easily run out of memory and crash. It is a consistent, classic problem with message brokers.</para>

<para>What are the answers? One is to pass the problem upstream. A is getting the messages from somewhere else. So tell that process, "stop!" And so on. This is called "flow control". It sounds great, but what if you're sending out a Twitter feed? Do you tell the whole world to stop tweeting while B gets its act together?</para>

<para>Flow control works in some cases but in others. The transport layer can't tell the application layer to "stop" any more than a subway system can tell a large business, "please keep your staff at work another half an hour, I'm too busy".</para>

<para>The answer for messaging is to set limits on the size of buffers, and then when we reach those limits, take some sensible action. In most cases (not for a subway system, though), the answer is to throw away messages. In a few others, it's to wait.</para>

<para>&Oslash;MQ uses the concept of "high water mark" or HWM to define the capacity of its internal pipes. Each connection out of a socket or into a socket has its own pipe, and HWM capacity.</para>

<para>In &Oslash;MQ/2.x the HWM was infinite by default. In &Oslash;MQ/3.x it's set to 1,000 by default, which is more sensible. If you're still using &Oslash;MQ/2.x you should always set a HWM on your sockets, be it 1,000 to match &Oslash;MQ/3.x or another figure that takes into account your message sizes.</para>

<para>The high water mark affects both the transmit and receive buffers of a single socket. Some sockets (PUB, PUSH) only have transmit buffers. Some (SUB, PULL, REQ, REP) only have receive buffers. Some (DEALER, ROUTER, PAIR) have both transmit and receive buffers.</para>

<para>When your socket reaches its high-water mark, it will either block or drop data depending on the socket type. PUB sockets will drop data if they reach their high-water mark, while other socket types will block.</para>

<para>Over the <literal>inproc</literal> transport, the sender and receiver share the same buffers, so the real HWM is the sum of the HWM set by both sides. This means in effect that if one side does not set a HWM, there is no limit to the buffer size.</para>

</sect1>
<sect1>
<title>Missing Message Problem Solver</title>
<para>As you build applications with &Oslash;MQ you will come across this problem more than once: losing messages that you expect to receive. We have put together a diagram(<xref linkend="figure-25"/>) that walks through the most common causes for this.</para>

<figure id="figure-25">
    <title>Missing Message Problem Solver</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig25.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>If you're using &Oslash;MQ in a context where failures are expensive, then you want to plan properly. First, build prototypes that let you learn and test the different aspects of your design. Stress them until they break, so that you know exactly how strong your designs are. Second, invest in testing. This means building test frameworks, ensuring you have access to realistic setups with sufficient computer power, and getting time or help to actually test seriously. Ideally, one team writes the code, a second team tries to break it. Lastly, do get your organization to <ulink url="http://www.imatix.com/contact">contact iMatix</ulink> to discuss how we can help to make sure things work properly, and can be fixed rapidly if they break.</para>

<para>In short: if you have not proven an architecture works in realistic conditions, it will most likely break at the worst possible moment.</para>

</sect1>
</chapter>
<chapter id="advanced-request-reply">
<title>Advanced Request-Reply Patterns</title>
<para>In Sockets and Patterns<xref linkend="sockets-and-patterns"/> we worked through the basics of using &Oslash;MQ by developing a series of small applications, each time exploring new aspects of &Oslash;MQ. We'll continue this approach in this chapter, as we explore advanced patterns built on top of &Oslash;MQ's core request-reply pattern.</para>

<para>We'll cover:</para>

<itemizedlist>
  <listitem><para>How to create and use message envelopes for request-reply.</para></listitem>
  <listitem><para>How to use the REQ, REP, DEALER, and ROUTER sockets.</para></listitem>
  <listitem><para>How to set manual reply addresses using identities.</para></listitem>
  <listitem><para>How to do custom random scatter routing.</para></listitem>
  <listitem><para>How to do custom least-recently used routing.</para></listitem>
  <listitem><para>How to build a higher-level message class.</para></listitem>
  <listitem><para>How to build a basic request-reply broker.</para></listitem>
  <listitem><para>How to choose good names for sockets.</para></listitem>
  <listitem><para>How to simulate a cluster of clients and workers.</para></listitem>
  <listitem><para>How to build a scalable cloud of request-reply clusters.</para></listitem>
  <listitem><para>How to use pipeline sockets for monitoring threads.</para></listitem>
</itemizedlist>
<sect1>
<title>Request-Reply Envelopes</title>
<para>We've looked briefly at multi-part messages. Let's now look at their first use case, which is <emphasis>message envelopes</emphasis>. An envelope is a way of safely packaging up data with an address, without touching the data itself. By separating addresses into an envelope we make it possible to write general-purpose intermediaries such as APIs and proxies that create, read, remove addresses no matter what the message payload or structure.</para>

<para>In the request-reply pattern, the envelope holds the return address for replies. It is how a &Oslash;MQ network with no state can create round-trip request-reply dialogs.</para>

<para>You don't in fact need to understand how request-reply envelopes work to use them for common cases. When you use REQ and REP, your sockets build and use envelopes automatically. When you write a proxy, if you don't call <literal>zmq_proxy()</literal>, you need to read and write all the parts of a message. &Oslash;MQ implements envelopes using multi-part data, so if you copy multi-part data safely, you implicitly copy envelopes too.</para>

<para>However, getting under the hood and playing with request-reply envelopes is necessary for advanced request-reply work. It's time to explain how the ROUTER socket works, in terms of envelopes:</para>

<itemizedlist>
  <listitem><para>When you receive a message from a ROUTER socket, it shoves a brown paper envelope around the message and scribbles on with indelible ink, "This came from Lucy". Then it gives that to you. That is, the ROUTER gives you what came off the wire, wrapped up in an envelope with the reply address on it.</para></listitem>
  <listitem><para>When you send a message to a ROUTER, it rips off that brown paper envelope, tries to read its own handwriting, and if it knows who "Lucy" is, sends the contents back to Lucy. That is the reverse process of receiving a message.</para></listitem>
</itemizedlist>
<para>If you leave the brown envelope alone, and then pass that message to another ROUTER (e.g. by sending to a DEALER connected to a ROUTER), the second ROUTER will in turn stick another brown envelope on it, and scribble the name of that DEALER on it.</para>

<para>The whole point of this is that each ROUTER knows how to send replies back to the right place. All you need to do, in your application, is respect the brown envelopes. Now the REP socket makes sense. It carefully slices open the brown envelopes, one by one, keeps them safely aside, and gives you (the application code that owns the REP socket) the original message. When you send the reply, it re-wraps the reply in the brown paper envelopes, so it can hand the resulting brown package back to the ROUTERs down the chain.</para>

<para>Which lets you insert ROUTER-DEALER proxies into a request-reply pattern like this:</para>

<screen>[REQ] &lt;--&gt; [REP]
[REQ] &lt;--&gt; [ROUTER--DEALER] &lt;--&gt; [REP]
[REQ] &lt;--&gt; [ROUTER--DEALER] &lt;--&gt; [ROUTER--DEALER] &lt;--&gt; [REP]
...etc.
</screen>

<para>If you connect a REQ socket to a ROUTER, and send one request message, you will get a message that consists of three frames: a reply address, an empty message frame, and the 'real' message(<xref linkend="figure-26"/>).</para>

<figure id="figure-26">
    <title>Single-hop Request-reply Envelope</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig26.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>Breaking this down:</para>

<itemizedlist>
  <listitem><para>The data in frame 3 is what the sending application sends to the REQ socket.</para></listitem>
  <listitem><para>The empty message frame in frame 2 is prepended by the REQ socket when it sends the message to the ROUTER.</para></listitem>
  <listitem><para>The reply address in frame 1 is prepended by the ROUTER before it passes the message to the receiving application.</para></listitem>
</itemizedlist>
<para>Now if we extend this with a chain of proxies, we get envelope on envelope, with the newest envelope always stuck at the beginning of the stack(<xref linkend="figure-27"/>).</para>

<figure id="figure-27">
    <title>Multihop Request-reply Envelope</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig27.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>Here now is a more detailed explanation of the four socket types we use for request-reply patterns:</para>

<itemizedlist>
  <listitem><para>DEALER just deals out the messages you send to all connected peers (aka "round-robin"), and deals in (aka "fair queuing") the messages it receives. It is exactly like a PUSH and PULL socket combined.</para></listitem>
  <listitem><para>REQ prepends an empty message frame to every message you send, and removes the empty message frame from each message you receive. It then works like DEALER (and in fact is built on DEALER) except it also imposes a strict send / receive cycle.</para></listitem>
  <listitem><para>ROUTER prepends an envelope with reply address to each message it receives, before passing it to the application. It also chops off the envelope (the first message frame) from each message it sends, and uses that reply address to decide which peer the message should go to.</para></listitem>
  <listitem><para>REP stores all the message frames up to the first empty message frame, when you receive a message and it passes the rest (the data) to your application. When you send a reply, REP prepends the saved envelopes to the message and sends it back using the same semantics as ROUTER (and in fact REP is built on top of ROUTER), but matching REQ, imposes a strict receive / send cycle.</para></listitem>
</itemizedlist>
<para>REP requires that the envelopes end with an empty message frame. If you're not using REQ at the other end of the chain then you must add the empty message frame yourself.</para>

<para>So the obvious question about ROUTER is, where does it get the reply addresses from? And the obvious answer is, it uses the socket's identity. As we already learned, if a socket does not set an identity, the ROUTER generates an identity that it can associate with the connection to that socket(<xref linkend="figure-28"/>).</para>

<figure id="figure-28">
    <title>ROUTER Invents a UUID</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig28.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>When we set our own identity on a socket, this gets passed to the ROUTER, which passes it to the application as part of the envelope for each message that comes in(<xref linkend="figure-29"/>).</para>

<figure id="figure-29">
    <title>ROUTER uses Identity If It knows It</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig29.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>Let's observe the above two cases in practice. This program dumps the contents of the message frames that a ROUTER receives from two REP sockets, one not using identities, and one using an identity 'Hello':</para>

<example id="identity-c">
<title>Identity check (identity.c)</title>
<programlisting language="c">
//
//  Demonstrate identities as used by the request-reply pattern.  Run this
//  program by itself.  Note that the utility functions s_ are provided by
//  zhelpers.h.  It gets boring for everyone to keep repeating this code.
//
#include "zhelpers.h"

int main (void) 
{
    void *context = zmq_ctx_new ();

    void *sink = zmq_socket (context, ZMQ_ROUTER);
    zmq_bind (sink, "inproc://example");

    //  First allow 0MQ to set the identity
    void *anonymous = zmq_socket (context, ZMQ_REQ);
    zmq_connect (anonymous, "inproc://example");
    s_send (anonymous, "ROUTER uses a generated UUID");
    s_dump (sink);

    //  Then set the identity ourself
    void *identified = zmq_socket (context, ZMQ_REQ);
    zmq_setsockopt (identified, ZMQ_IDENTITY, "Hello", 5);
    zmq_connect (identified, "inproc://example");
    s_send (identified, "ROUTER socket uses REQ's socket identity");
    s_dump (sink);

    zmq_close (sink);
    zmq_close (anonymous);
    zmq_close (identified);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<para>Here is what the dump function prints:</para>

<screen>----------------------------------------
[017] 00314F043F46C441E28DD0AC54BE8DA727
[000]
[026] ROUTER uses a generated UUID
----------------------------------------
[005] Hello
[000]
[038] ROUTER uses REQ's socket identity
</screen>

</sect1>
<sect1>
<title>Custom Request-Reply Routing</title>
<para>We already saw that ROUTER uses the message envelope to decide which client to route a reply back to. Now let me express that in another way: <emphasis>ROUTER will route messages asynchronously to any peer connected to it, if you provide the correct routing address via a properly constructed envelope.</emphasis></para>

<para>So ROUTER is really a fully controllable ROUTER. We'll dig into this magic in detail.</para>

<para>But first, and because we're going to go off-road into some rough and possibly illegal terrain now, let's look closer at REQ and REP. These provide your kindergarten request-reply socket pattern. It's an easy pattern to learn but quite rapidly gets annoying as it provides, for instance, no way to resend a request if it got lost for some reason.</para>

<para>While we usually think of request-reply as a to-and-fro pattern, in fact it can be fully asynchronous, as long as we understand that any REQs and REPS will be at the end of a chain, never in the middle of it, and always synchronous. All we need to know is the address of the peer we want to talk to, and then we can then send it messages asynchronously, via a ROUTER. The ROUTER is the one and only &Oslash;MQ socket type capable of being told "send this message to X" where X is the address of a connected peer.</para>

<para>These are the ways we can know the address to send a message to, and you'll see most of these used in the examples of custom request-reply routing:</para>

<itemizedlist>
  <listitem><para>By default, a peer has a null identity and the ROUTER will generate a UUID and use that to refer to the connection when it delivers you each incoming message from that peer.</para></listitem>
  <listitem><para>If the peer socket set an identity, the ROUTER will give that identity when it delivers an incoming request envelope from that peer.</para></listitem>
  <listitem><para>Peers with explicit identities can send them via some other mechanism, e.g. via some other sockets.</para></listitem>
  <listitem><para>Peers can have prior knowledge of each others' identities, e.g. via configuration files or some other magic.</para></listitem>
</itemizedlist>
<para>There are at least three routing patterns, one for each of the socket types we can easily connect to a ROUTER:</para>

<itemizedlist>
  <listitem><para>ROUTER-to-DEALER.</para></listitem>
  <listitem><para>ROUTER-to-REQ.</para></listitem>
  <listitem><para>ROUTER-to-REP.</para></listitem>
</itemizedlist>
<para>In each of these cases we have total control over how we route messages, but the different patterns cover different use-cases and message flows. Let's break it down over the next sections with examples of different routing algorithms.</para>

</sect1>
<sect1>
<title>ROUTER-to-DEALER Routing</title>
<para>The ROUTER-to-DEALER pattern is the simplest. You connect one ROUTER to many DEALERs, and then distribute messages to the DEALERs using any algorithm you like. The DEALERs can be sinks (process the messages without any response), proxies (send the messages on to other nodes), or services (send back replies).</para>

<para>If you expect the DEALER to reply, there should only be one ROUTER talking to it. DEALERs have no idea how to reply to a specific peer, so if they have multiple peers, they will just round-robin between them, which would be weird. If the DEALER is a sink, any number of ROUTERs can talk to it.</para>

<para>What kind of routing can you do with a ROUTER-to-DEALER pattern? If the DEALERs talk back to the ROUTER, e.g. telling the ROUTER when they finished a task, you can use that knowledge to route depending on how fast a DEALER is. Since both ROUTER and DEALER are asynchronous, it can get a little tricky. You'd need to use <literal>zmq_poll()</literal> at least.</para>

<para>We'll make an example where the DEALERs don't talk back, they're pure sinks. Our routing algorithm will be a weighted random scatter: we have two DEALERs and we send twice as many messages to one as to the other(<xref linkend="figure-30"/>).</para>

<figure id="figure-30">
    <title>ROUTER-to-DEALER Custom Routing</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig30.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>Here's code that shows how this works:</para>

<example id="rtdealer-c">
<title>ROUTER-to-DEALER (rtdealer.c)</title>
<programlisting language="c">
//
//  Custom routing Router to Dealer
//
#include "zhelpers.h"
#include &lt;pthread.h&gt;

//  We have two workers, here we copy the code, normally these would
//  run on different boxes...
//
static void *
worker_task_a (void *args)
{
    void *context = zmq_ctx_new ();
    void *worker = zmq_socket (context, ZMQ_DEALER);
    zmq_setsockopt (worker, ZMQ_IDENTITY, "A", 1);
    zmq_connect (worker, "ipc://routing.ipc");

    int total = 0;
    while (true) {
        //  We receive one part, with the workload
        char *request = s_recv (worker);
        int finished = (strcmp (request, "END") == 0);
        free (request);
        if (finished) {
            printf ("A received: %d\n", total);
            break;
        }
        total++;
    }
    zmq_close (worker);
    zmq_ctx_destroy (context);
    return NULL;
}

static void *
worker_task_b (void *args)
{
    void *context = zmq_ctx_new ();
    void *worker = zmq_socket (context, ZMQ_DEALER);
    zmq_setsockopt (worker, ZMQ_IDENTITY, "B", 1);
    zmq_connect (worker, "ipc://routing.ipc");

    int total = 0;
    while (true) {
        //  We receive one part, with the workload
        char *request = s_recv (worker);
        int finished = (strcmp (request, "END") == 0);
        free (request);
        if (finished) {
            printf ("B received: %d\n", total);
            break;
        }
        total++;
    }
    zmq_close (worker);
    zmq_ctx_destroy (context);
    return NULL;
}
</programlisting>

</example>
<para>After we've defined the two worker tasks, we have the main task. Recall that these three tasks could be in separate processes, even running on different boxes. It's just easier to start by writing these in a single program. The main task starts the two workers, then scatters tasks to the workers. It sends an END message to each worker to tell them to exit: 
</para>

<example id="rtdealer-c-1">
<title>ROUTER-to-DEALER (rtdealer.c) - main task</title>
<programlisting language="c">

int main (void)
{
    void *context = zmq_ctx_new ();
    void *client = zmq_socket (context, ZMQ_ROUTER);
    zmq_bind (client, "ipc://routing.ipc");

    pthread_t worker;
    pthread_create (&amp;worker, NULL, worker_task_a, NULL);
    pthread_create (&amp;worker, NULL, worker_task_b, NULL);

    //  Wait for threads to connect, since otherwise the messages
    //  we send won't be routable.
    sleep (1);

    //  Send 10 tasks scattered to A twice as often as B
    int task_nbr;
    srandom ((unsigned) time (NULL));
    for (task_nbr = 0; task_nbr &lt; 10; task_nbr++) {
        //  Send two message parts, first the address...
        if (randof (3) &gt; 0)
            s_sendmore (client, "A");
        else
            s_sendmore (client, "B");

        //  And then the workload
        s_send (client, "This is the workload");
    }
    s_sendmore (client, "A");
    s_send     (client, "END");

    s_sendmore (client, "B");
    s_send     (client, "END");

    zmq_close (client);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<para>Some comments on this code:</para>

<itemizedlist>
  <listitem><para>The ROUTER doesn't know when the DEALERs are ready, and it would be distracting for our example to add in the signaling to do that. So the ROUTER just does a "sleep (1)" after starting the DEALER threads. Without this sleep, the ROUTER will send out messages that can't be routed, and &Oslash;MQ will discard them.</para></listitem>
  <listitem><para>Note that this behavior is specific to ROUTERs. PUB sockets will also discard messages if there are no subscribers, but all other socket types will queue sent messages until there's a peer to receive them.</para></listitem>
</itemizedlist>
<para>To route to a DEALER, we create an envelope consisting of just an identity frame (we don't need a null separator)(<xref linkend="figure-31"/>).</para>

<figure id="figure-31">
    <title>Routing Envelope for DEALER</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig31.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>The ROUTER socket removes the first frame, and sends the second frame, which the DEALER gets as-is. When the DEALER sends a message to the ROUTER, it sends one frame. The ROUTER prepends the DEALER's address and gives us back a similar envelope in two parts.</para>

<para>Something to note: if you use an invalid address, the ROUTER discards the message silently. There is not much else it can do usefully. In normal cases this either means the peer has gone away, or that there is a programming error somewhere and you're using a bogus address. In any case you cannot ever assume a message will be routed successfully until and unless you get a reply of some sort from the destination node. We'll come to creating reliable patterns later on.</para>

<para>DEALERs in fact work exactly like PUSH and PULL combined. Do not however connect PUSH or PULL sockets to DEALERS. That would just be nasty and pointless.</para>

</sect1>
<sect1>
<title>Least-Recently Used Routing (LRU Pattern)</title>
<para>REQ sockets don't listen to you, and if you try to speak out of turn they'll ignore you. You have to wait for them to say something, and <emphasis>then</emphasis> you can give a sarcastic answer. This is very useful for routing because it means we can keep a bunch of REQs waiting for answers. In effect, a REQ socket will tell us when it's ready.</para>

<para>You can connect one ROUTER to many REQs, and distribute messages as you would to DEALERs. REQs will usually want to reply, but they will let you have the last word. However it's one thing at a time:</para>

<itemizedlist>
  <listitem><para>REQ speaks to ROUTER</para></listitem>
  <listitem><para>ROUTER replies to REQ</para></listitem>
  <listitem><para>REQ speaks to ROUTER</para></listitem>
  <listitem><para>ROUTER replies to REQ</para></listitem>
  <listitem><para>etc.</para></listitem>
</itemizedlist>
<para>Like DEALERs, REQs can only talk to one ROUTER and since REQs always start by talking to the ROUTER, you should never connect one REQ to more than one ROUTER unless you are doing sneaky stuff like multi-pathway redundant routing(<xref linkend="figure-32"/>). I'm not even going to explain that now, and hopefully the jargon is complex enough to stop you trying this until you need it.</para>

<figure id="figure-32">
    <title>ROUTER to REQ Custom Routing</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig32.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>What kind of routing can you do with a ROUTER-to-REQ pattern? Probably the most obvious is "least-recently-used" (LRU), where we always route to the REQ that's been waiting longest. Here is an example that does LRU routing to a set of REQs:</para>

<example id="rtmama-c">
<title>ROUTER-to-REQ (rtmama.c)</title>
<programlisting language="c">
//
//  Custom routing Router to Mama (ROUTER to REQ)
//
#include "zhelpers.h"
#include &lt;pthread.h&gt;

#define NBR_WORKERS 10

static void *
worker_task (void *args)
{
    void *context = zmq_ctx_new ();
    void *worker = zmq_socket (context, ZMQ_REQ);

    //  We use a string identity for ease here
    s_set_id (worker);
    zmq_connect (worker, "ipc://routing.ipc");

    int total = 0;
    while (true) {
        //  Tell the router we're ready for work
        s_send (worker, "ready");

        //  Get workload from router, until finished
        char *workload = s_recv (worker);
        int finished = (strcmp (workload, "END") == 0);
        free (workload);
        if (finished) {
            printf ("Processed: %d tasks\n", total);
            break;
        }
        total++;

        //  Do some random work
        s_sleep (randof (1000) + 1);
    }
    zmq_close (worker);
    zmq_ctx_destroy (context);
    return NULL;
}
</programlisting>

</example>
<para>While this example runs in a single process, that is just to make it easier to start and stop the example. Each thread has its own context and conceptually acts as a separate process. 
</para>

<example id="rtmama-c-1">
<title>ROUTER-to-REQ (rtmama.c) - main task</title>
<programlisting language="c">

int main (void)
{
    void *context = zmq_ctx_new ();
    void *client = zmq_socket (context, ZMQ_ROUTER);
    zmq_bind (client, "ipc://routing.ipc");
    srandom ((unsigned) time (NULL));

    int worker_nbr;
    for (worker_nbr = 0; worker_nbr &lt; NBR_WORKERS; worker_nbr++) {
        pthread_t worker;
        pthread_create (&amp;worker, NULL, worker_task, NULL);
    }
    int task_nbr;
    for (task_nbr = 0; task_nbr &lt; NBR_WORKERS * 10; task_nbr++) {
        //  LRU worker is next waiting in queue
        char *address = s_recv (client);
        char *empty = s_recv (client);
        free (empty);
        char *ready = s_recv (client);
        free (ready);

        s_sendmore (client, address);
        s_sendmore (client, "");
        s_send (client, "This is the workload");
        free (address);
    }
    //  Now ask mamas to shut down and report their results
    for (worker_nbr = 0; worker_nbr &lt; NBR_WORKERS; worker_nbr++) {
        char *address = s_recv (client);
        char *empty = s_recv (client);
        free (empty);
        char *ready = s_recv (client);
        free (ready);

        s_sendmore (client, address);
        s_sendmore (client, "");
        s_send (client, "END");
        free (address);
    }
    zmq_close (client);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<para>For this example the LRU doesn't need any particular data structures above what &Oslash;MQ gives us (message queues) because we don't need to synchronize the workers with anything. A more realistic LRU algorithm would have to collect workers as they become ready, into a queue, and the use this queue when routing client requests. We'll do this in a later example.</para>

<para>To prove that the LRU is working as expected, the REQs print the total tasks they each did. Since the REQs do random work, and we're not load balancing, we expect each REQ to do approximately the same amount but with random variation. And that is indeed what we see:</para>

<screen>Processed: 8 tasks
Processed: 8 tasks
Processed: 11 tasks
Processed: 7 tasks
Processed: 9 tasks
Processed: 11 tasks
Processed: 14 tasks
Processed: 11 tasks
Processed: 11 tasks
Processed: 10 tasks
</screen>

<para>Some comments on this code</para>

<itemizedlist>
  <listitem><para>We don't need any settle time, since the REQs explicitly tell the ROUTER when they are ready.</para></listitem>
  <listitem><para>We're generating our own identities here, as printable strings, using the zhelpers.h s_set_id function. That's just to make our life a little simpler. In a realistic application the REQs would be fully anonymous and then you'd call <literal>zmq_msg_recv()</literal> and <literal>zmq_msg_send()</literal> directly instead of the zhelpers <literal>s_recv</literal> and <literal>s_send</literal> functions, which can only handle strings.</para></listitem>
  <listitem><para>If you copy and paste example code without understanding it, you deserve what you get. It's like watching Spiderman leap off the roof and then trying that yourself.</para></listitem>
</itemizedlist>
<para>To route to a REQ, we must create a REQ-friendly envelope consisting of an address plus an empty message frame(<xref linkend="figure-33"/>).</para>

<figure id="figure-33">
    <title>Routing Envelope for REQ</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig33.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

</sect1>
<sect1>
<title>Address-based Routing</title>
<para>In a classic request-reply pattern a ROUTER wouldn't talk to a REP socket at all, but rather would get a DEALER to do the job for it. It's worth remembering with &Oslash;MQ that the classic patterns are the ones that work best, that the beaten path is there for a reason, and that when we go off-road we take the risk of falling off cliffs and getting eaten by zombies. Having said that, let's plug a ROUTER into a REP and see what the heck emerges.</para>

<para>The special thing about REPs is actually two things:</para>

<itemizedlist>
  <listitem><para>One, they are strictly lockstep request-reply.</para></listitem>
  <listitem><para>Two, they accept an envelope stack of any size and will return that intact.</para></listitem>
</itemizedlist>
<para>In the normal request-reply pattern, REPs are anonymous and replaceable, but we're learning about custom routing. So, in our use-case we have reason to send a request to REP A rather than REP B. This is essential if you want to keep some kind of a conversation going between you, at one end of a large network, and a REP sitting somewhere far away.</para>

<para>A core philosophy of &Oslash;MQ is that the edges are smart and many, and the middle is vast and dumb. This does mean the edges can address each other, and this also means we want to know how to reach a given REP. Doing routing across multiple hops is something we'll look at later but for now we'll look just at the final step: a ROUTER talking to a specific REP(<xref linkend="figure-34"/>).</para>

<figure id="figure-34">
    <title>ROUTER-to-REP Custom Routing</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig34.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>This example shows a very specific chain of events:</para>

<itemizedlist>
  <listitem><para>The client has a message that it expects to route back (via another ROUTER) to some node. The message has two addresses (a stack), an empty part, and a body.</para></listitem>
  <listitem><para>The client passes that to the ROUTER but specifies a REP address first.</para></listitem>
  <listitem><para>The ROUTER removes the REP address, uses that to decide which REP to send the message to.</para></listitem>
  <listitem><para>The REP receives the addresses, empty part, and body.</para></listitem>
  <listitem><para>It removes the addresses, saves them, and passes the body to the worker.</para></listitem>
  <listitem><para>The worker sends a reply back to the REP.</para></listitem>
  <listitem><para>The REP recreates the envelope stack and sends that back with the worker's reply to the ROUTER.</para></listitem>
  <listitem><para>The ROUTER prepends the REP's address and provides that to the client along with the rest of the address stack, empty part, and the body.</para></listitem>
</itemizedlist>
<para>It's complex but worth working through until you understand it. Just remember a REP is garbage in, garbage out.</para>

<example id="rtpapa-c">
<title>ROUTER-to-REP (rtpapa.c)</title>
<programlisting language="c">
//
//  Custom routing Router to Papa (ROUTER to REP)
//
#include "zhelpers.h"

//  We will do this all in one thread to emphasize the sequence
//  of events...
int main (void) 
{
    void *context = zmq_ctx_new ();

    void *client = zmq_socket (context, ZMQ_ROUTER);
    zmq_bind (client, "ipc://routing.ipc");

    void *worker = zmq_socket (context, ZMQ_REP);
    zmq_setsockopt (worker, ZMQ_IDENTITY, "A", 1);
    zmq_connect (worker, "ipc://routing.ipc");

    //  Wait for the worker to connect so that when we send a message
    //  with routing envelope, it will actually match the worker...
    sleep (1);

    //  Send papa address, address stack, empty part, and request
    s_sendmore (client, "A");
    s_sendmore (client, "address 3");
    s_sendmore (client, "address 2");
    s_sendmore (client, "address 1");
    s_sendmore (client, "");
    s_send     (client, "This is the workload");

    //  Worker should get just the workload
    s_dump (worker);

    //  We don't play with envelopes in the worker
    s_send (worker, "This is the reply");

    //  Now dump what we got off the ROUTER socket...
    s_dump (client);

    zmq_close (client);
    zmq_close (worker);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<para>Run this program and it should show you this:</para>

<screen>----------------------------------------
[020] This is the workload
----------------------------------------
[001] A
[009] address 3
[009] address 2
[009] address 1
[000]
[017] This is the reply
</screen>

<para>Some comments on this code:</para>

<itemizedlist>
  <listitem><para>In reality we'd have the REP and ROUTER in separate nodes. This example does it all in one thread because it makes the sequence of events really clear.</para></listitem>
  <listitem><para><literal>zmq_connect()</literal> doesn't happen instantly. When the REP socket connects to the ROUTER, that takes a certain time and happens in the background. In a realistic application the ROUTER wouldn't even know the REP existed until there had been some previous dialog. In our toy example we'll just <literal>sleep (1);</literal> to make sure the connection's done. If you remove the sleep, the REP socket won't get the message. (Try it.)</para></listitem>
  <listitem><para>We're routing using the REP's identity. Just to convince yourself this really is happening, try sending to a wrong address, like "B". The REP won't get the message.</para></listitem>
  <listitem><para>The s_dump and other utility functions (in the C code) come from the zhelpers.h header file. It becomes clear that we do the same work over and over on sockets, and there are interesting layers we can build on top of the &Oslash;MQ API. We'll come back to this later when we make a real application rather than these toy examples.</para></listitem>
</itemizedlist>
<para>To route to a REP, we must create a REP-friendly envelope(<xref linkend="figure-35"/>).</para>

<figure id="figure-35">
    <title>Routing Envelope for REP</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig35.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

</sect1>
<sect1>
<title>A Request-Reply Message Broker</title>
<para>I'll recap the knowledge we have so far about doing weird stuff with &Oslash;MQ message envelopes, and build the core of a generic custom routing proxy that we can properly call a <emphasis>message broker</emphasis>. Sorry for all the buzzwords. What we'll make is a <emphasis>proxy</emphasis> that connects a bunch of <emphasis>clients</emphasis> to a bunch of <emphasis>workers</emphasis>, and lets you use <emphasis>any routing algorithm</emphasis> you want. The algorithm we'll implement is <emphasis>least-recently used</emphasis>, since it's the most obvious use-case after simple round-robin distribution.</para>

<para>To start with, let's look back at the classic request-reply pattern and then see how it extends over a larger and larger service-oriented network. The basic pattern just has one client talking to a few workers(<xref linkend="figure-36"/>).</para>

<figure id="figure-36">
    <title>Basic Request-reply</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig36.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>This extends to multiple workers, but if we want to handle multiple clients as well, we need a proxy in the middle. We'd use a simple proxy connecting a ROUTER and a DEALER back to back. This proxy just switches message frames between the two sockets as fast as it can(<xref linkend="figure-37"/>).</para>

<figure id="figure-37">
    <title>Stretched Request-reply</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig37.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>The key here is that the ROUTER stores the originating client address in the request envelope, the DEALER and workers don't touch that, and so the ROUTER knows which client to send the reply back to. This pattern assumes all workers provide the exact same service.</para>

<para>In the above design, we're using the built-in round-robin routing that DEALER provides. However this means some workers may be idle while others have multiple requests waiting. For better efficiency and proper load-balancing we want to use a least-recently used algorithm, so we take the ROUTER-REQ pattern we learned, and apply that(<xref linkend="figure-38"/>).</para>

<figure id="figure-38">
    <title>Stretched Request-reply with LRU</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig38.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>Our broker - a ROUTER-to-ROUTER LRU queue - can't simply copy message frames blindly. Here is the code, it's a fair chunk of code, but we can reuse the core logic any time we want to do load-balancing:</para>

<example id="lruqueue-c">
<title>LRU queue broker (lruqueue.c)</title>
<programlisting language="c">
//
//  Least-recently used (LRU) queue device
//  Clients and workers are shown here in-process
//
#include "zhelpers.h"
#include &lt;pthread.h&gt;

#define NBR_CLIENTS 10
#define NBR_WORKERS 3

//  Dequeue operation for queue implemented as array of anything
#define DEQUEUE(q) memmove (&amp;(q)[0], &amp;(q)[1], sizeof (q) - sizeof (q [0]))

//  Basic request-reply client using REQ socket
//  Since s_send and s_recv can't handle 0MQ binary identities we
//  set a printable text identity to allow routing.
//
static void *
client_task (void *args)
{
    void *context = zmq_ctx_new ();
    void *client = zmq_socket (context, ZMQ_REQ);
    s_set_id (client);          //  Set a printable identity
    zmq_connect (client, "ipc://frontend.ipc");

    //  Send request, get reply
    s_send (client, "HELLO");
    char *reply = s_recv (client);
    printf ("Client: %s\n", reply);
    free (reply);
    zmq_close (client);
    zmq_ctx_destroy (context);
    return NULL;
}
</programlisting>

</example>
<para>While this example runs in a single process, that is just to make it easier to start and stop the example. Each thread has its own context and conceptually acts as a separate process. This is the worker task, using a REQ socket to do LRU routing. Since s_send and s_recv can't handle &Oslash;MQ binary identities we set a printable text identity to allow routing. 
</para>

<example id="lruqueue-c-1">
<title>LRU queue broker (lruqueue.c) - worker task</title>
<programlisting language="c">

static void *
worker_task (void *args)
{
    void *context = zmq_ctx_new ();
    void *worker = zmq_socket (context, ZMQ_REQ);
    s_set_id (worker);          //  Set a printable identity
    zmq_connect (worker, "ipc://backend.ipc");

    //  Tell broker we're ready for work
    s_send (worker, "READY");

    while (true) {
        //  Read and save all frames until we get an empty frame
        //  In this example there is only 1 but it could be more
        char *address = s_recv (worker);
        char *empty = s_recv (worker);
        assert (*empty == 0);
        free (empty);

        //  Get request, send reply
        char *request = s_recv (worker);
        printf ("Worker: %s\n", request);
        free (request);

        s_sendmore (worker, address);
        s_sendmore (worker, "");
        s_send     (worker, "OK");
        free (address);
    }
    zmq_close (worker);
    zmq_ctx_destroy (context);
    return NULL;
}
</programlisting>

</example>
<para>This is the main task. It starts the clients and workers, and then routes requests between the two layers. Workers signal READY when they start; after that we treat them as ready when they reply with a response back to a client. The LRU data structure is just a queue of next available workers. 
</para>

<example id="lruqueue-c-2">
<title>LRU queue broker (lruqueue.c) - main task</title>
<programlisting language="c">

int main (void)
{
    //  Prepare our context and sockets
    void *context = zmq_ctx_new ();
    void *frontend = zmq_socket (context, ZMQ_ROUTER);
    void *backend  = zmq_socket (context, ZMQ_ROUTER);
    zmq_bind (frontend, "ipc://frontend.ipc");
    zmq_bind (backend,  "ipc://backend.ipc");

    int client_nbr;
    for (client_nbr = 0; client_nbr &lt; NBR_CLIENTS; client_nbr++) {
        pthread_t client;
        pthread_create (&amp;client, NULL, client_task, NULL);
    }
    int worker_nbr;
    for (worker_nbr = 0; worker_nbr &lt; NBR_WORKERS; worker_nbr++) {
        pthread_t worker;
        pthread_create (&amp;worker, NULL, worker_task, NULL);
    }
</programlisting>

</example>
<para>Here is the main loop for the least-recently-used queue. It has two sockets; a frontend for clients and a backend for workers. It polls the backend in all cases, and polls the frontend only when there are one or more workers ready. This is a neat way to use &Oslash;MQ's own queues to hold messages we're not ready to process yet. When we get a client reply, we pop the next available worker, and send the request to it, including the originating client address. When a worker replies, we re-queue that worker, and we forward the reply to the original client, using the address envelope. 
</para>

<example id="lruqueue-c-3">
<title>LRU queue broker (lruqueue.c) - main task body</title>
<programlisting language="c">
    //  Queue of available workers
    int available_workers = 0;
    char *worker_queue [10];

    while (true) {
        zmq_pollitem_t items [] = {
            { backend,  0, ZMQ_POLLIN, 0 },
            { frontend, 0, ZMQ_POLLIN, 0 }
        };
        //  Poll frontend only if we have available workers
        int rc = zmq_poll (items, available_workers ? 2 : 1, -1);
        if (rc == -1)
            break;              //  Interrupted

        //  Handle worker activity on backend
        if (items [0].revents &amp; ZMQ_POLLIN) {
            //  Queue worker address for LRU routing
            char *worker_addr = s_recv (backend);
            assert (available_workers &lt; NBR_WORKERS);
            worker_queue [available_workers++] = worker_addr;

            //  Second frame is empty
            char *empty = s_recv (backend);
            assert (empty [0] == 0);
            free (empty);

            //  Third frame is READY or else a client reply address
            char *client_addr = s_recv (backend);

            //  If client reply, send rest back to frontend
            if (strcmp (client_addr, "READY") != 0) {
                empty = s_recv (backend);
                assert (empty [0] == 0);
                free (empty);
                char *reply = s_recv (backend);
                s_sendmore (frontend, client_addr);
                s_sendmore (frontend, "");
                s_send     (frontend, reply);
                free (reply);
                if (--client_nbr == 0)
                    break;      //  Exit after N messages
            }
            free (client_addr);
        }
</programlisting>

</example>
<para>Here is how we handle a client request: 
</para>

<example id="lruqueue-c-4">
<title>LRU queue broker (lruqueue.c) - handling a client request</title>
<programlisting language="c">
        if (items [1].revents &amp; ZMQ_POLLIN) {
            //  Now get next client request, route to LRU worker
            //  Client request is [address][empty][request]
            char *client_addr = s_recv (frontend);
            char *empty = s_recv (frontend);
            assert (empty [0] == 0);
            free (empty);
            char *request = s_recv (frontend);

            s_sendmore (backend, worker_queue [0]);
            s_sendmore (backend, "");
            s_sendmore (backend, client_addr);
            s_sendmore (backend, "");
            s_send     (backend, request);

            free (client_addr);
            free (request);

            //  Dequeue and drop the next worker address
            free (worker_queue [0]);
            DEQUEUE (worker_queue);
            available_workers--;
        }
    }
    zmq_close (frontend);
    zmq_close (backend);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<para>The difficult part of this program is (a) the envelopes that each socket reads and writes, and (b) the LRU algorithm. We'll take these in turn, starting with the message envelope formats.</para>

<para>First, recall that a REQ REQ socket always puts on an empty part (the envelope delimiter) on sending and removes this empty part on reception. The reason for this isn't important, it's just part of the 'normal' request-reply pattern. What we care about here is just keeping REQ happy by doing precisely what she needs. Second, the ROUTER always adds an envelope with the address of whomever the message came from.</para>

<para>We can now walk through a full request-reply chain from client to worker and back. In this code we set the identity of client and worker sockets to make it easier to trace the message frames. Most normal applications do not use identities. Let's assume the client's identity is "CLIENT" and the worker's identity is "WORKER". The client sends a single frame with the message(<xref linkend="figure-39"/>).</para>

<figure id="figure-39">
    <title>Message that Client Sends</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig39.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>What the queue gets, when reading off the ROUTER frontend socket, are three frames consisting of the sender address, empty frame delimiter, and the data part(<xref linkend="figure-40"/>).</para>

<figure id="figure-40">
    <title>Message Coming in on Frontend</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig40.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>The broker sends this to the worker, prefixed by the address of the worker, taken from the LRU queue, plus an additional empty part to keep the REQ at the other end happy(<xref linkend="figure-41"/>).</para>

<figure id="figure-41">
    <title>Message Sent to Backend</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig41.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>This complex envelope stack gets chewed up first by the backend ROUTER socket, which removes the first frame. Then the REQ socket in the worker removes the empty part, and provides the rest to the worker application(<xref linkend="figure-42"/>).</para>

<figure id="figure-42">
    <title>Message Delivered to Worker</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig42.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>Which is exactly the same as what the queue received on its frontend ROUTER socket. The worker has to save the envelope (which is all the parts up to and including the empty message frame) and then it can do what's needed with the data part.</para>

<para>On the return path the messages are the same as when they come in, i.e. the backend socket gives the queue a message in five parts, and the queue sends the frontend socket a message in three parts, and the client gets a message in one part.</para>

<para>Now let's look at the LRU algorithm. It requires that both clients and workers use REQ sockets, and that workers correctly store and replay the envelope on messages they get. The algorithm is:</para>

<itemizedlist>
  <listitem><para>Create a pollset which polls the backend always, and the frontend only if there are one or more workers available.</para></listitem>
  <listitem><para>Poll for activity with infinite timeout.</para></listitem>
  <listitem><para>If there is activity on the backend, we either have a "ready" message or a reply for a client. In either case we store the worker address (the first part) on our LRU queue, and if the rest is a client reply we send it back to that client via the frontend.</para></listitem>
  <listitem><para>If there is activity on the frontend, we take the client request, pop the next worker (which is the least-recently used), and send the request to the backend. This means sending the worker address, empty part, and then the three parts of the client request.</para></listitem>
</itemizedlist>
<para>You should now see that you can reuse and extend the LRU algorithm with variations based on the information the worker provides in its initial "ready" message. For example, workers might start up and do a performance self-test, then tell the broker how fast they are. The broker can then choose the fastest available worker rather than LRU or round-robin.</para>

</sect1>
<sect1>
<title>A High-Level API for &Oslash;MQ</title>
<para>Reading and writing multi-part messages using the native &Oslash;MQ API is, to be polite, a lot of work. Look at the core of the worker thread from our LRU queue broker:</para>

<programlisting language="c">
while (true) {
    //  Read and save all frames until we get an empty frame
    //  In this example there is only 1 but it could be more
    char *address = s_recv (worker);
    char *empty = s_recv (worker);
    assert (*empty == 0);
    free (empty);

    //  Get request, send reply
    char *request = s_recv (worker);
    printf ("Worker: %s\n", request);
    free (request);

    s_sendmore (worker, address);
    s_sendmore (worker, "");
    s_send     (worker, "OK");
    free (address);
}
</programlisting>

<para>That code isn't even reusable, because it can only handle one envelope. And this code already does some wrapping around the &Oslash;MQ API. If we used the libzmq API directly this is what we'd have to write:</para>

<programlisting language="c">
while (true) {
    //  Read and save all frames until we get an empty frame
    //  In this example there is only 1 but it could be more
    zmq_msg_t address;
    zmq_msg_init (&amp;address);
    zmq_msg_recv (worker, &amp;address, 0);

    zmq_msg_t empty;
    zmq_msg_init (&amp;empty);
    zmq_msg_recv (worker, &amp;empty, 0);

    //  Get request, send reply
    zmq_msg_t payload;
    zmq_msg_init (&amp;payload);
    zmq_msg_recv (worker, &amp;payload, 0);

    int char_nbr;
    printf ("Worker: ");
    for (char_nbr = 0; char_nbr &lt; zmq_msg_size (&amp;payload); char_nbr++)
        printf ("%c", *(char *) (zmq_msg_data (&amp;payload) + char_nbr));
    printf ("\n");

    zmq_msg_init_size (&amp;payload, 2);
    memcpy (zmq_msg_data (&amp;payload), "OK", 2);

    zmq_msg_send (worker, &amp;address, ZMQ_SNDMORE);
    zmq_close (&amp;address);
    zmq_msg_send (worker, &amp;empty, ZMQ_SNDMORE);
    zmq_close (&amp;empty);
    zmq_msg_send (worker, &amp;payload, 0);
    zmq_close (&amp;payload);
}
</programlisting>

<para>What we want is an API that lets us receive and send an entire message in one shot, including all envelopes. One that lets us do what we want with the absolute least lines of code. The &Oslash;MQ core API itself doesn't aim to do this, but nothing prevents us making layers on top, and part of learning to use &Oslash;MQ intelligently is to do exactly that.</para>

<para>Making a good message API is fairly difficult, especially if we want to avoid copying data around too much. We have a problem of terminology: &Oslash;MQ uses "message" to describe both multi-part messages, and individual parts of a message. We have a problem of semantics: sometimes it's natural to see message content as printable string data, sometimes as binary blobs.</para>

<para>So one solution is to use three concepts: <emphasis>string</emphasis> (already the basis for {{s_send} and <literal>s_recv</literal>), <emphasis>frame</emphasis> (a message frame), and <emphasis>message</emphasis> (a list of one or more frames). Here is the worker code, rewritten onto an API using these concepts:</para>

<programlisting language="c">
while (true) {
    zmsg_t *zmsg = zmsg_recv (worker);
    zframe_print (zmsg_last (zmsg), "Worker: ");
    zframe_reset (zmsg_last (zmsg), "OK", 2);
    zmsg_send (&amp;zmsg, worker);
}
</programlisting>

<para>Cutting the amount of code we have to write is profitable, especially since the results are easy to read and understand. We can continue this process for other aspects of working with &Oslash;MQ. Let's make a wishlist of things we would like in a higher-level API:</para>

<itemizedlist>
  <listitem><para><emphasis>Automatic handling of sockets.</emphasis> I find it really annoying to have to close sockets manually, and to have to explicitly define the linger timeout in some but not all cases. It'd be great to have a way to close sockets automatically when I close the context.</para></listitem>
  <listitem><para><emphasis>Portable thread management.</emphasis> Every non-trivial &Oslash;MQ application uses threads, but POSIX threads aren't portable. So a decent high-level API should hide this under a portable layer.</para></listitem>
  <listitem><para><emphasis>Portable clocks.</emphasis> Even getting the time to a millisecond resolution, or sleeping for some milliseconds, is not portable. Realistic &Oslash;MQ applications need portable clocks, so our API should provide them.</para></listitem>
  <listitem><para><emphasis>A reactor to replace <literal>zmq_poll()</literal>.</emphasis> The poll loop is simple but clumsy. Writing a lot of these, we end up doing the same work over and over: calculating timers, and calling code when sockets are ready. A simple reactor with socket readers, and timers, would save a lot of repeated work.</para></listitem>
  <listitem><para><emphasis>Proper handling of Ctrl-C.</emphasis> We already saw how to catch an interrupt. It would be useful if this happened in all applications.</para></listitem>
</itemizedlist>
<para>Turning this wishlist into reality gives us <ulink url="http://zero.mq/c">CZMQ</ulink>, a high-level C API for &Oslash;MQ. This high-level binding in fact developed out of earlier versions of the Guide. It combines nicer semantics for working with &Oslash;MQ with some portability layers, and (importantly for C but less for other languages) containers like hashes and lists. CZMQ also uses an elegant object model that leads to frankly lovely code.</para>

<para>Here is the LRU queue broker rewritten to use a higher-level API (CZMQ for the C case):</para>

<example id="lruqueue2-c">
<title>LRU queue broker using high-level API (lruqueue2.c)</title>
<programlisting language="c">
//
//  Least-recently used (LRU) queue device
//  Demonstrates use of the CZMQ API
//
#include "czmq.h"

#define NBR_CLIENTS 10
#define NBR_WORKERS 3
#define LRU_READY   "\001"      //  Signals worker is ready

//  Basic request-reply client using REQ socket
//
static void *
client_task (void *args)
{
    zctx_t *ctx = zctx_new ();
    void *client = zsocket_new (ctx, ZMQ_REQ);
    zsocket_connect (client, "ipc://frontend.ipc");

    //  Send request, get reply
    while (true) {
        zstr_send (client, "HELLO");
        char *reply = zstr_recv (client);
        if (!reply)
            break;
        printf ("Client: %s\n", reply);
        free (reply);
        sleep (1);
    }
    zctx_destroy (&amp;ctx);
    return NULL;
}

//  Worker using REQ socket to do LRU routing
//
static void *
worker_task (void *args)
{
    zctx_t *ctx = zctx_new ();
    void *worker = zsocket_new (ctx, ZMQ_REQ);
    zsocket_connect (worker, "ipc://backend.ipc");

    //  Tell broker we're ready for work
    zframe_t *frame = zframe_new (LRU_READY, 1);
    zframe_send (&amp;frame, worker, 0);

    //  Process messages as they arrive
    while (true) {
        zmsg_t *msg = zmsg_recv (worker);
        if (!msg)
            break;              //  Interrupted
        //zframe_print (zmsg_last (msg), "Worker: ");
        zframe_reset (zmsg_last (msg), "OK", 2);
        zmsg_send (&amp;msg, worker);
    }
    zctx_destroy (&amp;ctx);
    return NULL;
}
</programlisting>

</example>
<para>Now we come to the main task. This has the identical functionality to the previous lruqueue example but uses CZMQ to start child threads, to hold the list of workers, and to read and send messages: 
</para>

<example id="lruqueue2-c-1">
<title>LRU queue broker using high-level API (lruqueue2.c) - main task</title>
<programlisting language="c">

int main (void)
{
    zctx_t *ctx = zctx_new ();
    void *frontend = zsocket_new (ctx, ZMQ_ROUTER);
    void *backend = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (frontend, "ipc://frontend.ipc");
    zsocket_bind (backend, "ipc://backend.ipc");

    int client_nbr;
    for (client_nbr = 0; client_nbr &lt; NBR_CLIENTS; client_nbr++)
        zthread_new (client_task, NULL);
    int worker_nbr;
    for (worker_nbr = 0; worker_nbr &lt; NBR_WORKERS; worker_nbr++)
        zthread_new (worker_task, NULL);

    //  Queue of available workers
    zlist_t *workers = zlist_new ();
</programlisting>

</example>
<para>Here is the main loop for the LRU queue. It works the same way as the previous example, but is a lot shorter because CZMQ gives us an API that does more with fewer calls: 
</para>

<example id="lruqueue2-c-2">
<title>LRU queue broker using high-level API (lruqueue2.c) - main LRU queue loop</title>
<programlisting language="c">

        zmq_pollitem_t items [] = {
            { backend,  0, ZMQ_POLLIN, 0 },
            { frontend, 0, ZMQ_POLLIN, 0 }
        };
        //  Poll frontend only if we have available workers
        int rc = zmq_poll (items, zlist_size (workers)? 2: 1, -1);
        if (rc == -1)
            break;              //  Interrupted

        //  Handle worker activity on backend
        if (items [0].revents &amp; ZMQ_POLLIN) {
            //  Use worker address for LRU routing
            zmsg_t *msg = zmsg_recv (backend);
            if (!msg)
                break;          //  Interrupted
            zframe_t *address = zmsg_unwrap (msg);
            zlist_append (workers, address);

            //  Forward message to client if it's not a READY
            zframe_t *frame = zmsg_first (msg);
            if (memcmp (zframe_data (frame), LRU_READY, 1) == 0)
                zmsg_destroy (&amp;msg);
            else
                zmsg_send (&amp;msg, frontend);
        }
        if (items [1].revents &amp; ZMQ_POLLIN) {
            //  Get client request, route to first available worker
            zmsg_t *msg = zmsg_recv (frontend);
            if (msg) {
                zmsg_wrap (msg, (zframe_t *) zlist_pop (workers));
                zmsg_send (&amp;msg, backend);
            }
        }
    }
    //  When we're done, clean up properly
    while (zlist_size (workers)) {
        zframe_t *frame = (zframe_t *) zlist_pop (workers);
        zframe_destroy (&amp;frame);
    }
    zlist_destroy (&amp;workers);
    zctx_destroy (&amp;ctx);
    return 0;
}
</programlisting>

</example>
<para>One thing CZMQ provides is clean interrupt handling. This means that Ctrl-C will cause any blocking &Oslash;MQ call to exit with a return code -1 and errno set to EINTR. The high-level recv methods will return NULL in such cases. So, you can cleanly exit a loop like this:</para>

<programlisting language="c">
while (true) {
    zstr_send (client, "HELLO");
    char *reply = zstr_recv (client);
    if (!reply)
        break;              //  Interrupted
    printf ("Client: %s\n", reply);
    free (reply);
    sleep (1);
}
</programlisting>

<para>Or, if you're calling <literal>zmq_poll()</literal>, test on the return code:</para>

<programlisting language="c">
if (zmq_poll (items, 2, 1000 * 1000) == -1)
    break;              //  Interrupted
</programlisting>

<para>The previous example still uses <literal>zmq_poll()</literal>. So how about reactors? The CZMQ <literal>zloop</literal> reactor is simple but functional. It lets you:</para>

<itemizedlist>
  <listitem><para>Set a reader on any socket, i.e. code that is called whenever the socket has input.</para></listitem>
  <listitem><para>Cancel a reader on a socket.</para></listitem>
  <listitem><para>Set a timer that goes off once or multiple times at specific intervals.</para></listitem>
  <listitem><para>Cancel a timer.</para></listitem>
</itemizedlist>
<para><literal>zloop</literal> of course uses <literal>zmq_poll()</literal> internally. It rebuilds its poll set each time you add or remove readers, and it calculates the poll timeout to match the next timer. Then, it calls the reader and timer handlers for each socket and timer that needs attention.</para>

<para>When we use a reactor pattern, our code turns inside out. The main logic looks like this:</para>

<programlisting language="c">
zloop_t *reactor = zloop_new ();
zloop_reader (reactor, self-&gt;backend, s_handle_backend, self);
zloop_start (reactor);
zloop_destroy (&amp;reactor);
</programlisting>

<para>While the actual handling of messages sits inside dedicated functions or methods. You may not like the style, it's a matter of taste. What it does help with is mixing timers and socket activity. In the rest of this text we'll use <literal>zmq_poll()</literal> in simpler cases, and <literal>zloop</literal> in more complex examples.</para>

<para>Here is the LRU queue broker rewritten once again, this time to use <literal>zloop</literal>:</para>

<example id="lruqueue3-c">
<title>LRU queue broker using zloop (lruqueue3.c)</title>
<programlisting language="c">
//
//  Least-recently used (LRU) queue device
//  Demonstrates use of the CZMQ API and reactor style
//
//  The client and worker tasks are identical from the previous example.
...
//  Our LRU queue structure, passed to reactor handlers
typedef struct {
    void *frontend;             //  Listen to clients
    void *backend;              //  Listen to workers
    zlist_t *workers;           //  List of ready workers
} lruqueue_t;
</programlisting>

</example>
<para>In the reactor design, each time a message arrives on a socket, the reactor passes it to a handler function. We have two handlers; one for the frontend, one for the backend: 
</para>

<example id="lruqueue3-c-1">
<title>LRU queue broker using zloop (lruqueue3.c) - reactor design</title>
<programlisting language="c">


//  Handle input from client, on frontend
int s_handle_frontend (zloop_t *loop, zmq_pollitem_t *poller, void *arg)
{
    lruqueue_t *self = (lruqueue_t *) arg;
    zmsg_t *msg = zmsg_recv (self-&gt;frontend);
    if (msg) {
        zmsg_wrap (msg, (zframe_t *) zlist_pop (self-&gt;workers));
        zmsg_send (&amp;msg, self-&gt;backend);

        //  Cancel reader on frontend if we went from 1 to 0 workers
        if (zlist_size (self-&gt;workers) == 0) {
            zmq_pollitem_t poller = { self-&gt;frontend, 0, ZMQ_POLLIN };
            zloop_poller_end (loop, &amp;poller);
        }
    }
    return 0;
}

//  Handle input from worker, on backend
int s_handle_backend (zloop_t *loop, zmq_pollitem_t *poller, void *arg)
{
    //  Use worker address for LRU routing
    lruqueue_t *self = (lruqueue_t *) arg;
    zmsg_t *msg = zmsg_recv (self-&gt;backend);
    if (msg) {
        zframe_t *address = zmsg_unwrap (msg);
        zlist_append (self-&gt;workers, address);

        //  Enable reader on frontend if we went from 0 to 1 workers
        if (zlist_size (self-&gt;workers) == 1) {
            zmq_pollitem_t poller = { self-&gt;frontend, 0, ZMQ_POLLIN };
            zloop_poller (loop, &amp;poller, s_handle_frontend, self);
        }
        //  Forward message to client if it's not a READY
        zframe_t *frame = zmsg_first (msg);
        if (memcmp (zframe_data (frame), LRU_READY, 1) == 0)
            zmsg_destroy (&amp;msg);
        else
            zmsg_send (&amp;msg, self-&gt;frontend);
    }
    return 0;
}
</programlisting>

</example>
<para>And the main task now sets-up child tasks, then starts its reactor. If you press Ctrl-C, the reactor exits and the main task shuts down. Since the reactor is a CZMQ class, this example may not translate into all languages equally well. 
</para>

<example id="lruqueue3-c-2">
<title>LRU queue broker using zloop (lruqueue3.c) - main task</title>
<programlisting language="c">

int main (void)
{
    zctx_t *ctx = zctx_new ();
    lruqueue_t *self = (lruqueue_t *) zmalloc (sizeof (lruqueue_t));
    self-&gt;frontend = zsocket_new (ctx, ZMQ_ROUTER);
    self-&gt;backend = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (self-&gt;frontend, "ipc://frontend.ipc");
    zsocket_bind (self-&gt;backend, "ipc://backend.ipc");

    int client_nbr;
    for (client_nbr = 0; client_nbr &lt; NBR_CLIENTS; client_nbr++)
        zthread_new (client_task, NULL);
    int worker_nbr;
    for (worker_nbr = 0; worker_nbr &lt; NBR_WORKERS; worker_nbr++)
        zthread_new (worker_task, NULL);

    //  Queue of available workers
    self-&gt;workers = zlist_new ();

    //  Prepare reactor and fire it up
    zloop_t *reactor = zloop_new ();
    zmq_pollitem_t poller = { self-&gt;backend, 0, ZMQ_POLLIN };
    zloop_poller (reactor, &amp;poller, s_handle_backend, self);
    zloop_start  (reactor);
    zloop_destroy (&amp;reactor);

    //  When we're done, clean up properly
    while (zlist_size (self-&gt;workers)) {
        zframe_t *frame = (zframe_t *) zlist_pop (self-&gt;workers);
        zframe_destroy (&amp;frame);
    }
    zlist_destroy (&amp;self-&gt;workers);
    zctx_destroy (&amp;ctx);
    free (self);
    return 0;
}
</programlisting>

</example>
<para>Getting applications to properly shut-down when you send them Ctrl-C can be tricky. If you use the <literal>zctx</literal> class it'll automatically set-up signal handling, but your code still has to cooperate. You must break any loop if <literal>zmq_poll</literal> returns -1 or if any of the <literal>zstr_recv</literal>, <literal>zframe_recv</literal>, or <literal>zmsg_recv</literal> methods return NULL. If you have nested loops, it can be useful to make the outer ones conditional on <literal>!zctx_interrupted</literal>.</para>

</sect1>
<sect1>
<title>Asynchronous Client-Server</title>
<para>In the ROUTER-to-DEALER example we saw a 1-to-N use case where one client talks asynchronously to multiple workers. We can turn this upside-down to get a very useful N-to-1 architecture where various clients talk to a single server, and do this asynchronously(<xref linkend="figure-43"/>).</para>

<figure id="figure-43">
    <title>Asynchronous Client-Server</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig43.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>Here's how it works:</para>

<itemizedlist>
  <listitem><para>Clients connect to the server and send requests.</para></listitem>
  <listitem><para>For each request, the server sends 0 to N replies.</para></listitem>
  <listitem><para>Clients can send multiple requests without waiting for a reply.</para></listitem>
  <listitem><para>Servers can send multiple replies without waiting for new requests.</para></listitem>
</itemizedlist>
<para>Here's code that shows how this works:</para>

<example id="asyncsrv-c">
<title>Asynchronous client-server (asyncsrv.c)</title>
<programlisting language="c">
//
//  Asynchronous client-to-server (DEALER to ROUTER)
//
//  While this example runs in a single process, that is just to make
//  it easier to start and stop the example. Each task has its own
//  context and conceptually acts as a separate process.

#include "czmq.h"

//  ---------------------------------------------------------------------
//  This is our client task
//  It connects to the server, and then sends a request once per second
//  It collects responses as they arrive, and it prints them out. We will
//  run several client tasks in parallel, each with a different random ID.

static void *
client_task (void *args)
{
    zctx_t *ctx = zctx_new ();
    void *client = zsocket_new (ctx, ZMQ_DEALER);

    //  Set random identity to make tracing easier
    char identity [10];
    sprintf (identity, "%04X-%04X", randof (0x10000), randof (0x10000));
    zsockopt_set_identity (client, identity);
    zsocket_connect (client, "tcp://localhost:5570");

    zmq_pollitem_t items [] = { { client, 0, ZMQ_POLLIN, 0 } };
    int request_nbr = 0;
    while (true) {
        //  Tick once per second, pulling in arriving messages
        int centitick;
        for (centitick = 0; centitick &lt; 100; centitick++) {
            zmq_poll (items, 1, 10 * ZMQ_POLL_MSEC);
            if (items [0].revents &amp; ZMQ_POLLIN) {
                zmsg_t *msg = zmsg_recv (client);
                zframe_print (zmsg_last (msg), identity);
                zmsg_destroy (&amp;msg);
            }
        }
        zstr_sendf (client, "request #%d", ++request_nbr);
    }
    zctx_destroy (&amp;ctx);
    return NULL;
}
</programlisting>

</example>
<para>This is our server task. It uses the multithreaded server model to deal requests out to a pool of workers and route replies back to clients. One worker can handle one request at a time but one client can talk to multiple workers at once. 
</para>

<example id="asyncsrv-c-1">
<title>Asynchronous client-server (asyncsrv.c) - server task</title>
<programlisting language="c">

static void server_worker (void *args, zctx_t *ctx, void *pipe);

void *server_task (void *args)
{
    zctx_t *ctx = zctx_new ();

    //  Frontend socket talks to clients over TCP
    void *frontend = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (frontend, "tcp://*:5570");

    //  Backend socket talks to workers over inproc
    void *backend = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_bind (backend, "inproc://backend");

    //  Launch pool of worker threads, precise number is not critical
    int thread_nbr;
    for (thread_nbr = 0; thread_nbr &lt; 5; thread_nbr++)
        zthread_fork (ctx, server_worker, NULL);

    //  Connect backend to frontend via a proxy
    zmq_proxy (frontend, backend, NULL);

    zctx_destroy (&amp;ctx);
    return NULL;
}
</programlisting>

</example>
<para>Each worker task works on one request at a time and sends a random number of replies back, with random delays between replies: 
</para>

<example id="asyncsrv-c-2">
<title>Asynchronous client-server (asyncsrv.c) - worker task</title>
<programlisting language="c">

static void
server_worker (void *args, zctx_t *ctx, void *pipe)
{
    void *worker = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_connect (worker, "inproc://backend");

    while (true) {
        //  The DEALER socket gives us the address envelope and message
        zmsg_t *msg = zmsg_recv (worker);
        zframe_t *address = zmsg_pop (msg);
        zframe_t *content = zmsg_pop (msg);
        assert (content);
        zmsg_destroy (&amp;msg);

        //  Send 0..4 replies back
        int reply, replies = randof (5);
        for (reply = 0; reply &lt; replies; reply++) {
            //  Sleep for some fraction of a second
            zclock_sleep (randof (1000) + 1);
            zframe_send (&amp;address, worker, ZFRAME_REUSE + ZFRAME_MORE);
            zframe_send (&amp;content, worker, ZFRAME_REUSE);
        }
        zframe_destroy (&amp;address);
        zframe_destroy (&amp;content);
    }
}


//  The main thread simply starts several clients, and a server, and then
//  waits for the server to finish.

int main (void)
{
    zctx_t *ctx = zctx_new ();
    zthread_new (client_task, NULL);
    zthread_new (client_task, NULL);
    zthread_new (client_task, NULL);
    zthread_new (server_task, NULL);

    //  Run for 5 seconds then quit
    zclock_sleep (5 * 1000);
    zctx_destroy (&amp;ctx);
    return 0;
}
</programlisting>

</example>
<para>Just run that example by itself. Like other multi-task examples, it runs in a single process but each task has its own context and conceptually acts as a separate process(<xref linkend="figure-44"/>). You will see three clients (each with a random ID), printing out the replies they get from the server. Look carefully and you'll see each client task gets 0 or more replies per request.</para>

<para>Some comments on this code:</para>

<itemizedlist>
  <listitem><para>The clients send a request once per second, and get zero or more replies back. To make this work using <literal>zmq_poll()</literal>, we can't simply poll with a 1-second timeout, or we'd end up sending a new request only one second <emphasis>after we received the last reply</emphasis>. So we poll at a high frequency (100 times at 1/100th of a second per poll), which is approximately accurate. This means the server could use requests as a form of heartbeat, i.e. detecting when clients are present or disconnected.</para></listitem>
  <listitem><para>The server uses a pool of worker threads, each processing one request synchronously. It connects these to its frontend socket using an internal queue. It connects the frontend and backend sockets using a <literal>zmq_proxy()</literal> call.</para></listitem>
</itemizedlist>
<figure id="figure-44">
    <title>Detail of Asynchronous Server</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig44.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>Note that we're doing a DEALER-to-ROUTER dialog between client and server, but internally between the server main thread and workers we're doing DEALER-to-DEALER. If the workers were strictly synchronous, we'd use REP. But since we want to send multiple replies we need an async socket. We do <emphasis>not</emphasis> want to route replies, they always go to the single server thread that sent us the request.</para>

<para>Let's think about the routing envelope. The client sends a simple message. The server thread receives a two-part message (real message prefixed by client identity). We have two possible designs for the server-to-worker interface:</para>

<itemizedlist>
  <listitem><para>Workers get unaddressed messages, and we manage the connections from server thread to worker threads explicitly using a ROUTER socket as backend. This would require that workers start by telling the server they exist, which can then route requests to workers and track which client is 'connected' to which worker. This is the LRU pattern we already covered.</para></listitem>
  <listitem><para>Workers get addressed messages, and they return addressed replies. This requires that workers can properly decode and recode envelopes but it doesn't need any other mechanisms.</para></listitem>
</itemizedlist>
<para>The second design is much simpler, so that's what we use:</para>

<screen>     client          server       frontend       worker
   [ DEALER ]&lt;----&gt;[ ROUTER &lt;----&gt; DEALER &lt;----&gt; DEALER ]
             1 part         2 parts       2 parts
</screen>

<para>When you build servers that maintain stateful conversations with clients, you will run into a classic problem. If the server keeps some state per client, and clients keep coming and going, eventually it will run out of resources. Even if the same clients keep connecting, if you're using default identities, each connection will look like a new one.</para>

<para>We cheat in the above example by keeping state only for a very short time (the time it takes a worker to process a request) and then throwing away the state. But that's not practical for many cases. To properly manage client state in a stateful asynchronous server you have to:</para>

<itemizedlist>
  <listitem><para>Do heartbeating from client to server. In our example we send a request once per second, which can reliably be used as a heartbeat.</para></listitem>
  <listitem><para>Store state using the client identity (whether generated or explicit) as key.</para></listitem>
  <listitem><para>Detect a stopped heartbeat. If there's no request from a client within, say, two seconds, the server can detect this and destroy any state it's holding for that client.</para></listitem>
</itemizedlist>
</sect1>
<sect1>
<title>Worked Example: Inter-Broker Routing</title>
<para>Let's take everything we've seen so far, and scale things up. Our best client calls us urgently and asks for a design of a large cloud computing facility. He has this vision of a cloud that spans many data centers, each a cluster of clients and workers, and that works together as a whole.</para>

<para>Because we're smart enough to know that practice always beats theory, we propose to make a working simulation using &Oslash;MQ. Our client, eager to lock down the budget before his own boss changes his mind, and having read great things about &Oslash;MQ on Twitter, agrees.</para>

<sect2>
<title>Establishing the Details</title>
<para>Several espressos later, we want to jump into writing code but a little voice tells us to get more details before making a sensational solution to entirely the wrong problem. "What kind of work is the cloud doing?", we ask. The client explains:</para>

<itemizedlist>
  <listitem><para>Workers run on various kinds of hardware, but they are all able to handle any task. There are several hundred workers per cluster, and as many as a dozen clusters in total.</para></listitem>
  <listitem><para>Clients create tasks for workers. Each task is an independent unit of work and all the client wants is to find an available worker, and send it the task, as soon as possible. There will be a lot of clients and they'll come and go arbitrarily.</para></listitem>
  <listitem><para>The real difficulty is to be able to add and remove clusters at any time. A cluster can leave or join the cloud instantly, bringing all its workers and clients with it.</para></listitem>
  <listitem><para>If there are no workers in their own cluster, clients' tasks will go off to other available workers in the cloud.</para></listitem>
  <listitem><para>Clients send out one task at a time, waiting for a reply. If they don't get an answer within X seconds they'll just send out the task again. This ain't our concern, the client API does it already.</para></listitem>
  <listitem><para>Workers process one task at a time, they are very simple beasts. If they crash, they get restarted by whatever script started them.</para></listitem>
</itemizedlist>
<para>So we double check to make sure that we understood this correctly:</para>

<itemizedlist>
  <listitem><para>"There will be some kind of super-duper network interconnect between clusters, right?", we ask. The client says, "Yes, of course, we're not idiots."</para></listitem>
  <listitem><para>"What kind of volumes are we talking about?", we ask. The client replies, "Up to a thousand clients per cluster, each doing max. ten requests per second. Requests are small, and replies are also small, no more than 1K bytes each."</para></listitem>
</itemizedlist>
<para>So we do a little calculation and see that this will work nicely over plain TCP. 2,500 clients x 10/second x 1,000 bytes x 2 directions = 50MB/sec or 400Mb/sec, not a problem for a 1Gb network.</para>

<para>It's a straight-forward problem that requires no exotic hardware or protocols, just some clever routing algorithms and careful design. We start by designing one cluster (one data center) and then we figure out how to connect clusters together.</para>

</sect2>
<sect2>
<title>Architecture of a Single Cluster</title>
<para>Workers and clients are synchronous. We want to use the LRU pattern to route tasks to workers. Workers are all identical, our facility has no notion of different services. Workers are anonymous, clients never address them directly. We make no attempt here to provide guaranteed delivery, retry, etc.</para>

<para>For reasons we already looked at, clients and workers won't speak to each other directly. It makes it impossible to add or remove nodes dynamically. So our basic model consists of the request-reply message broker we saw earlier(<xref linkend="figure-45"/>).</para>

<figure id="figure-45">
    <title>Cluster Architecture</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig45.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

</sect2>
<sect2>
<title>Scaling to Multiple Clusters</title>
<para>Now we scale this out to more than one cluster. Each cluster has a set of clients and workers, and a broker that joins these together:</para>

<figure id="figure-46">
    <title>Multiple Clusters</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig46.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>The question is: how do we get the clients of each cluster talking to the workers of the other cluster? There are a few possibilities, each with pros and cons:</para>

<itemizedlist>
  <listitem><para>Clients could connect directly to both brokers. The advantage is that we don't need to modify brokers or workers. But clients get more complex, and become aware of the overall topology. If we want to add, e.g. a third or forth cluster, all the clients are affected. In effect we have to move routing and fail-over logic into the clients and that's not nice.</para></listitem>
  <listitem><para>Workers might connect directly to both brokers. But REQ workers can't do that, they can only reply to one broker. We might use REPs but REPs don't give us customizable broker-to-worker routing like LRU, only the built-in load balancing. That's a fail, if we want to distribute work to idle workers: we precisely need LRU. One solution would be to use ROUTER sockets for the worker nodes. Let's label this "Idea #1".</para></listitem>
  <listitem><para>Brokers could connect to each other. This looks neatest because it creates the fewest additional connections. We can't add clusters on the fly but that is probably out of scope. Now clients and workers remain ignorant of the real network topology, and brokers tell each other when they have spare capacity. Let's label this "Idea #2".</para></listitem>
</itemizedlist>
<para>Let's explore Idea #1. In this model we have workers connecting to both brokers and accepting jobs from either(<xref linkend="figure-47"/>).</para>

<figure id="figure-47">
    <title>Idea 1 - Cross-connected Workers</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig47.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>It looks feasible. However it doesn't provide what we wanted, which was that clients get local workers if possible and remote workers only if it's better than waiting. Also workers will signal "ready" to both brokers and can get two jobs at once, while other workers remain idle. It seems this design fails because again we're putting routing logic at the edges.</para>

<para>So idea #2 then. We interconnect the brokers and don't touch the clients or workers, which are REQs like we're used to(<xref linkend="figure-48"/>).</para>

<figure id="figure-48">
    <title>Idea 2 - Brokers Talking to Each Other</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig48.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>This design is appealing because the problem is solved in one place, invisible to the rest of the world. Basically, brokers open secret channels to each other and whisper, like camel traders, "Hey, I've got some spare capacity, if you have too many clients give me a shout and we'll deal".</para>

<para>It is in effect just a more sophisticated routing algorithm: brokers become subcontractors for each other. Other things to like about this design, even before we play with real code:</para>

<itemizedlist>
  <listitem><para>It treats the common case (clients and workers on the same cluster) as default and does extra work for the exceptional case (shuffling jobs between clusters).</para></listitem>
  <listitem><para>It lets us use different message flows for the different types of work. That means we can handle them differently, e.g. using different types of network connection.</para></listitem>
  <listitem><para>It feels like it would scale smoothly. Interconnecting three, or more brokers doesn't get over-complex. If we find this to be a problem, it's easy to solve by adding a super-broker.</para></listitem>
</itemizedlist>
<para>We'll now make a worked example. We'll pack an entire cluster into one process. That is obviously not realistic but it makes it simple to simulate, and the simulation can accurately scale to real processes. This is the beauty of &Oslash;MQ, you can design at the microlevel and scale that up to the macro level. Threads become processes, become boxes and the patterns and logic remain the same. Each of our 'cluster' processes contains client threads, worker threads, and a broker thread.</para>

<para>We know the basic model well by now:</para>

<itemizedlist>
  <listitem><para>The REQ client (REQ) threads create workloads and pass them to the broker (ROUTER).</para></listitem>
  <listitem><para>The REQ worker (REQ) threads process workloads and return the results to the broker (ROUTER).</para></listitem>
  <listitem><para>The broker queues and distributes workloads using the LRU routing model.</para></listitem>
</itemizedlist>
</sect2>
<sect2>
<title>Federation vs. Peering</title>
<para>There are several possible ways to interconnect brokers. What we <emphasis>want</emphasis> is to be able to tell other brokers, "we have capacity", and then receive multiple tasks. We also need to be able to tell other brokers "stop, we're full". It doesn't need to be perfect: sometimes we may accept jobs we can't process immediately, then we'll do them as soon as possible.</para>

<para>The simplest interconnect is <emphasis>federation</emphasis> in which brokers simulate clients and workers for each other. We would do this by connecting our frontend to the other broker's backend socket(<xref linkend="figure-49"/>). Note that it is legal to both bind a socket to an endpoint and connect it to other endpoints.</para>

<figure id="figure-49">
    <title>Cross-connected Brokers in Federation Model</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig49.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>This would give us simple logic in both brokers and a reasonably good mechanism: when there are no clients, tell the other broker 'ready', and accept one job from it. The problem is also that it is too simple for this problem. A federated broker would be able to handle only one task at once. If the broker emulates a lock-step client and worker, it is by definition also going to be lock-step and if it has lots of available workers they won't be used. Our brokers need to be connected in a fully asynchronous fashion.</para>

<para>The federation model is perfect for other kinds of routing, especially service-oriented architectures or SOAs (which route by service name and proximity rather than LRU or round-robin or random scatter). So don't dismiss it as useless, it's just not right for least-recently used and cluster load-balancing.</para>

<para>So instead of federation, let's look at a <emphasis>peering</emphasis> approach in which brokers are explicitly aware of each other and talk over privileged channels. Let's break this down, assuming we want to interconnect N brokers. Each broker has (N - 1) peers, and all brokers are using exactly the same code and logic. There are two distinct flows of information between brokers:</para>

<itemizedlist>
  <listitem><para>Each broker needs to tell its peers how many workers it has available at any time. This can be fairly simple information, just a quantity that is updated regularly. The obvious (and correct) socket pattern for this is publish-subscribe. So every broker opens a PUB socket and publishes state information on that, and every broker also opens a SUB socket and connects that to the PUB socket of every other broker, to get state information from its peers.</para></listitem>
  <listitem><para>Each broker needs a way to delegate tasks to a peer and get replies back, asynchronously. We'll do this using ROUTER/ROUTER (ROUTER/ROUTER) sockets, no other combination works. Each broker has two such sockets: one for tasks it receives, one for tasks it delegates. If we didn't use two sockets it would be more work to know whether we were reading a request or a reply each time. That would mean adding more information to the message envelope.</para></listitem>
</itemizedlist>
<para>And there is also the flow of information between a broker and its local clients and workers.</para>

</sect2>
<sect2>
<title>The Naming Ceremony</title>
<para>Three flows x two sockets for each flow = six sockets that we have to manage in the broker.  Choosing good names is vital to keeping a multi-socket juggling act reasonably coherent in our minds. Sockets <emphasis>do</emphasis> something and what they do should form the basis for their names. It's about being able to read the code several weeks later on a cold Monday morning before coffee, and not feeling pain.</para>

<para>Let's do a shamanistic naming ceremony for the sockets. The three flows are:</para>

<itemizedlist>
  <listitem><para>A <emphasis>local</emphasis> request-reply flow between the broker and its clients and workers.</para></listitem>
  <listitem><para>A <emphasis>cloud</emphasis> request-reply flow between the broker and its peer brokers.</para></listitem>
  <listitem><para>A <emphasis>state</emphasis> flow between the broker and its peer brokers.</para></listitem>
</itemizedlist>
<para>Finding meaningful names that are all the same length means our code will align nicely. It's not a big thing, but attention to details helps. For each flow the broker has two sockets that we can orthogonally call the "frontend" and "backend". We've used these names quite often. A frontend receives information or tasks. A backend sends those out to other peers. The conceptual flow is from front to back (with replies going in the opposite direction from back to front).</para>

<para>So in all the code we write for this tutorial will use these socket names:</para>

<itemizedlist>
  <listitem><para><emphasis>localfe</emphasis> and <emphasis>localbe</emphasis> for the local flow.</para></listitem>
  <listitem><para><emphasis>cloudfe</emphasis> and <emphasis>cloudbe</emphasis> for the cloud flow.</para></listitem>
  <listitem><para><emphasis>statefe</emphasis> and <emphasis>statebe</emphasis> for the state flow.</para></listitem>
</itemizedlist>
<para>For our transport and because we're simulating the whole thing on one box, we'll use <literal>ipc</literal> for everything. This has the advantage of working like <literal>tcp</literal> in terms of connectivity (i.e. it's a disconnected transport, unlike <literal>inproc</literal>), yet we don't need IP addresses or DNS names, which would be a pain here. Instead, we will use <literal>ipc</literal> endpoints called <emphasis>something</emphasis>-<literal>local</literal>, <emphasis>something</emphasis>-<literal>cloud</literal>, and <emphasis>something</emphasis>-<literal>state</literal>, where <emphasis>something</emphasis> is the name of our simulated cluster.</para>

<para>You may be thinking that this is a lot of work for some names. Why not call them s1, s2, s3, s4, etc.? The answer is that if your brain is not a perfect machine, you need a lot of help when reading code, and we'll see that these names do help. It's easier to remember "three flows, two directions" than "six different sockets"(<xref linkend="figure-50"/>).</para>

<figure id="figure-50">
    <title>Broker Socket Arrangement</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig50.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>Note that we connect the cloudbe in each broker to the cloudfe in every other broker, and likewise we connect the statebe in each broker to the statefe in every other broker.</para>

</sect2>
<sect2>
<title>Prototyping the State Flow</title>
<para>Since each socket flow has its own little traps for the unwary, we will test them in real code one by one, rather than try to throw the whole lot into code in one go. When we're happy with each flow, we can put them together into a full program. We'll start with the state flow(<xref linkend="figure-51"/>).</para>

<figure id="figure-51">
    <title>The State Flow</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig51.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>Here is how this works in code:</para>

<example id="peering1-c">
<title>Prototype state flow (peering1.c)</title>
<programlisting language="c">
//
//  Broker peering simulation (part 1)
//  Prototypes the state flow
//
#include "czmq.h"

int main (int argc, char *argv [])
{
    //  First argument is this broker's name
    //  Other arguments are our peers' names
    //
    if (argc &lt; 2) {
        printf ("syntax: peering1 me {you}...\n");
        exit (EXIT_FAILURE);
    }
    char *self = argv [1];
    printf ("I: preparing broker at %s...\n", self);
    srandom ((unsigned) time (NULL));

    zctx_t *ctx = zctx_new ();
    
    //  Bind state backend to endpoint
    void *statebe = zsocket_new (ctx, ZMQ_PUB);
    zsocket_bind (statebe, "ipc://%s-state.ipc", self);
    
    //  Connect statefe to all peers
    void *statefe = zsocket_new (ctx, ZMQ_SUB);
    zsockopt_set_subscribe (statefe, "");
    int argn;
    for (argn = 2; argn &lt; argc; argn++) {
        char *peer = argv [argn];
        printf ("I: connecting to state backend at '%s'\n", peer);
        zsocket_connect (statefe, "ipc://%s-state.ipc", peer);
    }
</programlisting>

</example>
<para>The main loop sends out status messages to peers, and collects status messages back from peers. The zmq_poll timeout defines our own heartbeat: 
</para>

<example id="peering1-c-1">
<title>Prototype state flow (peering1.c) - main loop</title>
<programlisting language="c">
    while (true) {
        //  Poll for activity, or 1 second timeout
        zmq_pollitem_t items [] = { { statefe, 0, ZMQ_POLLIN, 0 } };
        int rc = zmq_poll (items, 1, 1000 * ZMQ_POLL_MSEC);
        if (rc == -1)
            break;              //  Interrupted

        //  Handle incoming status messages
        if (items [0].revents &amp; ZMQ_POLLIN) {
            char *peer_name = zstr_recv (statefe);
            char *available = zstr_recv (statefe);
            printf ("%s - %s workers free\n", peer_name, available);
            free (peer_name);
            free (available);
        }
        else {
            //  Send random values for worker availability
            zstr_sendm (statebe, self);
            zstr_sendf (statebe, "%d", randof (10));
        }
    }
    zctx_destroy (&amp;ctx);
    return EXIT_SUCCESS;
}
</programlisting>

</example>
<para>Notes about this code:</para>

<itemizedlist>
  <listitem><para>Each broker has an identity that we use to construct <literal>ipc</literal> endpoint names. A real broker would need to work with TCP and a more sophisticated configuration scheme. We'll look at such schemes later in this book but for now, using generated <literal>ipc</literal> names lets us ignore the problem of where to get TCP/IP addresses or names from.</para></listitem>
  <listitem><para>We use a <literal>zmq_poll()</literal> loop as the core of the program. This processes incoming messages and sends out state messages. We send a state message <emphasis>only</emphasis> if we did not get any incoming messages <emphasis>and</emphasis> we waited for a second. If we send out a state message each time we get one in, we'll get message storms.</para></listitem>
  <listitem><para>We use a two-part pubsub message consisting of sender address and data. Note that we will need to know the address of the publisher in order to send it tasks, and the only way is to send this explicitly as a part of the message.</para></listitem>
  <listitem><para>We don't set identities on subscribers, because if we did then we'd get out of date state information when connecting to running brokers.</para></listitem>
  <listitem><para>We don't set a HWM on the publisher, but if we were using &Oslash;MQ/2.x that would be a wise idea.</para></listitem>
</itemizedlist>
<para>We can build this little program and run it three times to simulate three clusters. Let's call them DC1, DC2, and DC3 (the names are arbitrary). We run these three commands, each in a separate window:</para>

<screen>peering1 DC1 DC2 DC3  #  Start DC1 and connect to DC2 and DC3
peering1 DC2 DC1 DC3  #  Start DC2 and connect to DC1 and DC3
peering1 DC3 DC1 DC2  #  Start DC3 and connect to DC1 and DC2
</screen>

<para>You'll see each cluster report the state of its peers, and after a few seconds they will all happily be printing random numbers once per second. Try this and satisfy yourself that the three brokers all match up and synchronize to per-second state updates.</para>

<para>In real life we'd not send out state messages at regular intervals but rather whenever we had a state change, i.e. whenever a worker becomes available or unavailable. That may seem like a lot of traffic but state messages are small and we've established that the inter-cluster connections are super-fast.</para>

<para>If we wanted to send state messages at precise intervals we'd create a child thread and open the statebe socket in that thread. We'd then send irregular state updates to that child thread from our main thread, and allow the child thread to conflate them into regular outgoing messages. This is more work than we need here.</para>

</sect2>
<sect2>
<title>Prototyping the Local and Cloud Flows</title>
<para>Let's now prototype at the flow of tasks via the local and cloud sockets(<xref linkend="figure-52"/>). This code pulls requests from clients and then distributes them to local workers and cloud peers on a random basis.</para>

<figure id="figure-52">
    <title>The Flow of Tasks</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig52.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>Before we jump into the code, which is getting a little complex, let's sketch the core routing logic and break it down into a simple but robust design.</para>

<para>We need two queues, one for requests from local clients and one for requests from cloud clients. One option would be to pull messages off the local and cloud frontends, and pump these onto their respective queues. But this is kind of pointless because &Oslash;MQ sockets <emphasis>are</emphasis> queues already. So let's use the &Oslash;MQ socket buffers as queues.</para>

<para>This was the technique we used in the LRU queue broker, and it worked nicely. We only read from the two frontends when there is somewhere to send the requests. We can always read from the backends, since they give us replies to route back. As long as the backends aren't talking to us, there's no point in even looking at the frontends.</para>

<para>So our main loop becomes:</para>

<itemizedlist>
  <listitem><para>Poll the backends for activity. When we get a message, it may be "READY" from a worker or it may be a reply. If it's a reply, route back via the local or cloud frontend.</para></listitem>
  <listitem><para>If a worker replied, it became available, so we queue it and count it.</para></listitem>
  <listitem><para>While there are workers available, take a request, if any, from either frontend and route to a local worker, or randomly, a cloud peer.</para></listitem>
</itemizedlist>
<para>Randomly sending tasks to a peer broker rather than a worker simulates work distribution across the cluster. It's dumb but that is fine for this stage.</para>

<para>We use broker identities to route messages between brokers. Each broker has a name, which we provide on the command line in this simple prototype. As long as these names don't overlap with the &Oslash;MQ-generated UUIDs used for client nodes, we can figure out whether to route a reply back to a client or to a broker.</para>

<para>Here is how this works in code. The interesting part starts around the comment "Interesting part".</para>

<example id="peering2-c">
<title>Prototype local and cloud flow (peering2.c)</title>
<programlisting language="c">
//
//  Broker peering simulation (part 2)
//  Prototypes the request-reply flow
//
#include "czmq.h"

#define NBR_CLIENTS 10
#define NBR_WORKERS 3
#define LRU_READY   "\001"      //  Signals worker is ready

//  Our own name; in practice this would be configured per node
static char *self;
</programlisting>

</example>
<para>The client task does a request-reply dialog using a standard synchronous REQ socket: 
</para>

<example id="peering2-c-1">
<title>Prototype local and cloud flow (peering2.c) - client task</title>
<programlisting language="c">

static void *
client_task (void *args)
{
    zctx_t *ctx = zctx_new ();
    void *client = zsocket_new (ctx, ZMQ_REQ);
    zsocket_connect (client, "ipc://%s-localfe.ipc", self);

    while (true) {
        //  Send request, get reply
        zstr_send (client, "HELLO");
        char *reply = zstr_recv (client);
        if (!reply)
            break;              //  Interrupted
        printf ("Client: %s\n", reply);
        free (reply);
        sleep (1);
    }
    zctx_destroy (&amp;ctx);
    return NULL;
}
</programlisting>

</example>
<para>The worker task plugs into the LRU routing dialog using a REQ socket: 
</para>

<example id="peering2-c-2">
<title>Prototype local and cloud flow (peering2.c) - worker task</title>
<programlisting language="c">

static void *
worker_task (void *args)
{
    zctx_t *ctx = zctx_new ();
    void *worker = zsocket_new (ctx, ZMQ_REQ);
    zsocket_connect (worker, "ipc://%s-localbe.ipc", self);

    //  Tell broker we're ready for work
    zframe_t *frame = zframe_new (LRU_READY, 1);
    zframe_send (&amp;frame, worker, 0);

    //  Process messages as they arrive
    while (true) {
        zmsg_t *msg = zmsg_recv (worker);
        if (!msg)
            break;              //  Interrupted

        zframe_print (zmsg_last (msg), "Worker: ");
        zframe_reset (zmsg_last (msg), "OK", 2);
        zmsg_send (&amp;msg, worker);
    }
    zctx_destroy (&amp;ctx);
    return NULL;
}
</programlisting>

</example>
<para>The main task begins by setting-up its frontend and backend sockets and then starting its client and worker tasks: 
</para>

<example id="peering2-c-3">
<title>Prototype local and cloud flow (peering2.c) - main task</title>
<programlisting language="c">

int main (int argc, char *argv [])
{
    //  First argument is this broker's name
    //  Other arguments are our peers' names
    //
    if (argc &lt; 2) {
        printf ("syntax: peering2 me {you}...\n");
        exit (EXIT_FAILURE);
    }
    self = argv [1];
    printf ("I: preparing broker at %s...\n", self);
    srandom ((unsigned) time (NULL));

    zctx_t *ctx = zctx_new ();

    //  Bind cloud frontend to endpoint
    void *cloudfe = zsocket_new (ctx, ZMQ_ROUTER);
    zsockopt_set_identity (cloudfe, self);
    zsocket_bind (cloudfe, "ipc://%s-cloud.ipc", self);

    //  Connect cloud backend to all peers
    void *cloudbe = zsocket_new (ctx, ZMQ_ROUTER);
    zsockopt_set_identity (cloudbe, self);
    int argn;
    for (argn = 2; argn &lt; argc; argn++) {
        char *peer = argv [argn];
        printf ("I: connecting to cloud frontend at '%s'\n", peer);
        zsocket_connect (cloudbe, "ipc://%s-cloud.ipc", peer);
    }
    //  Prepare local frontend and backend
    void *localfe = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (localfe, "ipc://%s-localfe.ipc", self);
    void *localbe = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (localbe, "ipc://%s-localbe.ipc", self);

    //  Get user to tell us when we can start...
    printf ("Press Enter when all brokers are started: ");
    getchar ();

    //  Start local workers
    int worker_nbr;
    for (worker_nbr = 0; worker_nbr &lt; NBR_WORKERS; worker_nbr++)
        zthread_new (worker_task, NULL);

    //  Start local clients
    int client_nbr;
    for (client_nbr = 0; client_nbr &lt; NBR_CLIENTS; client_nbr++)
        zthread_new (client_task, NULL);
</programlisting>

</example>
<para>Here we handle the request-reply flow. We're using the LRU approach to poll workers at all times, and clients only when there are one or more workers available. 
</para>

<example id="peering2-c-4">
<title>Prototype local and cloud flow (peering2.c) - request-reply handling</title>
<programlisting language="c">

    //  Least recently used queue of available workers
    int capacity = 0;
    zlist_t *workers = zlist_new ();

    while (true) {
        //  First, route any waiting replies from workers
        zmq_pollitem_t backends [] = {
            { localbe, 0, ZMQ_POLLIN, 0 },
            { cloudbe, 0, ZMQ_POLLIN, 0 }
        };
        //  If we have no workers anyhow, wait indefinitely
        int rc = zmq_poll (backends, 2,
            capacity? 1000 * ZMQ_POLL_MSEC: -1);
        if (rc == -1)
            break;              //  Interrupted

        //  Handle reply from local worker
        zmsg_t *msg = NULL;
        if (backends [0].revents &amp; ZMQ_POLLIN) {
            msg = zmsg_recv (localbe);
            if (!msg)
                break;          //  Interrupted
            zframe_t *address = zmsg_unwrap (msg);
            zlist_append (workers, address);
            capacity++;

            //  If it's READY, don't route the message any further
            zframe_t *frame = zmsg_first (msg);
            if (memcmp (zframe_data (frame), LRU_READY, 1) == 0)
                zmsg_destroy (&amp;msg);
        }
        //  Or handle reply from peer broker
        else
        if (backends [1].revents &amp; ZMQ_POLLIN) {
            msg = zmsg_recv (cloudbe);
            if (!msg)
                break;          //  Interrupted
            //  We don't use peer broker address for anything
            zframe_t *address = zmsg_unwrap (msg);
            zframe_destroy (&amp;address);
        }
        //  Route reply to cloud if it's addressed to a broker
        for (argn = 2; msg &amp;&amp; argn &lt; argc; argn++) {
            char *data = (char *) zframe_data (zmsg_first (msg));
            size_t size = zframe_size (zmsg_first (msg));
            if (size == strlen (argv [argn])
            &amp;&amp;  memcmp (data, argv [argn], size) == 0)
                zmsg_send (&amp;msg, cloudfe);
        }
        //  Route reply to client if we still need to
        if (msg)
            zmsg_send (&amp;msg, localfe);
</programlisting>

</example>
<para>Now we route as many client requests as we have worker capacity for. We may reroute requests from our local frontend, but not from the cloud frontend. We reroute randomly now, just to test things out. In the next version we'll do this properly by calculating cloud capacity: 
</para>

<example id="peering2-c-5">
<title>Prototype local and cloud flow (peering2.c) - route client requests</title>
<programlisting language="c">

        while (capacity) {
            zmq_pollitem_t frontends [] = {
                { localfe, 0, ZMQ_POLLIN, 0 },
                { cloudfe, 0, ZMQ_POLLIN, 0 }
            };
            rc = zmq_poll (frontends, 2, 0);
            assert (rc &gt;= 0);
            int reroutable = 0;
            //  We'll do peer brokers first, to prevent starvation
            if (frontends [1].revents &amp; ZMQ_POLLIN) {
                msg = zmsg_recv (cloudfe);
                reroutable = 0;
            }
            else
            if (frontends [0].revents &amp; ZMQ_POLLIN) {
                msg = zmsg_recv (localfe);
                reroutable = 1;
            }
            else
                break;      //  No work, go back to backends

            //  If reroutable, send to cloud 20% of the time
            //  Here we'd normally use cloud status information
            //
            if (reroutable &amp;&amp; argc &gt; 2 &amp;&amp; randof (5) == 0) {
                //  Route to random broker peer
                int random_peer = randof (argc - 2) + 2;
                zmsg_pushmem (msg, argv [random_peer], strlen (argv [random_peer]));
                zmsg_send (&amp;msg, cloudbe);
            }
            else {
                zframe_t *frame = (zframe_t *) zlist_pop (workers);
                zmsg_wrap (msg, frame);
                zmsg_send (&amp;msg, localbe);
                capacity--;
            }
        }
    }
    //  When we're done, clean up properly
    while (zlist_size (workers)) {
        zframe_t *frame = (zframe_t *) zlist_pop (workers);
        zframe_destroy (&amp;frame);
    }
    zlist_destroy (&amp;workers);
    zctx_destroy (&amp;ctx);
    return EXIT_SUCCESS;
}
</programlisting>

</example>
<para>Run this by, for instance, starting two instance of the broker in two windows:</para>

<screen>peering2 me you
peering2 you me
</screen>

<para>Some comments on this code:</para>

<itemizedlist>
  <listitem><para>Using the zmsg class makes life much easier, and our code much shorter. It's obviously an abstraction that works. If you build &Oslash;MQ applications in C, you should use CZMQ.</para></listitem>
  <listitem><para>Since we're not getting any state information from peers, we naively assume they are running. The code prompts you to confirm when you've started all the brokers. In the real case we'd not send anything to brokers who had not told us they exist.</para></listitem>
</itemizedlist>
<para>You can satisfy yourself that the code works by watching it run forever. If there were any misrouted messages, clients would end up blocking, and the brokers would stop printing trace information. You can prove that by killing either of the brokers. The other broker tries to send requests to the cloud, and one by one its clients block, waiting for an answer.</para>

</sect2>
<sect2>
<title>Putting it All Together</title>
<para>Let's put this together into a single package. As before, we'll run an entire cluster as one process. We're going to take the two previous examples and merge them into one properly working design that lets you simulate any number of clusters.</para>

<para>This code is the size of both previous prototypes together, at 270 LoC. That's pretty good for a simulation of a cluster that includes clients and workers and cloud workload distribution. Here is the code:</para>

<example id="peering3-c">
<title>Full cluster simulation (peering3.c)</title>
<programlisting language="c">
//
//  Broker peering simulation (part 3)
//  Prototypes the full flow of status and tasks
//
#include "czmq.h"

#define NBR_CLIENTS 10
#define NBR_WORKERS 5
#define LRU_READY   "\001"      //  Signals worker is ready

//  Our own name; in practice this would be configured per node
static char *self;
</programlisting>

</example>
<para>This is the client task. It issues a burst of requests and then sleeps for a few seconds. This simulates sporadic activity; when a number of clients are active at once, the local workers should be overloaded. The client uses a REQ socket for requests and also pushes statistics to the monitor socket: 
</para>

<example id="peering3-c-1">
<title>Full cluster simulation (peering3.c) - client task</title>
<programlisting language="c">

static void *
client_task (void *args)
{
    zctx_t *ctx = zctx_new ();
    void *client = zsocket_new (ctx, ZMQ_REQ);
    zsocket_connect (client, "ipc://%s-localfe.ipc", self);
    void *monitor = zsocket_new (ctx, ZMQ_PUSH);
    zsocket_connect (monitor, "ipc://%s-monitor.ipc", self);

    while (true) {
        sleep (randof (5));
        int burst = randof (15);
        while (burst--) {
            char task_id [5];
            sprintf (task_id, "%04X", randof (0x10000));

            //  Send request with random hex ID
            zstr_send (client, task_id);

            //  Wait max ten seconds for a reply, then complain
            zmq_pollitem_t pollset [1] = { { client, 0, ZMQ_POLLIN, 0 } };
            int rc = zmq_poll (pollset, 1, 10 * 1000 * ZMQ_POLL_MSEC);
            if (rc == -1)
                break;          //  Interrupted

            if (pollset [0].revents &amp; ZMQ_POLLIN) {
                char *reply = zstr_recv (client);
                if (!reply)
                    break;              //  Interrupted
                //  Worker is supposed to answer us with our task id
                assert (streq (reply, task_id));
                zstr_sendf (monitor, "%s", reply);
                free (reply);
            }
            else {
                zstr_sendf (monitor,
                    "E: CLIENT EXIT - lost task %s", task_id);
                return NULL;
            }
        }
    }
    zctx_destroy (&amp;ctx);
    return NULL;
}
</programlisting>

</example>
<para>This is the worker task, which uses a REQ socket to plug into the LRU router. It's the same stub worker task you've seen in other examples: 
</para>

<example id="peering3-c-2">
<title>Full cluster simulation (peering3.c) - worker task</title>
<programlisting language="c">

static void *
worker_task (void *args)
{
    zctx_t *ctx = zctx_new ();
    void *worker = zsocket_new (ctx, ZMQ_REQ);
    zsocket_connect (worker, "ipc://%s-localbe.ipc", self);

    //  Tell broker we're ready for work
    zframe_t *frame = zframe_new (LRU_READY, 1);
    zframe_send (&amp;frame, worker, 0);

    //  Process messages as they arrive
    while (true) {
        zmsg_t *msg = zmsg_recv (worker);
        if (!msg)
            break;              //  Interrupted

        //  Workers are busy for 0/1 seconds
        sleep (randof (2));
        zmsg_send (&amp;msg, worker);
    }
    zctx_destroy (&amp;ctx);
    return NULL;
}
</programlisting>

</example>
<para>The main task begins by setting-up all its sockets. The local frontend talks to clients, and our local backend talks to workers. The cloud frontend talks to peer brokers as if they were clients, and the cloud backend talks to peer brokers as if they were workers. The state backend publishes regular state messages, and the state frontend subscribes to all state backends to collect these messages. Finally, we use a PULL monitor socket to collect printable messages from tasks: 
</para>

<example id="peering3-c-3">
<title>Full cluster simulation (peering3.c) - main task</title>
<programlisting language="c">

int main (int argc, char *argv [])
{
    //  First argument is this broker's name
    //  Other arguments are our peers' names
    //
    if (argc &lt; 2) {
        printf ("syntax: peering3 me {you}...\n");
        exit (EXIT_FAILURE);
    }
    self = argv [1];
    printf ("I: preparing broker at %s...\n", self);
    srandom ((unsigned) time (NULL));

    zctx_t *ctx = zctx_new ();

    //  Prepare local frontend and backend
    void *localfe = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (localfe, "ipc://%s-localfe.ipc", self);

    void *localbe = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (localbe, "ipc://%s-localbe.ipc", self);

    //  Bind cloud frontend to endpoint
    void *cloudfe = zsocket_new (ctx, ZMQ_ROUTER);
    zsockopt_set_identity (cloudfe, self);
    zsocket_bind (cloudfe, "ipc://%s-cloud.ipc", self);
    
    //  Connect cloud backend to all peers
    void *cloudbe = zsocket_new (ctx, ZMQ_ROUTER);
    zsockopt_set_identity (cloudbe, self);
    int argn;
    for (argn = 2; argn &lt; argc; argn++) {
        char *peer = argv [argn];
        printf ("I: connecting to cloud frontend at '%s'\n", peer);
        zsocket_connect (cloudbe, "ipc://%s-cloud.ipc", peer);
    }
    //  Bind state backend to endpoint
    void *statebe = zsocket_new (ctx, ZMQ_PUB);
    zsocket_bind (statebe, "ipc://%s-state.ipc", self);

    //  Connect state frontend to all peers
    void *statefe = zsocket_new (ctx, ZMQ_SUB);
    zsockopt_set_subscribe (statefe, "");
    for (argn = 2; argn &lt; argc; argn++) {
        char *peer = argv [argn];
        printf ("I: connecting to state backend at '%s'\n", peer);
        zsocket_connect (statefe, "ipc://%s-state.ipc", peer);
    }
    //  Prepare monitor socket
    void *monitor = zsocket_new (ctx, ZMQ_PULL);
    zsocket_bind (monitor, "ipc://%s-monitor.ipc", self);
</programlisting>

</example>
<para>After binding and connecting all our sockets, we start our child tasks - workers and clients: 
</para>

<example id="peering3-c-4">
<title>Full cluster simulation (peering3.c) - start child tasks</title>
<programlisting language="c">

    int worker_nbr;
    for (worker_nbr = 0; worker_nbr &lt; NBR_WORKERS; worker_nbr++)
        zthread_new (worker_task, NULL);

    //  Start local clients
    int client_nbr;
    for (client_nbr = 0; client_nbr &lt; NBR_CLIENTS; client_nbr++)
        zthread_new (client_task, NULL);

    //  Queue of available workers
    int local_capacity = 0;
    int cloud_capacity = 0;
    zlist_t *workers = zlist_new ();
</programlisting>

</example>
<para>The main loop has two parts. First we poll workers and our two service sockets (statefe and monitor), in any case. If we have no ready workers, there's no point in looking at incoming requests. These can remain on their internal &Oslash;MQ queues: 
</para>

<example id="peering3-c-5">
<title>Full cluster simulation (peering3.c) - main loop</title>
<programlisting language="c">

    while (true) {
        zmq_pollitem_t primary [] = {
            { localbe, 0, ZMQ_POLLIN, 0 },
            { cloudbe, 0, ZMQ_POLLIN, 0 },
            { statefe, 0, ZMQ_POLLIN, 0 },
            { monitor, 0, ZMQ_POLLIN, 0 }
        };
        //  If we have no workers ready, wait indefinitely
        int rc = zmq_poll (primary, 4,
            local_capacity? 1000 * ZMQ_POLL_MSEC: -1);
        if (rc == -1)
            break;              //  Interrupted

        //  Track if capacity changes during this iteration
        int previous = local_capacity;

        //  Handle reply from local worker
        zmsg_t *msg = NULL;

        if (primary [0].revents &amp; ZMQ_POLLIN) {
            msg = zmsg_recv (localbe);
            if (!msg)
                break;          //  Interrupted
            zframe_t *address = zmsg_unwrap (msg);
            zlist_append (workers, address);
            local_capacity++;

            //  If it's READY, don't route the message any further
            zframe_t *frame = zmsg_first (msg);
            if (memcmp (zframe_data (frame), LRU_READY, 1) == 0)
                zmsg_destroy (&amp;msg);
        }
        //  Or handle reply from peer broker
        else
        if (primary [1].revents &amp; ZMQ_POLLIN) {
            msg = zmsg_recv (cloudbe);
            if (!msg)
                break;          //  Interrupted
            //  We don't use peer broker address for anything
            zframe_t *address = zmsg_unwrap (msg);
            zframe_destroy (&amp;address);
        }
        //  Route reply to cloud if it's addressed to a broker
        for (argn = 2; msg &amp;&amp; argn &lt; argc; argn++) {
            char *data = (char *) zframe_data (zmsg_first (msg));
            size_t size = zframe_size (zmsg_first (msg));
            if (size == strlen (argv [argn])
            &amp;&amp;  memcmp (data, argv [argn], size) == 0)
                zmsg_send (&amp;msg, cloudfe);
        }
        //  Route reply to client if we still need to
        if (msg)
            zmsg_send (&amp;msg, localfe);
</programlisting>

</example>
<para>If we have input messages on our statefe or monitor sockets we can process these immediately: 
</para>

<example id="peering3-c-6">
<title>Full cluster simulation (peering3.c) - handle state messages</title>
<programlisting language="c">

        if (primary [2].revents &amp; ZMQ_POLLIN) {
            char *peer = zstr_recv (statefe);
            char *status = zstr_recv (statefe);
            cloud_capacity = atoi (status);
            free (peer);
            free (status);
        }
        if (primary [3].revents &amp; ZMQ_POLLIN) {
            char *status = zstr_recv (monitor);
            printf ("%s\n", status);
            free (status);
        }
</programlisting>

</example>
<para>Now route as many clients requests as we can handle. If we have local capacity we poll both localfe and cloudfe. If we have cloud capacity only, we poll just localfe. We route any request locally if we can, else we route to the cloud. 
</para>

<example id="peering3-c-7">
<title>Full cluster simulation (peering3.c) - route client requests</title>
<programlisting language="c">
        while (local_capacity + cloud_capacity) {
            zmq_pollitem_t secondary [] = {
                { localfe, 0, ZMQ_POLLIN, 0 },
                { cloudfe, 0, ZMQ_POLLIN, 0 }
            };
            if (local_capacity)
                rc = zmq_poll (secondary, 2, 0);
            else
                rc = zmq_poll (secondary, 1, 0);
            assert (rc &gt;= 0);

            if (secondary [0].revents &amp; ZMQ_POLLIN)
                msg = zmsg_recv (localfe);
            else
            if (secondary [1].revents &amp; ZMQ_POLLIN)
                msg = zmsg_recv (cloudfe);
            else
                break;      //  No work, go back to primary

            if (local_capacity) {
                zframe_t *frame = (zframe_t *) zlist_pop (workers);
                zmsg_wrap (msg, frame);
                zmsg_send (&amp;msg, localbe);
                local_capacity--;
            }
            else {
                //  Route to random broker peer
                int random_peer = randof (argc - 2) + 2;
                zmsg_pushmem (msg, argv [random_peer], strlen (argv [random_peer]));
                zmsg_send (&amp;msg, cloudbe);
            }
        }
</programlisting>

</example>
<para>We broadcast capacity messages to other peers; to reduce chatter we do this only if our capacity changed. 
</para>

<example id="peering3-c-8">
<title>Full cluster simulation (peering3.c) - broadcast capacity</title>
<programlisting language="c">
        if (local_capacity != previous) {
            //  We stick our own address onto the envelope
            zstr_sendm (statebe, self);
            //  Broadcast new capacity
            zstr_sendf (statebe, "%d", local_capacity);
        }
    }
    //  When we're done, clean up properly
    while (zlist_size (workers)) {
        zframe_t *frame = (zframe_t *) zlist_pop (workers);
        zframe_destroy (&amp;frame);
    }
    zlist_destroy (&amp;workers);
    zctx_destroy (&amp;ctx);
    return EXIT_SUCCESS;
}
</programlisting>

</example>
<para>It's a non-trivial program and took about a day to get working. These are the highlights:</para>

<itemizedlist>
  <listitem><para>The client threads detect and report a failed request. They do this by polling for a response and if none arrives after a while (10 seconds), printing an error message.</para></listitem>
  <listitem><para>Client threads don't print directly, but instead send a message to a 'monitor' socket (PUSH) that the main loop collects (PULL) and prints off. This is the first case we've seen of using &Oslash;MQ sockets for monitoring and logging; this is a big use case we'll come back to later.</para></listitem>
  <listitem><para>Clients simulate varying loads to get the cluster 100% at random moments, so that tasks are shifted over to the cloud. The number of clients and workers, and delays in the client and worker threads control this. Feel free to play with them to see if you can make a more realistic simulation.</para></listitem>
  <listitem><para>The main loop uses two pollsets. It could in fact use three: information, backends, and frontends. As in the earlier prototype, there is no point in taking a frontend message if there is no backend capacity.</para></listitem>
</itemizedlist>
<para>These are some of the problems that hit during development of this program:</para>

<itemizedlist>
  <listitem><para>Clients would freeze, due to requests or replies getting lost somewhere. Recall that the &Oslash;MQ ROUTER/ROUTER socket drops messages it can't route. The first tactic here was to modify the client thread to detect and report such problems. Secondly, I put zmsg_dump() calls after every recv() and before every send() in the main loop, until it was clear what the problems were.</para></listitem>
  <listitem><para>The main loop was mistakenly reading from more than one ready socket. This caused the first message to be lost. Fixed that by reading only from the first ready socket.</para></listitem>
  <listitem><para>The zmsg class was not properly encoding UUIDs as C strings. This caused UUIDs that contain 0 bytes to be corrupted. Fixed by modifying zmsg to encode UUIDs as printable hex strings.</para></listitem>
</itemizedlist>
<para>This simulation does not detect disappearance of a cloud peer. If you start several peers and stop one, and it was broadcasting capacity to the others, they will continue to send it work even if it's gone. You can try this, and you will get clients that complain of lost requests. The solution is twofold: first, only keep the capacity information for a short time so that if a peer does disappear, its capacity is quickly set to 'zero'. Second, add reliability to the request-reply chain. We'll look at reliability in the next chapter.</para>

</sect2>
</sect1>
</chapter>
<chapter id="reliable-request-reply">
<title>Reliable Request-Reply Patterns</title>
<para>In Advanced Request-Reply Patterns<xref linkend="advanced-request-reply"/> we looked at advanced use of &Oslash;MQ's request-reply pattern with worked examples. In this chapter we'll look at the general question of reliability and build a set of reliable messaging patterns on top of &Oslash;MQ's core request-reply pattern.</para>

<para>In this chapter we focus heavily on user-space request-reply 'patterns', reusable models that help you design your own &Oslash;MQ architectures:</para>

<itemizedlist>
  <listitem><para>The <emphasis>Lazy Pirate</emphasis> pattern: reliable request reply from the client side.</para></listitem>
  <listitem><para>The <emphasis>Simple Pirate</emphasis> pattern: reliable request-reply using a LRU queue.</para></listitem>
  <listitem><para>The <emphasis>Paranoid Pirate</emphasis> pattern: reliable request-reply with heartbeating.</para></listitem>
  <listitem><para>The <emphasis>Majordomo</emphasis> pattern: service-oriented reliable queuing.</para></listitem>
  <listitem><para>The <emphasis>Titanic</emphasis> pattern: disk-based / disconnected reliable queuing.</para></listitem>
  <listitem><para>The <emphasis>Binary Star</emphasis> pattern: primary-backup server fail-over.</para></listitem>
  <listitem><para>The <emphasis>Freelance</emphasis> pattern: brokerless reliable request-reply.</para></listitem>
</itemizedlist>
<sect1>
<title>What is "Reliability"?</title>
<para>Most people who speak of 'reliability' don't really know what they mean. We can only define reliability in terms of failure. That is, if we can handle a certain set of well-defined and understood failures, we are reliable with respect to those failures. No more, no less. So let's look at the possible causes of failure in a distributed &Oslash;MQ application, in roughly descending order of probability:</para>

<itemizedlist>
  <listitem><para>Application code is the worst offender. It can crash and exit, freeze and stop responding to input, run too slowly for its input, exhaust all memory, etc.</para></listitem>
  <listitem><para>System code - like brokers we write using &Oslash;MQ - can die for the same reasons as application code. System code <emphasis>should</emphasis> be more reliable than application code but it can still crash and burn, and especially run out of memory if it tries to queue messages for slow clients.</para></listitem>
  <listitem><para>Message queues can overflow, typically in system code that has learned to deal brutally with slow clients. When a queue overflows, it starts to discard messages. So we get "lost" messages.</para></listitem>
  <listitem><para>Networks can fail (e.g. wifi gets switched off or goes out of range). &Oslash;MQ will automatically reconnect in such cases but in the meantime, messages may get lost.</para></listitem>
  <listitem><para>Hardware can fail and take with it all the processes running on that box.</para></listitem>
  <listitem><para>Networks can fail in exotic ways, e.g. some ports on a switch may die and those parts of the network become inaccessible.</para></listitem>
  <listitem><para>Entire data centers can be struck by lightning, earthquakes, fire, or more mundane power or cooling failures.</para></listitem>
</itemizedlist>
<para>To make a software system fully reliable against <emphasis>all</emphasis> of these possible failures is an enormously difficult and expensive job and goes beyond the scope of this modest guide.</para>

<para>Since the first five cases cover 99.9% of real world requirements outside large companies (according to a highly scientific study I just ran, which also told me that 78% of statistics are made up on the spot), that's what we'll look at. If you're a large company with money to spend on the last two cases, contact my company immediately! There's a large hole behind my beach house waiting to be converted into an executive pool.</para>

</sect1>
<sect1>
<title>Designing Reliability</title>
<para>So to make things brutally simple, reliability is "keeping things working properly when code freezes or crashes", a situation we'll shorten to "dies". However the things we want to keep working properly are more complex than just messages. We need to take each core &Oslash;MQ messaging pattern and see how to make it work (if we can) even when code dies.</para>

<para>Let's take them one by one:</para>

<itemizedlist>
  <listitem><para>Request-reply: if the server dies (while processing a request), the client can figure that out since it won't get an answer back. Then it can give up in a huff, wait and try again later, find another server, etc. As for the client dying, we can brush that off as "someone else's problem" for now.</para></listitem>
  <listitem><para>Publish-subscribe: if the client dies (having gotten some data), the server doesn't know about it. Pubsub doesn't send any information back from client to server. But the client can contact the server out-of-band, e.g. via request-reply, and ask, "please resend everything I missed". As for the server dying, that's out of scope for here. Subscribers can also self-verify that they're not running too slowly, and take action (e.g. warn the operator, and die) if they are.</para></listitem>
  <listitem><para>Pipeline: if a worker dies (while working), the ventilator doesn't know about it. Pipelines, like pubsub, and the grinding gears of time, only work in one direction. But the downstream collector can detect that one task didn't get done, and send a message back to the ventilator saying, "hey, resend task 324!" If the ventilator or collector dies, then whatever upstream client originally sent the work batch can get tired of waiting and resend the whole lot. It's not elegant but system code should really not die often enough to matter.</para></listitem>
</itemizedlist>
<para>In this chapter we'll focus on just on request-reply, which is the low-hanging Durian fruit of reliable messaging. We'll cover reliable pub-sub and pipeline in later following chapters.</para>

<para>The basic request-reply pattern (a REQ client socket doing a blocking send/recv to a REP server socket) scores low on handling the most common types of failure. If the server crashes while processing the request, the client just hangs forever. If the network loses the request or the reply, the client hangs forever.</para>

<para>It is much better than TCP, thanks to &Oslash;MQ's ability to reconnect peers silently, to load-balance messages, and so on. But it's still not good enough for real work. The only case where you can really trust the basic request-reply pattern is between two threads in the same process where there's no network or separate server process to die.</para>

<para>However, with a little extra work this humble pattern becomes a good basis for real work across a distributed network, and we get a set of reliable request-reply (RRR) patterns I like to call the "Pirate" patterns (you'll get the joke, eventually).</para>

<para>There are in my experience, roughly three ways to connect clients to servers. Each needs a specific approach to reliability:</para>

<itemizedlist>
  <listitem><para>Multiple clients talking directly to a single server. Use case: single well-known server that clients need to talk to. Types of failure we aim to handle: server crashes and restarts, network disconnects.</para></listitem>
  <listitem><para>Multiple clients talking to a single queue device that distributes work to multiple servers. Use case: workload distribution to workers. Types of failure we aim to handle: worker crashes and restarts, worker busy looping, worker overload, queue crashes and restarts, network disconnects.</para></listitem>
  <listitem><para>Multiple clients talking to multiple servers with no intermediary devices. Use case: distributed services such as name resolution. Types of failure we aim to handle: service crashes and restarts, service busy looping, service overload, network disconnects.</para></listitem>
</itemizedlist>
<para>Each of these has their trade-offs and often you'll mix them. We'll look at all three of these in detail.</para>

</sect1>
<sect1>
<title>Client-side Reliability (Lazy Pirate Pattern)</title>
<para>We can get very simple reliable request-reply with only some changes in the client. We call this the Lazy Pirate pattern(<xref linkend="figure-53"/>). Rather than doing a blocking receive, we:</para>

<itemizedlist>
  <listitem><para>Poll the REQ socket and only receive from it when it's sure a reply has arrived.</para></listitem>
  <listitem><para>Resend a request several times, if no reply arrived within a timeout period.</para></listitem>
  <listitem><para>Abandon the transaction if after several requests, there is still no reply.</para></listitem>
</itemizedlist>
<figure id="figure-53">
    <title>The Lazy Pirate Pattern</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig53.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>If you try to use a REQ socket in anything than a strict send-recv fashion, you'll get an error (technically, the REQ socket implements a small finite-state machine to enforce the send-recv ping-pong, and so the error code is called "EFSM"). This is slightly annoying when we want to use REQ in a pirate pattern, because we may send several requests before getting a reply. The pretty good brute-force solution is to close and reopen the REQ socket after an error:</para>

<example id="lpclient-c">
<title>Lazy Pirate client (lpclient.c)</title>
<programlisting language="c">
//
//  Lazy Pirate client
//  Use zmq_poll to do a safe request-reply
//  To run, start lpserver and then randomly kill/restart it
//
#include "czmq.h"

#define REQUEST_TIMEOUT     2500    //  msecs, (&gt; 1000!)
#define REQUEST_RETRIES     3       //  Before we abandon
#define SERVER_ENDPOINT     "tcp://localhost:5555"

int main (void)
{
    zctx_t *ctx = zctx_new ();
    printf ("I: connecting to server...\n");
    void *client = zsocket_new (ctx, ZMQ_REQ);
    assert (client);
    zsocket_connect (client, SERVER_ENDPOINT);

    int sequence = 0;
    int retries_left = REQUEST_RETRIES;
    while (retries_left &amp;&amp; !zctx_interrupted) {
        //  We send a request, then we work to get a reply
        char request [10];
        sprintf (request, "%d", ++sequence);
        zstr_send (client, request);

        int expect_reply = 1;
        while (expect_reply) {
            //  Poll socket for a reply, with timeout
            zmq_pollitem_t items [] = { { client, 0, ZMQ_POLLIN, 0 } };
            int rc = zmq_poll (items, 1, REQUEST_TIMEOUT * ZMQ_POLL_MSEC);
            if (rc == -1)
                break;          //  Interrupted
</programlisting>

</example>
<para>Here we process a server reply and exit our loop if the reply is valid. If we didn't a reply we close the client socket and resend the request. We try a number of times before finally abandoning: 
</para>

<example id="lpclient-c-1">
<title>Lazy Pirate client (lpclient.c) - process server reply</title>
<programlisting language="c">

            if (items [0].revents &amp; ZMQ_POLLIN) {
                //  We got a reply from the server, must match sequence
                char *reply = zstr_recv (client);
                if (!reply)
                    break;      //  Interrupted
                if (atoi (reply) == sequence) {
                    printf ("I: server replied OK (%s)\n", reply);
                    retries_left = REQUEST_RETRIES;
                    expect_reply = 0;
                }
                else
                    printf ("E: malformed reply from server: %s\n",
                        reply);

                free (reply);
            }
            else
            if (--retries_left == 0) {
                printf ("E: server seems to be offline, abandoning\n");
                break;
            }
            else {
                printf ("W: no response from server, retrying...\n");
                //  Old socket is confused; close it and open a new one
                zsocket_destroy (ctx, client);
                printf ("I: reconnecting to server...\n");
                client = zsocket_new (ctx, ZMQ_REQ);
                zsocket_connect (client, SERVER_ENDPOINT);
                //  Send request again, on new socket
                zstr_send (client, request);
            }
        }
    }
    zctx_destroy (&amp;ctx);
    return 0;
}
</programlisting>

</example>
<para>Run this together with the matching server:</para>

<example id="lpserver-c">
<title>Lazy Pirate server (lpserver.c)</title>
<programlisting language="c">
//
//  Lazy Pirate server
//  Binds REQ socket to tcp://*:5555
//  Like hwserver except:
//   - echoes request as-is
//   - randomly runs slowly, or exits to simulate a crash.
//
#include "zhelpers.h"

int main (void)
{
    srandom ((unsigned) time (NULL));

    void *context = zmq_ctx_new ();
    void *server = zmq_socket (context, ZMQ_REP);
    zmq_bind (server, "tcp://*:5555");

    int cycles = 0;
    while (true) {
        char *request = s_recv (server);
        cycles++;

        //  Simulate various problems, after a few cycles
        if (cycles &gt; 3 &amp;&amp; randof (3) == 0) {
            printf ("I: simulating a crash\n");
            break;
        }
        else
        if (cycles &gt; 3 &amp;&amp; randof (3) == 0) {
            printf ("I: simulating CPU overload\n");
            sleep (2);
        }
        printf ("I: normal request (%s)\n", request);
        sleep (1);              //  Do some heavy work
        s_send (server, request);
        free (request);
    }
    zmq_close (server);
    zmq_ctx_destroy (context);
    return 0;
}
</programlisting>

</example>
<para>To run this testcase, start the client and the server in two console windows. The server will randomly misbehave after a few messages. You can check the client's response. Here is a typical output from the server:</para>

<screen>I: normal request (1)
I: normal request (2)
I: normal request (3)
I: simulating CPU overload
I: normal request (4)
I: simulating a crash
</screen>

<para>And here is the client's response:</para>

<screen>I: connecting to server...
I: server replied OK (1)
I: server replied OK (2)
I: server replied OK (3)
W: no response from server, retrying...
I: connecting to server...
W: no response from server, retrying...
I: connecting to server...
E: server seems to be offline, abandoning
</screen>

<para>The client sequences each message, and checks that replies come back exactly in order: that no requests or replies are lost, and no replies come back more than once, or out of order. Run the test a few times until you're convinced this mechanism actually works. You don't need sequence numbers in reality, they just help us trust our design.</para>

<para>The client uses a REQ socket, and does the brute-force close/reopen because REQ sockets impose that strict send/receive cycle. You might be tempted to use a DEALER instead, but it would not be a good decision. First, it would mean emulating the secret sauce that REQ does with envelopes (if you've forgotten what that is, it's a good sign you don't want to have to do it). Second, it would mean potentially getting back replies that you didn't expect.</para>

<para>Handling failures only at the client works when we have a set of clients talking to a single server. It can handle a server crash, but only if recovery means restarting that same server. If there's a permanent error - e.g. a dead power supply on the server hardware - this approach won't work. Since the application code in servers is usually the biggest source of failures in any architecture, depending on a single server is not a great idea.</para>

<para>So, pros and cons:</para>

<itemizedlist>
  <listitem><para>Pro: simple to understand and implement.</para></listitem>
  <listitem><para>Pro: works easily with existing client and server application code.</para></listitem>
  <listitem><para>Pro: &Oslash;MQ automatically retries the actual reconnection until it works.</para></listitem>
  <listitem><para>Con: doesn't do fail-over to backup / alternate servers.</para></listitem>
</itemizedlist>
</sect1>
<sect1>
<title>Basic Reliable Queuing (Simple Pirate Pattern)</title>
<para>Our second approach takes Lazy Pirate pattern and extends it with a queue device that lets us talk, transparently, to multiple servers, which we can more accurately call 'workers'. We'll develop this in stages, starting with a minimal working model, the Simple Pirate pattern.</para>

<para>In all these Pirate patterns, workers are stateless, or have some shared state we don't know about, e.g. a shared database. Having a queue device means workers can come and go without clients knowing anything about it. If one worker dies, another takes over. This is a nice simple topology with only one real weakness, namely the central queue itself, which can become a problem to manage, and a single point of failure.</para>

<para>The basis for the queue device is the least-recently-used (LRU) routing queue from Advanced Request-Reply Patterns<xref linkend="advanced-request-reply"/>. What is the very <emphasis>minimum</emphasis> we need to do to handle dead or blocked workers? Turns out, it's surprisingly little. We already have a retry mechanism in the client. So using the standard LRU queue will work pretty well. This fits with &Oslash;MQ's philosophy that we can extend a peer-to-peer pattern like request-reply by plugging naive devices in the middle(<xref linkend="figure-54"/>).</para>

<figure id="figure-54">
    <title>The Simple Pirate Pattern</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig54.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>We don't need a special client, we're still using the Lazy Pirate client. Here is the queue, which is exactly a LRU queue, no more or less:</para>

<example id="spqueue-c">
<title>Simple Pirate queue (spqueue.c)</title>
<programlisting language="c">
//
//  Simple Pirate queue
//  This is identical to the LRU pattern, with no reliability mechanisms
//  at all. It depends on the client for recovery. Runs forever.
//
#include "czmq.h"

#define LRU_READY   "\001"      //  Signals worker is ready

int main (void)
{
    zctx_t *ctx = zctx_new ();
    void *frontend = zsocket_new (ctx, ZMQ_ROUTER);
    void *backend = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (frontend, "tcp://*:5555");    //  For clients
    zsocket_bind (backend,  "tcp://*:5556");    //  For workers

    //  Queue of available workers
    zlist_t *workers = zlist_new ();
    
    //  The body of this example is exactly the same as lruqueue2.
...
}
</programlisting>

</example>
<para>Here is the worker, which takes the Lazy Pirate server and adapts it for the LRU pattern (using the REQ 'ready' signaling):</para>

<example id="spworker-c">
<title>Simple Pirate worker (spworker.c)</title>
<programlisting language="c">
//
//  Simple Pirate worker
//  Connects REQ socket to tcp://*:5556
//  Implements worker part of LRU queueing
//
#include "czmq.h"
#define LRU_READY   "\001"      //  Signals worker is ready

int main (void)
{
    zctx_t *ctx = zctx_new ();
    void *worker = zsocket_new (ctx, ZMQ_REQ);

    //  Set random identity to make tracing easier
    srandom ((unsigned) time (NULL));
    char identity [10];
    sprintf (identity, "%04X-%04X", randof (0x10000), randof (0x10000));
    zmq_setsockopt (worker, ZMQ_IDENTITY, identity, strlen (identity));
    zsocket_connect (worker, "tcp://localhost:5556");

    //  Tell broker we're ready for work
    printf ("I: (%s) worker ready\n", identity);
    zframe_t *frame = zframe_new (LRU_READY, 1);
    zframe_send (&amp;frame, worker, 0);

    int cycles = 0;
    while (true) {
        zmsg_t *msg = zmsg_recv (worker);
        if (!msg)
            break;              //  Interrupted

        //  Simulate various problems, after a few cycles
        cycles++;
        if (cycles &gt; 3 &amp;&amp; randof (5) == 0) {
            printf ("I: (%s) simulating a crash\n", identity);
            zmsg_destroy (&amp;msg);
            break;
        }
        else
        if (cycles &gt; 3 &amp;&amp; randof (5) == 0) {
            printf ("I: (%s) simulating CPU overload\n", identity);
            sleep (3);
            if (zctx_interrupted)
                break;
        }
        printf ("I: (%s) normal reply\n", identity);
        sleep (1);              //  Do some heavy work
        zmsg_send (&amp;msg, worker);
    }
    zctx_destroy (&amp;ctx);
    return 0;
}
</programlisting>

</example>
<para>To test this, start a handful of workers, a client, and the queue, in any order. You'll see that the workers eventually all crash and burn, and the client retries and then gives up. The queue never stops, and you can restart workers and clients ad-nauseam. This model works with any number of clients and workers.</para>

</sect1>
<sect1>
<title>Robust Reliable Queuing (Paranoid Pirate Pattern)</title>
<para>The Simple Pirate Queue pattern works pretty well, especially since it's just a combination of two existing patterns, but it has some weaknesses:</para>

<itemizedlist>
  <listitem><para>It's not robust against a queue crash and restart. The client will recover, but the workers won't. While &Oslash;MQ will reconnect workers' sockets automatically, as far as the newly started queue is concerned, the workers haven't signaled "READY", so don't exist. To fix this we have to do heartbeating from queue to worker, so that the worker can detect when the queue has gone away.</para></listitem>
  <listitem><para>The queue does not detect worker failure, so if a worker dies while idle, the queue can only remove it from its worker queue by first sending it a request. The client waits and retries for nothing. It's not a critical problem but it's not nice. To make this work properly we do heartbeating from worker to queue, so that the queue can detect a lost worker at any stage.</para></listitem>
</itemizedlist>
<para>We'll fix these in a properly pedantic Paranoid Pirate Pattern.</para>

<para>We previously used a REQ socket for the worker. For the Paranoid Pirate worker we'll switch to a DEALER socket(<xref linkend="figure-55"/>). This has the advantage of letting us send and receive messages at any time, rather than the lock-step send/receive that REQ imposes. The downside of DEALER is that we have to do our own envelope management. If you don't know what I mean, please re-read Advanced Request-Reply Patterns<xref linkend="advanced-request-reply"/>.</para>

<figure id="figure-55">
    <title>The Paranoid Pirate Pattern</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig55.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>We're still using the Lazy Pirate client. Here is the Paranoid Pirate queue device:</para>

<example id="ppqueue-c">
<title>Paranoid Pirate queue (ppqueue.c)</title>
<programlisting language="c">
//
//  Paranoid Pirate queue
//
#include "czmq.h"

#define HEARTBEAT_LIVENESS  3       //  3-5 is reasonable
#define HEARTBEAT_INTERVAL  1000    //  msecs

//  Paranoid Pirate Protocol constants
#define PPP_READY       "\001"      //  Signals worker is ready
#define PPP_HEARTBEAT   "\002"      //  Signals worker heartbeat
</programlisting>

</example>
<para>Here we define the worker class; a structure and a set of functions that as constructor, destructor, and methods on worker objects: 
</para>

<example id="ppqueue-c-1">
<title>Paranoid Pirate queue (ppqueue.c) - worker class structure</title>
<programlisting language="c">

typedef struct {
    zframe_t *address;          //  Address of worker
    char *identity;             //  Printable identity
    int64_t expiry;             //  Expires at this time
} worker_t;

//  Construct new worker
static worker_t *
s_worker_new (zframe_t *address)
{
    worker_t *self = (worker_t *) zmalloc (sizeof (worker_t));
    self-&gt;address = address;
    self-&gt;identity = zframe_strdup (address);
    self-&gt;expiry = zclock_time () + HEARTBEAT_INTERVAL * HEARTBEAT_LIVENESS;
    return self;
}

//  Destroy specified worker object, including identity frame.
static void
s_worker_destroy (worker_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        worker_t *self = *self_p;
        zframe_destroy (&amp;self-&gt;address);
        free (self-&gt;identity);
        free (self);
        *self_p = NULL;
    }
}
</programlisting>

</example>
<para>The ready method puts a worker to the end of the ready list: 
</para>

<example id="ppqueue-c-2">
<title>Paranoid Pirate queue (ppqueue.c) - worker ready method</title>
<programlisting language="c">

static void
s_worker_ready (worker_t *self, zlist_t *workers)
{
    worker_t *worker = (worker_t *) zlist_first (workers);
    while (worker) {
        if (streq (self-&gt;identity, worker-&gt;identity)) {
            zlist_remove (workers, worker);
            s_worker_destroy (&amp;worker);
            break;
        }
        worker = (worker_t *) zlist_next (workers);
    }
    zlist_append (workers, self);
}
</programlisting>

</example>
<para>The next method returns the next available worker address: 
</para>

<example id="ppqueue-c-3">
<title>Paranoid Pirate queue (ppqueue.c) - get next available worker</title>
<programlisting language="c">

static zframe_t *
s_workers_next (zlist_t *workers)
{
    worker_t *worker = zlist_pop (workers);
    assert (worker);
    zframe_t *frame = worker-&gt;address;
    worker-&gt;address = NULL;
    s_worker_destroy (&amp;worker);
    return frame;
}
</programlisting>

</example>
<para>The purge method looks for and kills expired workers. We hold workers from oldest to most recent, so we stop at the first alive worker: 
</para>

<example id="ppqueue-c-4">
<title>Paranoid Pirate queue (ppqueue.c) - purge expired workers</title>
<programlisting language="c">

static void
s_workers_purge (zlist_t *workers)
{
    worker_t *worker = (worker_t *) zlist_first (workers);
    while (worker) {
        if (zclock_time () &lt; worker-&gt;expiry)
            break;              //  Worker is alive, we're done here

        zlist_remove (workers, worker);
        s_worker_destroy (&amp;worker);
        worker = (worker_t *) zlist_first (workers);
    }
}
</programlisting>

</example>
<para>The main task is an LRU queue with heartbeating on workers so we can detect crashed or blocked worker tasks: 
</para>

<example id="ppqueue-c-5">
<title>Paranoid Pirate queue (ppqueue.c) - main task</title>
<programlisting language="c">

int main (void)
{
    zctx_t *ctx = zctx_new ();
    void *frontend = zsocket_new (ctx, ZMQ_ROUTER);
    void *backend = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (frontend, "tcp://*:5555");    //  For clients
    zsocket_bind (backend,  "tcp://*:5556");    //  For workers

    //  List of available workers
    zlist_t *workers = zlist_new ();

    //  Send out heartbeats at regular intervals
    uint64_t heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;

    while (true) {
        zmq_pollitem_t items [] = {
            { backend,  0, ZMQ_POLLIN, 0 },
            { frontend, 0, ZMQ_POLLIN, 0 }
        };
        //  Poll frontend only if we have available workers
        int rc = zmq_poll (items, zlist_size (workers)? 2: 1,
            HEARTBEAT_INTERVAL * ZMQ_POLL_MSEC);
        if (rc == -1)
            break;              //  Interrupted

        //  Handle worker activity on backend
        if (items [0].revents &amp; ZMQ_POLLIN) {
            //  Use worker address for LRU routing
            zmsg_t *msg = zmsg_recv (backend);
            if (!msg)
                break;          //  Interrupted

            //  Any sign of life from worker means it's ready
            zframe_t *address = zmsg_unwrap (msg);
            worker_t *worker = s_worker_new (address);
            s_worker_ready (worker, workers);

            //  Validate control message, or return reply to client
            if (zmsg_size (msg) == 1) {
                zframe_t *frame = zmsg_first (msg);
                if (memcmp (zframe_data (frame), PPP_READY, 1)
                &amp;&amp;  memcmp (zframe_data (frame), PPP_HEARTBEAT, 1)) {
                    printf ("E: invalid message from worker");
                    zmsg_dump (msg);
                }
                zmsg_destroy (&amp;msg);
            }
            else
                zmsg_send (&amp;msg, frontend);
        }
        if (items [1].revents &amp; ZMQ_POLLIN) {
            //  Now get next client request, route to next worker
            zmsg_t *msg = zmsg_recv (frontend);
            if (!msg)
                break;          //  Interrupted
            zmsg_push (msg, s_workers_next (workers));
            zmsg_send (&amp;msg, backend);
        }
</programlisting>

</example>
<para>We handle heartbeating after any socket activity. First we send heartbeats to any idle workers if it's time. Then we purge any dead workers: 
</para>

<example id="ppqueue-c-6">
<title>Paranoid Pirate queue (ppqueue.c) - handle heartbeating</title>
<programlisting language="c">

        if (zclock_time () &gt;= heartbeat_at) {
            worker_t *worker = (worker_t *) zlist_first (workers);
            while (worker) {
                zframe_send (&amp;worker-&gt;address, backend,
                             ZFRAME_REUSE + ZFRAME_MORE);
                zframe_t *frame = zframe_new (PPP_HEARTBEAT, 1);
                zframe_send (&amp;frame, backend, 0);
                worker = (worker_t *) zlist_next (workers);
            }
            heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;
        }
        s_workers_purge (workers);
    }

    //  When we're done, clean up properly
    while (zlist_size (workers)) {
        worker_t *worker = (worker_t *) zlist_pop (workers);
        s_worker_destroy (&amp;worker);
    }
    zlist_destroy (&amp;workers);
    zctx_destroy (&amp;ctx);
    return 0;
}
</programlisting>

</example>
<para>The queue extends the LRU pattern with heartbeating of workers. Heartbeating is one of those 'simple' things that can be subtle to get right. I'll explain more about that in a second.</para>

<para>Here is the Paranoid Pirate worker:</para>

<example id="ppworker-c">
<title>Paranoid Pirate worker (ppworker.c)</title>
<programlisting language="c">
//
//  Paranoid Pirate worker
//
#include "czmq.h"

#define HEARTBEAT_LIVENESS  3       //  3-5 is reasonable
#define HEARTBEAT_INTERVAL  1000    //  msecs
#define INTERVAL_INIT       1000    //  Initial reconnect
#define INTERVAL_MAX       32000    //  After exponential backoff

//  Paranoid Pirate Protocol constants
#define PPP_READY       "\001"      //  Signals worker is ready
#define PPP_HEARTBEAT   "\002"      //  Signals worker heartbeat

//  Helper function that returns a new configured socket
//  connected to the Paranoid Pirate queue

static void *
s_worker_socket (zctx_t *ctx) {
    void *worker = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_connect (worker, "tcp://localhost:5556");

    //  Tell queue we're ready for work
    printf ("I: worker ready\n");
    zframe_t *frame = zframe_new (PPP_READY, 1);
    zframe_send (&amp;frame, worker, 0);

    return worker;
}
</programlisting>

</example>
<para>We have a single task, which implements the worker side of the Paranoid Pirate Protocol (PPP). The interesting parts here are the heartbeating, which lets the worker detect if the queue has died, and vice-versa: 
</para>

<example id="ppworker-c-1">
<title>Paranoid Pirate worker (ppworker.c) - main task</title>
<programlisting language="c">

int main (void)
{
    zctx_t *ctx = zctx_new ();
    void *worker = s_worker_socket (ctx);

    //  If liveness hits zero, queue is considered disconnected
    size_t liveness = HEARTBEAT_LIVENESS;
    size_t interval = INTERVAL_INIT;

    //  Send out heartbeats at regular intervals
    uint64_t heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;

    srandom ((unsigned) time (NULL));
    int cycles = 0;
    while (true) {
        zmq_pollitem_t items [] = { { worker,  0, ZMQ_POLLIN, 0 } };
        int rc = zmq_poll (items, 1, HEARTBEAT_INTERVAL * ZMQ_POLL_MSEC);
        if (rc == -1)
            break;              //  Interrupted

        if (items [0].revents &amp; ZMQ_POLLIN) {
            //  Get message
            //  - 3-part envelope + content -&gt; request
            //  - 1-part HEARTBEAT -&gt; heartbeat
            zmsg_t *msg = zmsg_recv (worker);
            if (!msg)
                break;          //  Interrupted
</programlisting>

</example>
<para>To test the robustness of the queue implementation we simulate various typical problems, such as the worker crashing, or running very slowly. We do this after a few cycles so that the architecture can get up and running first: 
</para>

<example id="ppworker-c-2">
<title>Paranoid Pirate worker (ppworker.c) - simulating problems</title>
<programlisting language="c">

                cycles++;
                if (cycles &gt; 3 &amp;&amp; randof (5) == 0) {
                    printf ("I: simulating a crash\n");
                    zmsg_destroy (&amp;msg);
                    break;
                }
                else
                if (cycles &gt; 3 &amp;&amp; randof (5) == 0) {
                    printf ("I: simulating CPU overload\n");
                    sleep (3);
                    if (zctx_interrupted)
                        break;
                }
                printf ("I: normal reply\n");
                zmsg_send (&amp;msg, worker);
                liveness = HEARTBEAT_LIVENESS;
                sleep (1);              //  Do some heavy work
                if (zctx_interrupted)
                    break;
            }
            else
</programlisting>

</example>
<para>When we get a heartbeat message from the queue, it means the queue was (recently) alive, so reset our liveness indicator: 
</para>

<example id="ppworker-c-3">
<title>Paranoid Pirate worker (ppworker.c) - handle heartbeats</title>
<programlisting language="c">
                zframe_t *frame = zmsg_first (msg);
                if (memcmp (zframe_data (frame), PPP_HEARTBEAT, 1) == 0)
                    liveness = HEARTBEAT_LIVENESS;
                else {
                    printf ("E: invalid message\n");
                    zmsg_dump (msg);
                }
                zmsg_destroy (&amp;msg);
            }
            else {
                printf ("E: invalid message\n");
                zmsg_dump (msg);
            }
            interval = INTERVAL_INIT;
        }
        else
</programlisting>

</example>
<para>If the queue hasn't sent us heartbeats in a while, destroy the socket and reconnect. This is the simplest most brutal way of discarding any messages we might have sent in the meantime: 
</para>

<example id="ppworker-c-4">
<title>Paranoid Pirate worker (ppworker.c) - detecting a dead queue</title>
<programlisting language="c">
            printf ("W: heartbeat failure, can't reach queue\n");
            printf ("W: reconnecting in %zd msec...\n", interval);
            zclock_sleep (interval);

            if (interval &lt; INTERVAL_MAX)
                interval *= 2;
            zsocket_destroy (ctx, worker);
            worker = s_worker_socket (ctx);
            liveness = HEARTBEAT_LIVENESS;
        }

        //  Send heartbeat to queue if it's time
        if (zclock_time () &gt; heartbeat_at) {
            heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;
            printf ("I: worker heartbeat\n");
            zframe_t *frame = zframe_new (PPP_HEARTBEAT, 1);
            zframe_send (&amp;frame, worker, 0);
        }
    }
    zctx_destroy (&amp;ctx);
    return 0;
}
</programlisting>

</example>
<para>Some comments about this example:</para>

<itemizedlist>
  <listitem><para>The code includes simulation of failures, as before. This makes it (a) very hard to debug, and (b) dangerous to reuse. When you want to debug this, disable the failure simulation.</para></listitem>
  <listitem><para>The worker uses a reconnect strategy similar to the one we designed for the Lazy Pirate client. With two major differences: (a) it does an exponential back-off, and (b) it never abandons.</para></listitem>
</itemizedlist>
<para>Try the client, queue, and workers, e.g. using a script like this:</para>

<screen>ppqueue &amp;
for i in 1 2 3 4; do
    ppworker &amp;
    sleep 1
done
lpclient &amp;
</screen>

<para>You should see the workers die, one by one, as they simulate a crash, and the client eventually give up. You can stop and restart the queue and both client and workers will reconnect and carry on. And no matter what you do to queues and workers, the client will never get an out-of-order reply: the whole chain either works, or the client abandons.</para>

</sect1>
<sect1>
<title>Heartbeating</title>
<para>When writing the Paranoid Pirate examples, it took about five hours to get the queue-to-worker heartbeating working properly. The rest of the request-reply chain took perhaps ten minutes. Heartbeating is one of those reliability layers that often causes more trouble than it saves. It is especially easy to create 'false failures', i.e. peers decide that they are disconnected because the heartbeats aren't sent properly.</para>

<para>Some points to consider when understanding and implementing heartbeating:</para>

<itemizedlist>
  <listitem><para>Note that heartbeats are not request-reply. They flow asynchronously in both directions. Either peer can decide the other is 'dead' and stop talking to it.</para></listitem>
  <listitem><para>First, get the heartbeating working, and only <emphasis>then</emphasis> add in the rest of the message flow. You should be able to prove the heartbeating works by starting peers in any order, stopping and restarting them, simulating freezes, and so on.</para></listitem>
  <listitem><para>When your main loop is based on <literal>zmq_poll()</literal>, use a secondary timer to trigger heartbeats. Do <emphasis>not</emphasis> use the poll loop for this, because you'll enter the loop every time you receive any message (fun, when you have two peers sending each other heartbeats) (think about it).</para></listitem>
</itemizedlist>
<para>Your language or binding should provide a method that returns the current system clock in milliseconds. It's easy to use this to calculate when to send the next heartbeats. Thus, in C:</para>

<programlisting language="c">
//  Send out heartbeats at regular intervals
uint64_t heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;

while (true) {
    ...
    int rc = zmq_poll (items, 1, HEARTBEAT_INTERVAL * ZMQ_POLL_MSEC);
    ...
    //  Send heartbeat to queue if it's time
    if (zclock_time () &gt; heartbeat_at) {
        ... Send heartbeats to all peers that expect them
        //  Set timer for next heartbeat
        heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;
    }
}
</programlisting>

<itemizedlist>
  <listitem><para>Your main poll loop should use the heartbeat interval as its timeout. Obviously, don't use infinity. Anything less will just waste cycles.</para></listitem>
  <listitem><para>Use simple tracing, i.e. print to console, to get this working. Some tricks to help you trace the flow of messages between peers: a dump method such as zmsg offers; number messages incrementally so you can see if there are gaps.</para></listitem>
  <listitem><para>In a real application, heartbeating must be configurable and usually negotiated with the peer. Some peers will want aggressive heartbeating, as low as 10 msecs. Other peers will be far away and want heartbeating as high as 30 seconds.</para></listitem>
  <listitem><para>If you have different heartbeat intervals for different peers, your poll timeout should be the lowest (shortest time) of these.</para></listitem>
  <listitem><para>You might be tempted to open a separate socket dialog for heartbeats. This is superficially nice because you can separate different dialogs, e.g. the synchronous request-reply from the asynchronous heartbeating. However it's a bad idea for several reasons. First, if you're sending data you don't need to send heartbeats. Second, sockets may, due to network vagaries, become jammed. You need to know when your main data socket is silent because it's dead, rather than just not busy, so you need heartbeats on that socket. Lastly, two sockets is more complex than one.</para></listitem>
  <listitem><para>We're not doing heartbeating from client to queue. It does make things more complex, but we do that in real applications so that clients can detect when brokers die, and do clever things like switch to alternate brokers.</para></listitem>
</itemizedlist>
</sect1>
<sect1>
<title>Contracts and Protocols</title>
<para>If you're paying attention you'll realize that Paranoid Pirate is not interoperable with Simple Pirate, because of the heartbeats. But how do we define "interoperable"? To guarantee interoperability we need a kind of contract, an agreement that lets different teams, in different times and places, write code that is guaranteed to work together. We call this a "protocol".</para>

<para>It's fun to experiment without specifications, but that's not a sensible basis for real applications. What happens if we want to write a worker in another language? Do we have to read code to see how things work? What if we want to change the protocol for some reason? The protocol may be simple but it's not obvious, and if it's successful it'll become more complex.</para>

<para>Lack of contracts is a sure sign of a disposable application. So, let's write a contract for this protocol. How do we do that?</para>

<itemizedlist>
  <listitem><para>There's a wiki, at <ulink url="http://rfc.zeromq.org">rfc.zeromq.org</ulink>, that we made especially as a home for public &Oslash;MQ contracts.</para></listitem>
  <listitem><para>To create a new specification, register, and follow the instructions. It's straight-forward, though technical writing is not for everyone.</para></listitem>
</itemizedlist>
<para>It took me about fifteen minutes to draft the new <ulink url="http://rfc.zeromq.org/spec:6">Pirate Pattern Protocol</ulink>. It's not a big specification but it does capture enough to act as the basis for arguments ("your queue isn't PPP compatible, please fix it!").</para>

<para>Turning PPP into a real protocol would take more work:</para>

<itemizedlist>
  <listitem><para>There should be a protocol version number in the READY command so that it's possible to create new versions of PPP safely.</para></listitem>
  <listitem><para>Right now, READY and HEARTBEAT are not entirely distinct from requests and replies. To make them distinct, we would want a message structure that includes a "message type" part.</para></listitem>
</itemizedlist>
</sect1>
<sect1>
<title>Service-Oriented Reliable Queuing (Majordomo Pattern)</title>
<para>The nice thing about progress is how fast it happens when lawyers and committees aren't involved. Just a few sentences ago we were dreaming of a better protocol that would fix the world. And here we have it:</para>

<itemizedlist>
  <listitem><para>http://rfc.zeromq.org/spec:7</para></listitem>
</itemizedlist>
<para>This one-page specification takes PPP and turns it into something more solid(<xref linkend="figure-56"/>). This is how we should design complex architectures: start by writing down the contracts, and only <emphasis>then</emphasis> write software to implement them.</para>

<para>The Majordomo Protocol (MDP) extends and improves PPP in one interesting way apart from the two points above. It adds a "service name" to requests that the client sends, and asks workers to register for specific services. The nice thing about MDP is that it came from working code, a simpler protocol, and a precise set of improvements. This made it easy to draft.</para>

<para>Adding service names is a small but significant change that turns our Paranoid Pirate queue into a service-oriented broker.</para>

<figure id="figure-56">
    <title>The Majordomo Pattern</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig56.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>To implement Majordomo we need to write a framework for clients and workers. It's really not sane to ask every application developer to read the spec and make it work, when they could be using a simpler API built and tested just once.</para>

<para>So, while our first contract (MDP itself) defines how the pieces of our distributed architecture talk to each other, our second contract defines how user applications talk to the technical framework we're going to design.</para>

<para>Majordomo has two halves, a client side and a worker side. Since we'll write both client and worker applications, we will need two APIs. Here is a sketch for the client API, using a simple object-oriented approach:</para>

<programlisting language="c">
mdcli_t *mdcli_new     (char *broker);
void     mdcli_destroy (mdcli_t **self_p);
zmsg_t  *mdcli_send    (mdcli_t *self, char *service, zmsg_t **request_p);
</programlisting>

<para>That's it. We open a session to the broker, we send a request message and get a reply message back, and we eventually close the connection. Here's a sketch for the worker API:</para>

<programlisting language="c">
mdwrk_t *mdwrk_new     (char *broker,char *service);
void     mdwrk_destroy (mdwrk_t **self_p);
zmsg_t  *mdwrk_recv    (mdwrk_t *self, zmsg_t *reply);
</programlisting>

<para>It's more or less symmetrical but the worker dialog is a little different. The first time a worker does a recv(), it passes a null reply, thereafter it passes the current reply, and gets a new request.</para>

<para>The client and worker APIs were fairly simple to construct, since they're heavily based on the Paranoid Pirate code we already developed. Here is the client API:</para>

<example id="mdcliapi-c">
<title>Majordomo client API (mdcliapi.c)</title>
<programlisting language="c">
/*  =====================================================================
 *  mdcliapi.c - Majordomo Protocol Client API
 *  Implements the MDP/Worker spec at http://rfc.zeromq.org/spec:7.
 *  ===================================================================== */

#include "mdcliapi.h"

//  Structure of our class
//  We access these properties only via class methods

struct _mdcli_t {
    zctx_t *ctx;                //  Our context
    char *broker;
    void *client;               //  Socket to broker
    int verbose;                //  Print activity to stdout
    int timeout;                //  Request timeout
    int retries;                //  Request retries
};


//  ---------------------------------------------------------------------
//  Connect or reconnect to broker

void s_mdcli_connect_to_broker (mdcli_t *self)
{
    if (self-&gt;client)
        zsocket_destroy (self-&gt;ctx, self-&gt;client);
    self-&gt;client = zsocket_new (self-&gt;ctx, ZMQ_REQ);
    zmq_connect (self-&gt;client, self-&gt;broker);
    if (self-&gt;verbose)
        zclock_log ("I: connecting to broker at %s...", self-&gt;broker);
}
</programlisting>

</example>
<para>Here we have the constructor and destructor for our mdcli class: 
</para>

<example id="mdcliapi-c-1">
<title>Majordomo client API (mdcliapi.c) - constructor and destructor</title>
<programlisting language="c">


//  ---------------------------------------------------------------------
//  Constructor

mdcli_t *
mdcli_new (char *broker, int verbose)
{
    assert (broker);

    mdcli_t *self = (mdcli_t *) zmalloc (sizeof (mdcli_t));
    self-&gt;ctx = zctx_new ();
    self-&gt;broker = strdup (broker);
    self-&gt;verbose = verbose;
    self-&gt;timeout = 2500;           //  msecs
    self-&gt;retries = 3;              //  Before we abandon

    s_mdcli_connect_to_broker (self);
    return self;
}


//  ---------------------------------------------------------------------
//  Destructor

void
mdcli_destroy (mdcli_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        mdcli_t *self = *self_p;
        zctx_destroy (&amp;self-&gt;ctx);
        free (self-&gt;broker);
        free (self);
        *self_p = NULL;
    }
}
</programlisting>

</example>
<para>These are the class methods. We can set the request timeout and number of retry attempts, before sending requests: 
</para>

<example id="mdcliapi-c-2">
<title>Majordomo client API (mdcliapi.c) - configure retry behavior</title>
<programlisting language="c">


//  ---------------------------------------------------------------------
//  Set request timeout

void
mdcli_set_timeout (mdcli_t *self, int timeout)
{
    assert (self);
    self-&gt;timeout = timeout;
}


//  ---------------------------------------------------------------------
//  Set request retries

void
mdcli_set_retries (mdcli_t *self, int retries)
{
    assert (self);
    self-&gt;retries = retries;
}
</programlisting>

</example>
<para>Here is the send method. It sends a request to the broker and gets a reply even if it has to retry several times. It takes ownership of the request message, and destroys it when sent. It returns the reply message, or NULL if there was no reply after multiple attempts: 
</para>

<example id="mdcliapi-c-3">
<title>Majordomo client API (mdcliapi.c) - send request and wait for reply</title>
<programlisting language="c">


zmsg_t *
mdcli_send (mdcli_t *self, char *service, zmsg_t **request_p)
{
    assert (self);
    assert (request_p);
    zmsg_t *request = *request_p;

    //  Prefix request with protocol frames
    //  Frame 1: "MDPCxy" (six bytes, MDP/Client x.y)
    //  Frame 2: Service name (printable string)
    zmsg_pushstr (request, service);
    zmsg_pushstr (request, MDPC_CLIENT);
    if (self-&gt;verbose) {
        zclock_log ("I: send request to '%s' service:", service);
        zmsg_dump (request);
    }
    int retries_left = self-&gt;retries;
    while (retries_left &amp;&amp; !zctx_interrupted) {
        zmsg_t *msg = zmsg_dup (request);
        zmsg_send (&amp;msg, self-&gt;client);

        zmq_pollitem_t items [] = {
            { self-&gt;client, 0, ZMQ_POLLIN, 0 }
        };
</programlisting>

</example>
<para>On any blocking call, libzmq will return -1 if there was an error; we could in theory check for different error codes but in practice it's OK to assume it was EINTR (Ctrl-C): 
</para>

<example id="mdcliapi-c-4">
<title>Majordomo client API (mdcliapi.c) - body of send </title>
<programlisting language="c">
        int rc = zmq_poll (items, 1, self-&gt;timeout * ZMQ_POLL_MSEC);
        if (rc == -1)
            break;          //  Interrupted

        //  If we got a reply, process it
        if (items [0].revents &amp; ZMQ_POLLIN) {
            zmsg_t *msg = zmsg_recv (self-&gt;client);
            if (self-&gt;verbose) {
                zclock_log ("I: received reply:");
                zmsg_dump (msg);
            }
            //  We would handle malformed replies better in real code
            assert (zmsg_size (msg) &gt;= 3);

            zframe_t *header = zmsg_pop (msg);
            assert (zframe_streq (header, MDPC_CLIENT));
            zframe_destroy (&amp;header);

            zframe_t *reply_service = zmsg_pop (msg);
            assert (zframe_streq (reply_service, service));
            zframe_destroy (&amp;reply_service);

            zmsg_destroy (&amp;request);
            return msg;     //  Success
        }
        else
        if (--retries_left) {
            if (self-&gt;verbose)
                zclock_log ("W: no reply, reconnecting...");
            s_mdcli_connect_to_broker (self);
        }
        else {
            if (self-&gt;verbose)
                zclock_log ("W: permanent error, abandoning");
            break;          //  Give up
        }
    }
    if (zctx_interrupted)
        printf ("W: interrupt received, killing client...\n");
    zmsg_destroy (&amp;request);
    return NULL;
}
</programlisting>

</example>
<para>With an example test program that does 100K request-reply cycles:</para>

<example id="mdclient-c">
<title>Majordomo client application (mdclient.c)</title>
<programlisting language="c">
//
//  Majordomo Protocol client example
//  Uses the mdcli API to hide all MDP aspects
//

//  Lets us build this source without creating a library
#include "mdcliapi.c"

int main (int argc, char *argv [])
{
    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], "-v"));
    mdcli_t *session = mdcli_new ("tcp://localhost:5555", verbose);

    int count;
    for (count = 0; count &lt; 100000; count++) {
        zmsg_t *request = zmsg_new ();
        zmsg_pushstr (request, "Hello world");
        zmsg_t *reply = mdcli_send (session, "echo", &amp;request);
        if (reply)
            zmsg_destroy (&amp;reply);
        else
            break;              //  Interrupt or failure
    }
    printf ("%d requests/replies processed\n", count);
    mdcli_destroy (&amp;session);
    return 0;
}
</programlisting>

</example>
<para>And here is the worker API:</para>

<example id="mdwrkapi-c">
<title>Majordomo worker API (mdwrkapi.c)</title>
<programlisting language="c">
/*  =====================================================================
 *  mdwrkapi.c - Majordomo Protocol Worker API
 *  Implements the MDP/Worker spec at http://rfc.zeromq.org/spec:7.
 *  ===================================================================== */

#include "mdwrkapi.h"

//  Reliability parameters
#define HEARTBEAT_LIVENESS  3       //  3-5 is reasonable
</programlisting>

</example>
<para>This is the structure of a worker API instance. We use a pseudo-OO approach in a lot of the C examples, as well as the CZMQ binding: 
</para>

<example id="mdwrkapi-c-1">
<title>Majordomo worker API (mdwrkapi.c) - worker class structure</title>
<programlisting language="c">

//  Structure of our class
//  We access these properties only via class methods

struct _mdwrk_t {
    zctx_t *ctx;                //  Our context
    char *broker;
    char *service;
    void *worker;               //  Socket to broker
    int verbose;                //  Print activity to stdout

    //  Heartbeat management
    uint64_t heartbeat_at;      //  When to send HEARTBEAT
    size_t liveness;            //  How many attempts left
    int heartbeat;              //  Heartbeat delay, msecs
    int reconnect;              //  Reconnect delay, msecs

    int expect_reply;           //  Zero only at start
    zframe_t *reply_to;         //  Return address, if any
};
</programlisting>

</example>
<para>We have two utility functions; to send a message to the broker and to (re-)connect to the broker: 
</para>

<example id="mdwrkapi-c-2">
<title>Majordomo worker API (mdwrkapi.c) - utility functions</title>
<programlisting language="c">


//  ---------------------------------------------------------------------
//  Send message to broker
//  If no msg is provided, creates one internally

static void
s_mdwrk_send_to_broker (mdwrk_t *self, char *command, char *option,
                        zmsg_t *msg)
{
    msg = msg? zmsg_dup (msg): zmsg_new ();

    //  Stack protocol envelope to start of message
    if (option)
        zmsg_pushstr (msg, option);
    zmsg_pushstr (msg, command);
    zmsg_pushstr (msg, MDPW_WORKER);
    zmsg_pushstr (msg, "");

    if (self-&gt;verbose) {
        zclock_log ("I: sending %s to broker",
            mdps_commands [(int) *command]);
        zmsg_dump (msg);
    }
    zmsg_send (&amp;msg, self-&gt;worker);
}


//  ---------------------------------------------------------------------
//  Connect or reconnect to broker

void s_mdwrk_connect_to_broker (mdwrk_t *self)
{
    if (self-&gt;worker)
        zsocket_destroy (self-&gt;ctx, self-&gt;worker);
    self-&gt;worker = zsocket_new (self-&gt;ctx, ZMQ_DEALER);
    zmq_connect (self-&gt;worker, self-&gt;broker);
    if (self-&gt;verbose)
        zclock_log ("I: connecting to broker at %s...", self-&gt;broker);

    //  Register service with broker
    s_mdwrk_send_to_broker (self, MDPW_READY, self-&gt;service, NULL);

    //  If liveness hits zero, queue is considered disconnected
    self-&gt;liveness = HEARTBEAT_LIVENESS;
    self-&gt;heartbeat_at = zclock_time () + self-&gt;heartbeat;
}
</programlisting>

</example>
<para>Here we have the constructor and destructor for our mdwrk class: 
</para>

<example id="mdwrkapi-c-3">
<title>Majordomo worker API (mdwrkapi.c) - constructor and destructor</title>
<programlisting language="c">


//  ---------------------------------------------------------------------
//  Constructor

mdwrk_t *
mdwrk_new (char *broker,char *service, int verbose)
{
    assert (broker);
    assert (service);

    mdwrk_t *self = (mdwrk_t *) zmalloc (sizeof (mdwrk_t));
    self-&gt;ctx = zctx_new ();
    self-&gt;broker = strdup (broker);
    self-&gt;service = strdup (service);
    self-&gt;verbose = verbose;
    self-&gt;heartbeat = 2500;     //  msecs
    self-&gt;reconnect = 2500;     //  msecs

    s_mdwrk_connect_to_broker (self);
    return self;
}


//  ---------------------------------------------------------------------
//  Destructor

void
mdwrk_destroy (mdwrk_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        mdwrk_t *self = *self_p;
        zctx_destroy (&amp;self-&gt;ctx);
        free (self-&gt;broker);
        free (self-&gt;service);
        free (self);
        *self_p = NULL;
    }
}
</programlisting>

</example>
<para>We provide two methods to configure the worker API. You can set the heartbeat interval and retries to match the expected network performance. 
</para>

<example id="mdwrkapi-c-4">
<title>Majordomo worker API (mdwrkapi.c) - configure worker</title>
<programlisting language="c">


//  ---------------------------------------------------------------------
//  Set heartbeat delay

void
mdwrk_set_heartbeat (mdwrk_t *self, int heartbeat)
{
    self-&gt;heartbeat = heartbeat;
}


//  ---------------------------------------------------------------------
//  Set reconnect delay

void
mdwrk_set_reconnect (mdwrk_t *self, int reconnect)
{
    self-&gt;reconnect = reconnect;
}
</programlisting>

</example>
<para>This is the recv method; it's a little misnamed since it first sends any reply and then waits for a new request. If you have a better name for this, let me know: 
</para>

<example id="mdwrkapi-c-5">
<title>Majordomo worker API (mdwrkapi.c) - recv method</title>
<programlisting language="c">

//  ---------------------------------------------------------------------
//  Send reply, if any, to broker and wait for next request.

zmsg_t *
mdwrk_recv (mdwrk_t *self, zmsg_t **reply_p)
{
    //  Format and send the reply if we were provided one
    assert (reply_p);
    zmsg_t *reply = *reply_p;
    assert (reply || !self-&gt;expect_reply);
    if (reply) {
        assert (self-&gt;reply_to);
        zmsg_wrap (reply, self-&gt;reply_to);
        s_mdwrk_send_to_broker (self, MDPW_REPLY, NULL, reply);
        zmsg_destroy (reply_p);
    }
    self-&gt;expect_reply = 1;

    while (true) {
        zmq_pollitem_t items [] = {
            { self-&gt;worker,  0, ZMQ_POLLIN, 0 } };
        int rc = zmq_poll (items, 1, self-&gt;heartbeat * ZMQ_POLL_MSEC);
        if (rc == -1)
            break;              //  Interrupted

        if (items [0].revents &amp; ZMQ_POLLIN) {
            zmsg_t *msg = zmsg_recv (self-&gt;worker);
            if (!msg)
                break;          //  Interrupted
            if (self-&gt;verbose) {
                zclock_log ("I: received message from broker:");
                zmsg_dump (msg);
            }
            self-&gt;liveness = HEARTBEAT_LIVENESS;

            //  Don't try to handle errors, just assert noisily
            assert (zmsg_size (msg) &gt;= 3);

            zframe_t *empty = zmsg_pop (msg);
            assert (zframe_streq (empty, ""));
            zframe_destroy (&amp;empty);

            zframe_t *header = zmsg_pop (msg);
            assert (zframe_streq (header, MDPW_WORKER));
            zframe_destroy (&amp;header);

            zframe_t *command = zmsg_pop (msg);
            if (zframe_streq (command, MDPW_REQUEST)) {
                //  We should pop and save as many addresses as there are
                //  up to a null part, but for now, just save one...
                self-&gt;reply_to = zmsg_unwrap (msg);
                zframe_destroy (&amp;command);
</programlisting>

</example>
<para>Here is where we actually have a message to process; we return it to the caller application: We have a request to process 
</para>

<example id="mdwrkapi-c-6">
<title>Majordomo worker API (mdwrkapi.c) - process message</title>
<programlisting language="c">
            else
            if (zframe_streq (command, MDPW_HEARTBEAT))
                ;               //  Do nothing for heartbeats
            else
            if (zframe_streq (command, MDPW_DISCONNECT))
                s_mdwrk_connect_to_broker (self);
            else {
                zclock_log ("E: invalid input message");
                zmsg_dump (msg);
            }
            zframe_destroy (&amp;command);
            zmsg_destroy (&amp;msg);
        }
        else
        if (--self-&gt;liveness == 0) {
            if (self-&gt;verbose)
                zclock_log ("W: disconnected from broker - retrying...");
            zclock_sleep (self-&gt;reconnect);
            s_mdwrk_connect_to_broker (self);
        }
        //  Send HEARTBEAT if it's time
        if (zclock_time () &gt; self-&gt;heartbeat_at) {
            s_mdwrk_send_to_broker (self, MDPW_HEARTBEAT, NULL, NULL);
            self-&gt;heartbeat_at = zclock_time () + self-&gt;heartbeat;
        }
    }
    if (zctx_interrupted)
        printf ("W: interrupt received, killing worker...\n");
    return NULL;
}
</programlisting>

</example>
<para>With an example test program that implements an 'echo' service:</para>

<example id="mdworker-c">
<title>Majordomo worker application (mdworker.c)</title>
<programlisting language="c">
//
//  Majordomo Protocol worker example
//  Uses the mdwrk API to hide all MDP aspects
//

//  Lets us build this source without creating a library
#include "mdwrkapi.c"

int main (int argc, char *argv [])
{
    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], "-v"));
    mdwrk_t *session = mdwrk_new (
        "tcp://localhost:5555", "echo", verbose);

    zmsg_t *reply = NULL;
    while (true) {
        zmsg_t *request = mdwrk_recv (session, &amp;reply);
        if (request == NULL)
            break;              //  Worker was interrupted
        reply = request;        //  Echo is complex... :-)
    }
    mdwrk_destroy (&amp;session);
    return 0;
}
</programlisting>

</example>
<para>Notes on this code:</para>

<itemizedlist>
  <listitem><para>The APIs are single threaded. This means, for example, that the worker won't send heartbeats in the background. Happily, this is exactly what we want: if the worker application gets stuck, heartbeats will stop and the broker will stop sending requests to the worker.</para></listitem>
  <listitem><para>The worker API doesn't do an exponential back-off, it's not worth the extra complexity.</para></listitem>
  <listitem><para>The APIs don't do any error reporting. If something isn't as expected, they raise an assertion (or exception depending on the language). This is ideal for a reference implementation, so any protocol errors show immediately. For real applications the API should be robust against invalid messages.</para></listitem>
</itemizedlist>
<para>You might wonder why the worker API is manually closing its socket and opening a new one, when &Oslash;MQ will automatically reconnect a socket if the peer disappears and comes back. Look back at the Simple Pirate worker, and the Paranoid Pirate worker to understand. While &Oslash;MQ will automatically reconnect workers, if the broker dies and comes back up, this isn't sufficient to re-register the workers with the broker. There are at least two solutions I know of. The simplest, which we use here, is that the worker monitors the connection using heartbeats, and if it decides the broker is dead, closes its socket and starts afresh with a new socket. The alternative is for the broker to challenge unknown workers -- when it gets a heartbeat from the worker -- and ask them to re-register. That would require protocol support.</para>

<para>Let's design the Majordomo broker. Its core structure is a set of queues, one per service. We will create these queues as workers appear (we could delete them as workers disappear but forget that for now, it gets complex). Additionally, we keep a queue of workers per service.</para>

<para>And here is the broker:</para>

<example id="mdbroker-c">
<title>Majordomo broker (mdbroker.c)</title>
<programlisting language="c">
//
//  Majordomo Protocol broker
//  A minimal C implementation of the Majordomo Protocol as defined in
//  http://rfc.zeromq.org/spec:7 and http://rfc.zeromq.org/spec:8.
//
#include "czmq.h"
#include "mdp.h"

//  We'd normally pull these from config data

#define HEARTBEAT_LIVENESS  3       //  3-5 is reasonable
#define HEARTBEAT_INTERVAL  2500    //  msecs
#define HEARTBEAT_EXPIRY    HEARTBEAT_INTERVAL * HEARTBEAT_LIVENESS
</programlisting>

</example>
<para>The broker class defines a single broker instance: 
</para>

<example id="mdbroker-c-1">
<title>Majordomo broker (mdbroker.c) - broker class structure</title>
<programlisting language="c">

typedef struct {
    zctx_t *ctx;                //  Our context
    void *socket;               //  Socket for clients &amp; workers
    int verbose;                //  Print activity to stdout
    char *endpoint;             //  Broker binds to this endpoint
    zhash_t *services;          //  Hash of known services
    zhash_t *workers;           //  Hash of known workers
    zlist_t *waiting;           //  List of waiting workers
    uint64_t heartbeat_at;      //  When to send HEARTBEAT
} broker_t;

static broker_t *
    s_broker_new (int verbose);
static void
    s_broker_destroy (broker_t **self_p);
static void
    s_broker_bind (broker_t *self, char *endpoint);
static void
    s_broker_worker_msg (broker_t *self, zframe_t *sender, zmsg_t *msg);
static void
    s_broker_client_msg (broker_t *self, zframe_t *sender, zmsg_t *msg);
static void
    s_broker_purge (broker_t *self);
</programlisting>

</example>
<para>The service class defines a single service instance: 
</para>

<example id="mdbroker-c-2">
<title>Majordomo broker (mdbroker.c) - service class structure</title>
<programlisting language="c">

typedef struct {
    broker_t *broker;           //  Broker instance
    char *name;                 //  Service name
    zlist_t *requests;          //  List of client requests
    zlist_t *waiting;           //  List of waiting workers
    size_t workers;             //  How many workers we have
} service_t;

static service_t *
    s_service_require (broker_t *self, zframe_t *service_frame);
static void
    s_service_destroy (void *argument);
static void
    s_service_dispatch (service_t *service, zmsg_t *msg);
</programlisting>

</example>
<para>The worker class defines a single worker, idle or active: 
</para>

<example id="mdbroker-c-3">
<title>Majordomo broker (mdbroker.c) - worker class structure</title>
<programlisting language="c">

typedef struct {
    broker_t *broker;           //  Broker instance
    char *identity;             //  Identity of worker
    zframe_t *address;          //  Address frame to route to
    service_t *service;         //  Owning service, if known
    int64_t expiry;             //  Expires at unless heartbeat
} worker_t;

static worker_t *
    s_worker_require (broker_t *self, zframe_t *address);
static void
    s_worker_delete (worker_t *self, int disconnect);
static void
    s_worker_destroy (void *argument);
static void
    s_worker_send (worker_t *self, char *command, char *option,
                   zmsg_t *msg);
static void
    s_worker_waiting (worker_t *self);
</programlisting>

</example>
<para>Here are the constructor and destructor for the broker: 
</para>

<example id="mdbroker-c-4">
<title>Majordomo broker (mdbroker.c) - broker constructor and destructor</title>
<programlisting language="c">

static broker_t *
s_broker_new (int verbose)
{
    broker_t *self = (broker_t *) zmalloc (sizeof (broker_t));

    //  Initialize broker state
    self-&gt;ctx = zctx_new ();
    self-&gt;socket = zsocket_new (self-&gt;ctx, ZMQ_ROUTER);
    self-&gt;verbose = verbose;
    self-&gt;services = zhash_new ();
    self-&gt;workers = zhash_new ();
    self-&gt;waiting = zlist_new ();
    self-&gt;heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;
    return self;
}

static void
s_broker_destroy (broker_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        broker_t *self = *self_p;
        zctx_destroy (&amp;self-&gt;ctx);
        zhash_destroy (&amp;self-&gt;services);
        zhash_destroy (&amp;self-&gt;workers);
        zlist_destroy (&amp;self-&gt;waiting);
        free (self);
        *self_p = NULL;
    }
}
</programlisting>

</example>
<para>The bind method binds the broker instance to an endpoint. We can call this multiple times. Note that MDP uses a single socket for both clients and workers: 
</para>

<example id="mdbroker-c-5">
<title>Majordomo broker (mdbroker.c) - broker bind method</title>
<programlisting language="c">

void
s_broker_bind (broker_t *self, char *endpoint)
{
    zsocket_bind (self-&gt;socket, endpoint);
    zclock_log ("I: MDP broker/0.2.0 is active at %s", endpoint);
}
</programlisting>

</example>
<para>The worker_msg method processes one READY, REPLY, HEARTBEAT or DISCONNECT message sent to the broker by a worker: 
</para>

<example id="mdbroker-c-6">
<title>Majordomo broker (mdbroker.c) - broker worker_msg method</title>
<programlisting language="c">

static void
s_broker_worker_msg (broker_t *self, zframe_t *sender, zmsg_t *msg)
{
    assert (zmsg_size (msg) &gt;= 1);     //  At least, command

    zframe_t *command = zmsg_pop (msg);
    char *identity = zframe_strhex (sender);
    int worker_ready = (zhash_lookup (self-&gt;workers, identity) != NULL);
    free (identity);
    worker_t *worker = s_worker_require (self, sender);

    if (zframe_streq (command, MDPW_READY)) {
        if (worker_ready)               //  Not first command in session
            s_worker_delete (worker, 1);
        else
        if (zframe_size (sender) &gt;= 4  //  Reserved service name
        &amp;&amp;  memcmp (zframe_data (sender), "mmi.", 4) == 0)
            s_worker_delete (worker, 1);
        else {
            //  Attach worker to service and mark as idle
            zframe_t *service_frame = zmsg_pop (msg);
            worker-&gt;service = s_service_require (self, service_frame);
            worker-&gt;service-&gt;workers++;
            s_worker_waiting (worker);
            zframe_destroy (&amp;service_frame);
        }
    }
    else
    if (zframe_streq (command, MDPW_REPLY)) {
        if (worker_ready) {
            //  Remove &amp; save client return envelope and insert the
            //  protocol header and service name, then rewrap envelope.
            zframe_t *client = zmsg_unwrap (msg);
            zmsg_pushstr (msg, worker-&gt;service-&gt;name);
            zmsg_pushstr (msg, MDPC_CLIENT);
            zmsg_wrap (msg, client);
            zmsg_send (&amp;msg, self-&gt;socket);
            s_worker_waiting (worker);
        }
        else
            s_worker_delete (worker, 1);
    }
    else
    if (zframe_streq (command, MDPW_HEARTBEAT)) {
        if (worker_ready)
            worker-&gt;expiry = zclock_time () + HEARTBEAT_EXPIRY;
        else
            s_worker_delete (worker, 1);
    }
    else
    if (zframe_streq (command, MDPW_DISCONNECT))
        s_worker_delete (worker, 0);
    else {
        zclock_log ("E: invalid input message");
        zmsg_dump (msg);
    }
    free (command);
    zmsg_destroy (&amp;msg);
}
</programlisting>

</example>
<para>Process a request coming from a client. We implement MMI requests directly here (at present, we implement only the mmi.service request): 
</para>

<example id="mdbroker-c-7">
<title>Majordomo broker (mdbroker.c) - broker client_msg method</title>
<programlisting language="c">

static void
s_broker_client_msg (broker_t *self, zframe_t *sender, zmsg_t *msg)
{
    assert (zmsg_size (msg) &gt;= 2);     //  Service name + body

    zframe_t *service_frame = zmsg_pop (msg);
    service_t *service = s_service_require (self, service_frame);

    //  Set reply return address to client sender
    zmsg_wrap (msg, zframe_dup (sender));

    //  If we got a MMI service request, process that internally
    if (zframe_size (service_frame) &gt;= 4
    &amp;&amp;  memcmp (zframe_data (service_frame), "mmi.", 4) == 0) {
        char *return_code;
        if (zframe_streq (service_frame, "mmi.service")) {
            char *name = zframe_strdup (zmsg_last (msg));
            service_t *service =
                (service_t *) zhash_lookup (self-&gt;services, name);
            return_code = service &amp;&amp; service-&gt;workers? "200": "404";
            free (name);
        }
        else
            return_code = "501";

        zframe_reset (zmsg_last (msg), return_code, strlen (return_code));

        //  Remove &amp; save client return envelope and insert the
        //  protocol header and service name, then rewrap envelope.
        zframe_t *client = zmsg_unwrap (msg);
        zmsg_push (msg, zframe_dup (service_frame));
        zmsg_pushstr (msg, MDPC_CLIENT);
        zmsg_wrap (msg, client);
        zmsg_send (&amp;msg, self-&gt;socket);
    }
    else
        //  Else dispatch the message to the requested service
        s_service_dispatch (service, msg);
    zframe_destroy (&amp;service_frame);
}
</programlisting>

</example>
<para>The purge method deletes any idle workers that haven't pinged us in a while. We hold workers from oldest to most recent, so we can stop scanning whenever we find a live worker. This means we'll mainly stop at the first worker, which is essential when we have large numbers of workers (since we call this method in our critical path): 
</para>

<example id="mdbroker-c-8">
<title>Majordomo broker (mdbroker.c) - broker purge method</title>
<programlisting language="c">

static void
s_broker_purge (broker_t *self)
{
    worker_t *worker = (worker_t *) zlist_first (self-&gt;waiting);
    while (worker) {
        if (zclock_time () &lt; worker-&gt;expiry)
            break;                  //  Worker is alive, we're done here
        if (self-&gt;verbose)
            zclock_log ("I: deleting expired worker: %s",
                        worker-&gt;identity);

        s_worker_delete (worker, 0);
        worker = (worker_t *) zlist_first (self-&gt;waiting);
    }
}
</programlisting>

</example>
<para>Here is the implementation of the methods that work on a service: 
</para>

<example id="mdbroker-c-9">
<title>Majordomo broker (mdbroker.c) - service methods</title>
<programlisting language="c">

//  Lazy constructor that locates a service by name, or creates a new
//  service if there is no service already with that name.

static service_t *
s_service_require (broker_t *self, zframe_t *service_frame)
{
    assert (service_frame);
    char *name = zframe_strdup (service_frame);

    service_t *service =
        (service_t *) zhash_lookup (self-&gt;services, name);
    if (service == NULL) {
        service = (service_t *) zmalloc (sizeof (service_t));
        service-&gt;broker = self;
        service-&gt;name = name;
        service-&gt;requests = zlist_new ();
        service-&gt;waiting = zlist_new ();
        zhash_insert (self-&gt;services, name, service);
        zhash_freefn (self-&gt;services, name, s_service_destroy);
        if (self-&gt;verbose)
            zclock_log ("I: added service: %s", name);
    }
    else
        free (name);

    return service;
}

//  Service destructor is called automatically whenever the service is
//  removed from broker-&gt;services.

static void
s_service_destroy (void *argument)
{
    service_t *service = (service_t *) argument;
    while (zlist_size (service-&gt;requests)) {
        zmsg_t *msg = zlist_pop (service-&gt;requests);
        zmsg_destroy (&amp;msg);
    }
    zlist_destroy (&amp;service-&gt;requests);
    zlist_destroy (&amp;service-&gt;waiting);
    free (service-&gt;name);
    free (service);
}
</programlisting>

</example>
<para>The dispatch method sends requests to waiting workers: 
</para>

<example id="mdbroker-c-10">
<title>Majordomo broker (mdbroker.c) - service dispatch method</title>
<programlisting language="c">

static void
s_service_dispatch (service_t *self, zmsg_t *msg)
{
    assert (self);
    if (msg)                    //  Queue message if any
        zlist_append (self-&gt;requests, msg);

    s_broker_purge (self-&gt;broker);
    while (zlist_size (self-&gt;waiting) &amp;&amp; zlist_size (self-&gt;requests)) {
        worker_t *worker = zlist_pop (self-&gt;waiting);
        zlist_remove (self-&gt;broker-&gt;waiting, worker);
        zmsg_t *msg = zlist_pop (self-&gt;requests);
        s_worker_send (worker, MDPW_REQUEST, NULL, msg);
        zmsg_destroy (&amp;msg);
    }
}
</programlisting>

</example>
<para>Here is the implementation of the methods that work on a worker: 
</para>

<example id="mdbroker-c-11">
<title>Majordomo broker (mdbroker.c) - worker methods</title>
<programlisting language="c">

//  Lazy constructor that locates a worker by identity, or creates a new
//  worker if there is no worker already with that identity.

static worker_t *
s_worker_require (broker_t *self, zframe_t *address)
{
    assert (address);

    //  self-&gt;workers is keyed off worker identity
    char *identity = zframe_strhex (address);
    worker_t *worker =
        (worker_t *) zhash_lookup (self-&gt;workers, identity);

    if (worker == NULL) {
        worker = (worker_t *) zmalloc (sizeof (worker_t));
        worker-&gt;broker = self;
        worker-&gt;identity = identity;
        worker-&gt;address = zframe_dup (address);
        zhash_insert (self-&gt;workers, identity, worker);
        zhash_freefn (self-&gt;workers, identity, s_worker_destroy);
        if (self-&gt;verbose)
            zclock_log ("I: registering new worker: %s", identity);
    }
    else
        free (identity);
    return worker;
}

//  The delete method deletes the current worker.

static void
s_worker_delete (worker_t *self, int disconnect)
{
    assert (self);
    if (disconnect)
        s_worker_send (self, MDPW_DISCONNECT, NULL, NULL);

    if (self-&gt;service) {
        zlist_remove (self-&gt;service-&gt;waiting, self);
        self-&gt;service-&gt;workers--;
    }
    zlist_remove (self-&gt;broker-&gt;waiting, self);
    //  This implicitly calls s_worker_destroy
    zhash_delete (self-&gt;broker-&gt;workers, self-&gt;identity);
}

//  Worker destructor is called automatically whenever the worker is
//  removed from broker-&gt;workers.

static void
s_worker_destroy (void *argument)
{
    worker_t *self = (worker_t *) argument;
    zframe_destroy (&amp;self-&gt;address);
    free (self-&gt;identity);
    free (self);
}
</programlisting>

</example>
<para>The send method formats and sends a command to a worker. The caller may also provide a command option, and a message payload: 
</para>

<example id="mdbroker-c-12">
<title>Majordomo broker (mdbroker.c) - worker send method</title>
<programlisting language="c">

static void
s_worker_send (worker_t *self, char *command, char *option, zmsg_t *msg)
{
    msg = msg? zmsg_dup (msg): zmsg_new ();

    //  Stack protocol envelope to start of message
    if (option)
        zmsg_pushstr (msg, option);
    zmsg_pushstr (msg, command);
    zmsg_pushstr (msg, MDPW_WORKER);

    //  Stack routing envelope to start of message
    zmsg_wrap (msg, zframe_dup (self-&gt;address));

    if (self-&gt;broker-&gt;verbose) {
        zclock_log ("I: sending %s to worker",
            mdps_commands [(int) *command]);
        zmsg_dump (msg);
    }
    zmsg_send (&amp;msg, self-&gt;broker-&gt;socket);
}

//  This worker is now waiting for work

static void
s_worker_waiting (worker_t *self)
{
    //  Queue to broker and service waiting lists
    assert (self-&gt;broker);
    zlist_append (self-&gt;broker-&gt;waiting, self);
    zlist_append (self-&gt;service-&gt;waiting, self);
    self-&gt;expiry = zclock_time () + HEARTBEAT_EXPIRY;
    s_service_dispatch (self-&gt;service, NULL);
}
</programlisting>

</example>
<para>Finally here is the main task. We create a new broker instance and then processes messages on the broker socket: 
</para>

<example id="mdbroker-c-13">
<title>Majordomo broker (mdbroker.c) - main task</title>
<programlisting language="c">

int main (int argc, char *argv [])
{
    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], "-v"));

    broker_t *self = s_broker_new (verbose);
    s_broker_bind (self, "tcp://*:5555");

    //  Get and process messages forever or until interrupted
    while (true) {
        zmq_pollitem_t items [] = {
            { self-&gt;socket,  0, ZMQ_POLLIN, 0 } };
        int rc = zmq_poll (items, 1, HEARTBEAT_INTERVAL * ZMQ_POLL_MSEC);
        if (rc == -1)
            break;              //  Interrupted

        //  Process next input message, if any
        if (items [0].revents &amp; ZMQ_POLLIN) {
            zmsg_t *msg = zmsg_recv (self-&gt;socket);
            if (!msg)
                break;          //  Interrupted
            if (self-&gt;verbose) {
                zclock_log ("I: received message:");
                zmsg_dump (msg);
            }
            zframe_t *sender = zmsg_pop (msg);
            zframe_t *empty  = zmsg_pop (msg);
            zframe_t *header = zmsg_pop (msg);

            if (zframe_streq (header, MDPC_CLIENT))
                s_broker_client_msg (self, sender, msg);
            else
            if (zframe_streq (header, MDPW_WORKER))
                s_broker_worker_msg (self, sender, msg);
            else {
                zclock_log ("E: invalid message:");
                zmsg_dump (msg);
                zmsg_destroy (&amp;msg);
            }
            zframe_destroy (&amp;sender);
            zframe_destroy (&amp;empty);
            zframe_destroy (&amp;header);
        }
        //  Disconnect and delete any expired workers
        //  Send heartbeats to idle workers if needed
        if (zclock_time () &gt; self-&gt;heartbeat_at) {
            s_broker_purge (self);
            worker_t *worker = (worker_t *) zlist_first (self-&gt;waiting);
            while (worker) {
                s_worker_send (worker, MDPW_HEARTBEAT, NULL, NULL);
                worker = (worker_t *) zlist_next (self-&gt;waiting);
            }
            self-&gt;heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;
        }
    }
    if (zctx_interrupted)
        printf ("W: interrupt received, shutting down...\n");

    s_broker_destroy (&amp;self);
    return 0;
}
</programlisting>

</example>
<para>This is by far the most complex example we've seen. It's almost 500 lines of code. To write this, and make it somewhat robust took two days. However this is still a short piece of code for a full service-oriented broker.</para>

<para>Notes on this code:</para>

<itemizedlist>
  <listitem><para>The Majordomo Protocol lets us handle both clients and workers on a single socket. This is nicer for those deploying and managing the broker: it just sits on one &Oslash;MQ endpoint rather than the two that most devices need.</para></listitem>
  <listitem><para>The broker implements all of MDP/0.1 properly (as far as I know), including disconnection if the broker sends invalid commands, heartbeating, and the rest.</para></listitem>
  <listitem><para>It can be extended to run multiple threads, each managing one socket and one set of clients and workers. This could be interesting for segmenting large architectures. The C code is already organized around a broker class to make this trivial.</para></listitem>
  <listitem><para>A primary-fail-over or live-live broker reliability model is easy, since the broker essentially has no state except service presence. It's up to clients and workers to choose another broker if their first choice isn't up and running.</para></listitem>
  <listitem><para>The examples use 5-second heartbeats, mainly to reduce the amount of output when you enable tracing. Realistic values would be lower for most LAN applications. However, any retry has to be slow enough to allow for a service to restart, say 10 seconds at least.</para></listitem>
  <listitem><para>We later improved and extended the protocol and the Majordomo implementation, which now sits in its own Github project. If you want a properly usable Majordomo stack, use the github project.</para></listitem>
</itemizedlist>
</sect1>
<sect1>
<title>Asynchronous Majordomo Pattern</title>
<para>The way we implemented Majordomo, above, is simple and stupid. The client is just the original Simple Pirate, wrapped up in a sexy API. When I fire up a client, broker, and worker on a test box, it can process 100,000 requests in about 14 seconds. That is partly due to the code, which cheerfully copies message frames around as if CPU cycles were free. But the real problem is that we're doing network round-trips. &Oslash;MQ disables <ulink url="http://en.wikipedia.org/wiki/Nagles_algorithm">Nagle's algorithm</ulink>, but round-tripping is still slow.</para>

<para>Theory is great in theory, but in practice, practice is better. Let's measure the actual cost of round-tripping with a simple test program. This sends a bunch of messages, first waiting for a reply to each message, and second as a batch, reading all the replies back as a batch. Both approaches do the same work, but they give very different results. We mock-up a client, broker, and worker:</para>

<example id="tripping-c">
<title>Round-trip demonstrator (tripping.c)</title>
<programlisting language="c">
//
//  Round-trip demonstrator
//
//  While this example runs in a single process, that is just to make
//  it easier to start and stop the example. The client task signals to
//  main when it's ready.
//
#include "czmq.h"

static void
client_task (void *args, zctx_t *ctx, void *pipe)
{
    void *client = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_connect (client, "tcp://localhost:5555");
    printf ("Setting up test...\n");
    zclock_sleep (100);

    int requests;
    int64_t start;

    printf ("Synchronous round-trip test...\n");
    start = zclock_time ();
    for (requests = 0; requests &lt; 10000; requests++) {
        zstr_send (client, "hello");
        char *reply = zstr_recv (client);
        free (reply);
    }
    printf (" %d calls/second\n",
        (1000 * 10000) / (int) (zclock_time () - start));

    printf ("Asynchronous round-trip test...\n");
    start = zclock_time ();
    for (requests = 0; requests &lt; 100000; requests++)
        zstr_send (client, "hello");
    for (requests = 0; requests &lt; 100000; requests++) {
        char *reply = zstr_recv (client);
        free (reply);
    }
    printf (" %d calls/second\n",
        (1000 * 100000) / (int) (zclock_time () - start));
    zstr_send (pipe, "done");
}
</programlisting>

</example>
<para>Here is the worker task. All it does is receive a message, and bounce it back the way it came: 
</para>

<example id="tripping-c-1">
<title>Round-trip demonstrator (tripping.c) - worker task</title>
<programlisting language="c">

static void *
worker_task (void *args)
{
    zctx_t *ctx = zctx_new ();
    void *worker = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_connect (worker, "tcp://localhost:5556");
    
    while (true) {
        zmsg_t *msg = zmsg_recv (worker);
        zmsg_send (&amp;msg, worker);
    }
    zctx_destroy (&amp;ctx);
    return NULL;
}
</programlisting>

</example>
<para>Here is the broker task. It uses the zmq_proxy function to switch messages between frontend and backend: 
</para>

<example id="tripping-c-2">
<title>Round-trip demonstrator (tripping.c) - broker task</title>
<programlisting language="c">

static void *
broker_task (void *args)
{
    //  Prepare our context and sockets
    zctx_t *ctx = zctx_new ();
    void *frontend = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_bind (frontend, "tcp://*:5555");
    void *backend = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_bind (backend, "tcp://*:5556");
    zmq_proxy (frontend, backend, NULL);
    zctx_destroy (&amp;ctx);
    return NULL;
}
</programlisting>

</example>
<para>Finally, here's the main task, which starts the client, worker, and broker, and then runs until the client signals it to stop: 
</para>

<example id="tripping-c-3">
<title>Round-trip demonstrator (tripping.c) - main task</title>
<programlisting language="c">

int main (void)
{
    //  Create threads
    zctx_t *ctx = zctx_new ();
    void *client = zthread_fork (ctx, client_task, NULL);
    zthread_new (worker_task, NULL);
    zthread_new (broker_task, NULL);

    //  Wait for signal on client pipe
    char *signal = zstr_recv (client);
    free (signal);

    zctx_destroy (&amp;ctx);
    return 0;
}
</programlisting>

</example>
<para>On my development box, this program says:</para>

<screen>Setting up test...
Synchronous round-trip test...
 9057 calls/second
Asynchronous round-trip test...
 173010 calls/second
</screen>

<para>Note that the client thread does a small pause before starting. This is to get around one of the 'features' of the router socket: if you send a message with the address of a peer that's not yet connected, the message gets discarded. In this example we don't use the LRU mechanism, so without the sleep, if the worker thread is too slow to connect, it'll lose messages, making a mess of our test.</para>

<para>As we see, round-tripping in the simplest case is 20 times slower than "shove it down the pipe as fast as it'll go" asynchronous approach. Let's see if we can apply this to Majordomo to make it faster.</para>

<para>First, we modify the client API to have separate send and recv methods:</para>

<programlisting language="c">
mdcli_t *mdcli_new     (char *broker);
void     mdcli_destroy (mdcli_t **self_p);
int      mdcli_send    (mdcli_t *self, char *service, zmsg_t **request_p);
zmsg_t  *mdcli_recv    (mdcli_t *self);
</programlisting>

<para>It's literally a few minutes' work to refactor the synchronous client API to become asynchronous:</para>

<example id="mdcliapi2-c">
<title>Majordomo asynchronous client API (mdcliapi2.c)</title>
<programlisting language="c">
/*  =====================================================================
 *  mdcliapi2.c - Majordomo Protocol Client API
 *  Implements the MDP/Worker spec at http://rfc.zeromq.org/spec:7.
 *  ===================================================================== */

#include "mdcliapi2.h"

//  Structure of our class
//  We access these properties only via class methods

struct _mdcli_t {
    zctx_t *ctx;                //  Our context
    char *broker;
    void *client;               //  Socket to broker
    int verbose;                //  Print activity to stdout
    int timeout;                //  Request timeout
};

//  ---------------------------------------------------------------------
//  Connect or reconnect to broker. In this asynchronous class we use a
//  DEALER socket instead of a REQ socket; this lets us send any number
//  of requests without waiting for a reply.

void s_mdcli_connect_to_broker (mdcli_t *self)
{
    if (self-&gt;client)
        zsocket_destroy (self-&gt;ctx, self-&gt;client);
    self-&gt;client = zsocket_new (self-&gt;ctx, ZMQ_DEALER);
    zmq_connect (self-&gt;client, self-&gt;broker);
    if (self-&gt;verbose)
        zclock_log ("I: connecting to broker at %s...", self-&gt;broker);
}


//  The constructor and destructor are the same as in mdcliapi, except
//  we don't do retries, so there's no retries property.
...
...
</programlisting>

</example>
<para>And here's the corresponding client test program:</para>

<example id="mdclient2-c">
<title>Majordomo client application (mdclient2.c)</title>
<programlisting language="c">
//
//  Majordomo Protocol client example - asynchronous
//  Uses the mdcli API to hide all MDP aspects
//
//  Lets us build this source without creating a library
#include "mdcliapi2.c"

int main (int argc, char *argv [])
{
    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], "-v"));
    mdcli_t *session = mdcli_new ("tcp://localhost:5555", verbose);

    int count;
    for (count = 0; count &lt; 100000; count++) {
        zmsg_t *request = zmsg_new ();
        zmsg_pushstr (request, "Hello world");
        mdcli_send (session, "echo", &amp;request);
    }
    for (count = 0; count &lt; 100000; count++) {
        zmsg_t *reply = mdcli_recv (session);
        if (reply)
            zmsg_destroy (&amp;reply);
        else
            break;              //  Interrupted by Ctrl-C
    }
    printf ("%d replies received\n", count);
    mdcli_destroy (&amp;session);
    return 0;
}
</programlisting>

</example>
<para>The broker and worker are unchanged, since we've not modified the protocol at all. We see an immediate improvement in performance. Here's the synchronous client chugging through 100K request-reply cycles:</para>

<screen>$ time mdclient
100000 requests/replies processed

real    0m14.088s
user    0m1.310s
sys     0m2.670s
</screen>

<para>And here's the asynchronous client, with a single worker:</para>

<screen>$ time mdclient2
100000 replies received

real    0m8.730s
user    0m0.920s
sys     0m1.550s
</screen>

<para>Twice as fast. Not bad, but let's fire up 10 workers, and see how it handles:</para>

<screen>$ time mdclient2
100000 replies received

real    0m3.863s
user    0m0.730s
sys     0m0.470s
</screen>

<para>It isn't fully asynchronous since workers get their messages on a strict LRU basis. But it will scale better with more workers. On my PC, after eight or so workers it doesn't get any faster. Four cores only stretches so far. But we got a 4x improvement in throughput with just a few minutes' work. The broker is still unoptimized. It spends most of its time copying message frames around, instead of doing zero copy, which it could. But we're getting 25K reliable request/reply calls a second, with pretty low effort.</para>

<para>However the asynchronous Majordomo pattern isn't all roses. It has a fundamental weakness, namely that it cannot survive a broker crash without more work. If you look at the mdcliapi2 code you'll see it does not attempt to reconnect after a failure. A proper reconnect would require:</para>

<itemizedlist>
  <listitem><para>That every request is numbered, and every reply has a matching number, which would ideally require a change to the protocol to enforce.</para></listitem>
  <listitem><para>That the client API tracks and holds onto all outstanding requests, i.e. for which no reply had yet been received.</para></listitem>
  <listitem><para>That in case of fail-over, the client API <emphasis>resends</emphasis> all outstanding requests to the broker.</para></listitem>
</itemizedlist>
<para>It's not a deal breaker but it does show that performance often means complexity. Is this worth doing for Majordomo? It depends on your use case. For a name lookup service you call once per session, no. For a web front-end serving thousands of clients, probably yes.</para>

</sect1>
<sect1>
<title>Service Discovery</title>
<para>So, we have a nice service-oriented broker, but we have no way of knowing whether a particular service is available or not. We know if a request failed, but we don't know why. It is useful to be able to ask the broker, "is the echo service running?" The most obvious way would be to modify our MDP/Client protocol to add commands to ask the broker, "is service X running?" But MDP/Client has the great charm of being simple. Adding service discovery to it would make it as complex as the MDP/Worker protocol.</para>

<para>Another option is to do what email does, and ask that undeliverable requests be returned. This can work well in an asynchronous world but it also adds complexity. We need ways to distinguish returned requests from replies, and to handle these properly.</para>

<para>Let's try to use what we've already built, building on top of MDP instead of modifying it. Service discovery is, itself, a service. It might indeed be one of several management services, such as "disable service X", "provide statistics", and so on. What we want is a general, extensible solution that doesn't affect the protocol nor existing applications.</para>

<para>So here's a small RFC - MMI, or the Majordomo Management Interface - that layers this on top of MDP: http://rfc.zeromq.org/spec:8. We already implemented it in the broker, though unless you read the whole thing you probably missed that. Here's how we use the service discovery in an application:</para>

<example id="mmiecho-c">
<title>Service discovery over Majordomo (mmiecho.c)</title>
<programlisting language="c">
//
//  MMI echo query example
//

//  Lets us build this source without creating a library
#include "mdcliapi.c"

int main (int argc, char *argv [])
{
    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], "-v"));
    mdcli_t *session = mdcli_new ("tcp://localhost:5555", verbose);

    //  This is the service we want to look up
    zmsg_t *request = zmsg_new ();
    zmsg_addstr (request, "echo");

    //  This is the service we send our request to
    zmsg_t *reply = mdcli_send (session, "mmi.service", &amp;request);

    if (reply) {
        char *reply_code = zframe_strdup (zmsg_first (reply));
        printf ("Lookup echo service: %s\n", reply_code);
        free (reply_code);
        zmsg_destroy (&amp;reply);
    }
    else
        printf ("E: no response from broker, make sure it's running\n");

    mdcli_destroy (&amp;session);
    return 0;
}
</programlisting>

</example>
<para>The broker checks the service name, and handles any service starting with "mmi." itself, rather than passing the request on to a worker. Try this with and without a worker running, and you should see the little program report '200' or '404' accordingly. The implementation of MMI in our example broker is pretty weak. For example if a worker disappears, services remain "present". In practice a broker should remove services that have no workers after some configurable timeout.</para>

</sect1>
<sect1>
<title>Idempotent Services</title>
<para>Idempotency is not something you take a pill for. What it means is that it's safe to repeat an operation. Checking the clock is idempotent. Lending ones credit card to ones children is not. While many client-to-server use cases are idempotent, some are not. Examples of idempotent use cases include:</para>

<itemizedlist>
  <listitem><para>Stateless task distribution, i.e. a pipeline where the servers are stateless workers that compute a reply based purely on the state provided by a request. In such a case it's safe (though inefficient) to execute the same request many times.</para></listitem>
  <listitem><para>A name service that translates logical addresses into endpoints to bind or connect to. In such a case it's safe to make the same lookup request many times.</para></listitem>
</itemizedlist>
<para>And here are examples of a non-idempotent use cases:</para>

<itemizedlist>
  <listitem><para>A logging service. One does not want the same log information recorded more than once.</para></listitem>
  <listitem><para>Any service that has impact on downstream nodes, e.g. sends on information to other nodes. If that service gets the same request more than once, downstream nodes will get duplicate information.</para></listitem>
  <listitem><para>Any service that modifies shared data in some non-idempotent way. E.g. a service that debits a bank account is definitely not idempotent.</para></listitem>
</itemizedlist>
<para>When our server applications are not idempotent, we have to think more carefully about when exactly they might crash. If an application dies when it's idle, or while it's processing a request, that's usually fine. We can use database transactions to make sure a debit and a credit are always done together, if at all. If the server dies while sending its reply, that's a problem, because as far as it's concerned, it's done its work.</para>

<para>if the network dies just as the reply is making its way back to the client, the same problem arises. The client will think the server died, will resend the request, and the server will do the same work twice. Which is not what we want.</para>

<para>We use the fairly standard solution of detecting and rejecting duplicate requests. This means:</para>

<itemizedlist>
  <listitem><para>The client must stamp every request with a unique client identifier and a unique message number.</para></listitem>
  <listitem><para>The server, before sending back a reply, stores it using the client id + message number as a key.</para></listitem>
  <listitem><para>The server, when getting a request from a given client, first checks if it has a reply for that client id + message number. If so, it does not process the request but just resends the reply.</para></listitem>
</itemizedlist>
</sect1>
<sect1>
<title>Disconnected Reliability (Titanic Pattern)</title>
<para>Once you realize that Majordomo is a 'reliable' message broker, you might be tempted to add some spinning rust (that is, ferrous-based hard disk platters). After all, this works for all the enterprise messaging systems. It's such a tempting idea that it's a little sad to have to be negative. But brutal cynicism is one of my specialties. So, some reasons you don't want rust-based brokers sitting in the center of your architecture are:</para>

<itemizedlist>
  <listitem><para>As you've seen, the Lazy Pirate client performs surprisingly well. It works across a whole range of architectures, from direct client-to-server to distributed queue devices. It does tend to assume that workers are stateless and idempotent. But we can work around that limitation without resorting to rust.</para></listitem>
  <listitem><para>Rust brings a whole set of problems, from slow performance to additional pieces to have to manage, repair, and create 6am panics as they inevitably break at the start of daily operations. The beauty of the Pirate patterns in general is their simplicity. They won't crash. And if you're still worried about the hardware, you can move to a peer-to-peer pattern that has no broker at all. I'll explain later in this chapter.</para></listitem>
</itemizedlist>
<para>Having said this, however, there is one sane use case for rust-based reliability, which is an asynchronous disconnected network. It solves a major problem with Pirate, namely that a client has to wait for an answer in real-time. If clients and workers are only sporadically connected (think of email as an analogy), we can't use a stateless network between clients and workers. We have to put state in the middle.</para>

<para>So, here's the Titanic pattern(<xref linkend="figure-57"/>), in which we write messages to disk to ensure they never get lost, no matter how sporadically clients and workers are connected. As we did for service discovery, we're going to layer Titanic on top of Majordomo rather than extend MDP. It's wonderfully lazy because it means we can implement our fire-and-forget reliability in a specialized worker, rather than in the broker. This is excellent for several reasons:</para>

<itemizedlist>
  <listitem><para>It is <emphasis>much</emphasis> easier because we divide and conquer: the broker handles message routing and the worker handles reliability.</para></listitem>
  <listitem><para>It lets us mix brokers written in one language with workers written in another.</para></listitem>
  <listitem><para>It lets us evolve the fire-and-forget technology independently.</para></listitem>
</itemizedlist>
<para>The only downside is that there's an extra network hop between broker and hard disk. This is easily worth it.</para>

<para>There are many ways to make a persistent request-reply architecture. We'll aim for simple and painless. The simplest design I could come up with, after playing with this for a few hours, is Titanic as a "proxy service". That is, it doesn't affect workers at all. If a client wants a reply immediately, it talks directly to a service and hopes the service is available. If a client is happy to wait a while, it talks to Titanic instead and asks, "hey, buddy, would you take care of this for me while I go buy my groceries?"</para>

<figure id="figure-57">
    <title>The Titanic Pattern</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig57.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>Titanic is thus both a worker, and a client. The dialog between client and Titanic goes along these lines:</para>

<itemizedlist>
  <listitem><para>Client: please accept this request for me. Titanic: OK, done.</para></listitem>
  <listitem><para>Client: do you have a reply for me? Titanic: Yes, here it is. Or, no, not yet.</para></listitem>
  <listitem><para>Client: ok, you can wipe that request now, it's all happy. Titanic: OK, done.</para></listitem>
</itemizedlist>
<para>Whereas the dialog between Titanic and broker and worker goes like this:</para>

<itemizedlist>
  <listitem><para>Titanic: hey, broker, is there an echo service? Broker: uhm, yeah, seems like.</para></listitem>
  <listitem><para>Titanic: hey, echo, please handle this for me. Echo: sure, here you are.</para></listitem>
  <listitem><para>Titanic: sweeeeet!</para></listitem>
</itemizedlist>
<para>You can work through this, and the possible failure scenarios. If a worker crashes while processing a request, Titanic retries, indefinitely. If a reply gets lost somewhere, Titanic will retry. If the request gets processed but the client doesn't get the reply, it will ask again. If Titanic crashes while processing a request, or a reply, the client will try again. As long as requests are fully committed to safe storage, work can't get lost.</para>

<para>The handshaking is pedantic, but can be pipelined, i.e. clients can use the asynchronous Majordomo pattern to do a lot of work and then get the responses later.</para>

<para>We need some way for a client to request <emphasis>its</emphasis> replies. We'll have many clients asking for the same services, and clients disappear and reappear with different identities. So here is a simple, reasonably secure solution:</para>

<itemizedlist>
  <listitem><para>Every request generates a universally unique ID (UUID), which Titanic returns to the client when it's queued the request.</para></listitem>
  <listitem><para>When a client asks for a reply, it must specify the UUID for the original request.</para></listitem>
</itemizedlist>
<para>This puts some onus on the client to store its request UUIDs safely, but it removes any need for authentication. What alternatives are there?</para>

<para>Before we jump off and write yet another formal specification (fun, fun!) let's consider how the client talks to Titanic. One way is to use a single service and send it three different request types. Another way, which seems simpler, is to use three services:</para>

<itemizedlist>
  <listitem><para><emphasis role="bold">titanic.request</emphasis> - store a request message, return a UUID for the request.</para></listitem>
  <listitem><para><emphasis role="bold">titanic.reply</emphasis> - fetch a reply, if available, for a given request UUID.</para></listitem>
  <listitem><para><emphasis role="bold">titanic.close</emphasis> - confirm that a reply has been stored and processed.</para></listitem>
</itemizedlist>
<para>We'll just make a multithreaded worker, which as we've seen from our multithreading experience with &Oslash;MQ, is trivial. However before jumping into code let's sketch down what Titanic would look like in terms of &Oslash;MQ messages and frames: http://rfc.zeromq.org/spec:9. This is the "Titanic Service Protocol", or TSP.</para>

<para>Using TSP is clearly more work for client applications than accessing a service directly via MDP. Here's the shortest robust 'echo' client example:</para>

<example id="ticlient-c">
<title>Titanic client example (ticlient.c)</title>
<programlisting language="c">
//
//  Titanic client example
//  Implements client side of http://rfc.zeromq.org/spec:9

//  Lets us build this source without creating a library
#include "mdcliapi.c"

//  Calls a TSP service
//  Returns response if successful (status code 200 OK), else NULL
//
static zmsg_t *
s_service_call (mdcli_t *session, char *service, zmsg_t **request_p)
{
    zmsg_t *reply = mdcli_send (session, service, request_p);
    if (reply) {
        zframe_t *status = zmsg_pop (reply);
        if (zframe_streq (status, "200")) {
            zframe_destroy (&amp;status);
            return reply;
        }
        else
        if (zframe_streq (status, "400")) {
            printf ("E: client fatal error, aborting\n");
            exit (EXIT_FAILURE);
        }
        else
        if (zframe_streq (status, "500")) {
            printf ("E: server fatal error, aborting\n");
            exit (EXIT_FAILURE);
        }
    }
    else
        exit (EXIT_SUCCESS);    //  Interrupted or failed

    zmsg_destroy (&amp;reply);
    return NULL;        //  Didn't succeed, don't care why not
}
</programlisting>

</example>
<para>The main task tests our service call by sending an echo request: 
</para>

<example id="ticlient-c-1">
<title>Titanic client example (ticlient.c) - main task</title>
<programlisting language="c">

int main (int argc, char *argv [])
{
    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], "-v"));
    mdcli_t *session = mdcli_new ("tcp://localhost:5555", verbose);

    //  1. Send 'echo' request to Titanic
    zmsg_t *request = zmsg_new ();
    zmsg_addstr (request, "echo");
    zmsg_addstr (request, "Hello world");
    zmsg_t *reply = s_service_call (
        session, "titanic.request", &amp;request);

    zframe_t *uuid = NULL;
    if (reply) {
        uuid = zmsg_pop (reply);
        zmsg_destroy (&amp;reply);
        zframe_print (uuid, "I: request UUID ");
    }

    //  2. Wait until we get a reply
    while (!zctx_interrupted) {
        zclock_sleep (100);
        request = zmsg_new ();
        zmsg_add (request, zframe_dup (uuid));
        zmsg_t *reply = s_service_call (
            session, "titanic.reply", &amp;request);

        if (reply) {
            char *reply_string = zframe_strdup (zmsg_last (reply));
            printf ("Reply: %s\n", reply_string);
            free (reply_string);
            zmsg_destroy (&amp;reply);

            //  3. Close request
            request = zmsg_new ();
            zmsg_add (request, zframe_dup (uuid));
            reply = s_service_call (session, "titanic.close", &amp;request);
            zmsg_destroy (&amp;reply);
            break;
        }
        else {
            printf ("I: no reply yet, trying again...\n");
            zclock_sleep (5000);     //  Try again in 5 seconds
        }
    }
    zframe_destroy (&amp;uuid);
    mdcli_destroy (&amp;session);
    return 0;
}
</programlisting>

</example>
<para>Of course this can and in practice would be wrapped up in some kind of framework. Real application developers should never see messaging up close, it's a tool for more technically-minded experts to build frameworks and APIs. If we had infinite time to explore this, I'd make a TSP API example, and bring the client application back down to a few lines of code. But it's the same principle as we saw for MDP, no need to be repetitive.</para>

<para>Here's the Titanic implementation. This server handles the three services using three threads, as proposed. It does full persistence to disk using the most brute-force approach possible: one file per message. It's so simple it's scary, the only complex part is that it keeps a separate 'queue' of all requests to avoid reading the directory over and over:</para>

<example id="titanic-c">
<title>Titanic broker example (titanic.c)</title>
<programlisting language="c">
//
//  Titanic service
//
//  Implements server side of http://rfc.zeromq.org/spec:9

//  Lets us build this source without creating a library
#include "mdwrkapi.c"
#include "mdcliapi.c"

#include "zfile.h"
#include &lt;uuid/uuid.h&gt;

//  Return a new UUID as a printable character string
//  Caller must free returned string when finished with it

static char *
s_generate_uuid (void)
{
    char hex_char [] = "0123456789ABCDEF";
    char *uuidstr = zmalloc (sizeof (uuid_t) * 2 + 1);
    uuid_t uuid;
    uuid_generate (uuid);
    int byte_nbr;
    for (byte_nbr = 0; byte_nbr &lt; sizeof (uuid_t); byte_nbr++) {
        uuidstr [byte_nbr * 2 + 0] = hex_char [uuid [byte_nbr] &gt;&gt; 4];
        uuidstr [byte_nbr * 2 + 1] = hex_char [uuid [byte_nbr] &amp; 15];
    }
    return uuidstr;
}

//  Returns freshly allocated request filename for given UUID

#define TITANIC_DIR ".titanic"

static char *
s_request_filename (char *uuid) {
    char *filename = malloc (256);
    snprintf (filename, 256, TITANIC_DIR "/%s.req", uuid);
    return filename;
}

//  Returns freshly allocated reply filename for given UUID

static char *
s_reply_filename (char *uuid) {
    char *filename = malloc (256);
    snprintf (filename, 256, TITANIC_DIR "/%s.rep", uuid);
    return filename;
}
</programlisting>

</example>
<para>The "titanic.request" task waits for requests to this service. It writes each request to disk and returns a UUID to the client. The client picks up the reply asynchronously using the "titanic.reply" service: 
</para>

<example id="titanic-c-1">
<title>Titanic broker example (titanic.c) - Titanic request service</title>
<programlisting language="c">


static void
titanic_request (void *args, zctx_t *ctx, void *pipe)
{
    mdwrk_t *worker = mdwrk_new (
        "tcp://localhost:5555", "titanic.request", 0);
    zmsg_t *reply = NULL;

    while (true) {
        //  Send reply if it's not null
        //  And then get next request from broker
        zmsg_t *request = mdwrk_recv (worker, &amp;reply);
        if (!request)
            break;      //  Interrupted, exit

        //  Ensure message directory exists
        zfile_mkdir (TITANIC_DIR);

        //  Generate UUID and save message to disk
        char *uuid = s_generate_uuid ();
        char *filename = s_request_filename (uuid);
        FILE *file = fopen (filename, "w");
        assert (file);
        zmsg_save (request, file);
        fclose (file);
        free (filename);
        zmsg_destroy (&amp;request);

        //  Send UUID through to message queue
        reply = zmsg_new ();
        zmsg_addstr (reply, uuid);
        zmsg_send (&amp;reply, pipe);

        //  Now send UUID back to client
        //  Done by the mdwrk_recv() at the top of the loop
        reply = zmsg_new ();
        zmsg_addstr (reply, "200");
        zmsg_addstr (reply, uuid);
        free (uuid);
    }
    mdwrk_destroy (&amp;worker);
}
</programlisting>

</example>
<para>The "titanic.reply" task checks if there's a reply for the specified request (by UUID), and returns a 200 OK, 300 Pending, or 400 Unknown accordingly: 
</para>

<example id="titanic-c-2">
<title>Titanic broker example (titanic.c) - Titanic reply service</title>
<programlisting language="c">


static void *
titanic_reply (void *context)
{
    mdwrk_t *worker = mdwrk_new (
        "tcp://localhost:5555", "titanic.reply", 0);
    zmsg_t *reply = NULL;

    while (true) {
        zmsg_t *request = mdwrk_recv (worker, &amp;reply);
        if (!request)
            break;      //  Interrupted, exit

        char *uuid = zmsg_popstr (request);
        char *req_filename = s_request_filename (uuid);
        char *rep_filename = s_reply_filename (uuid);
        if (zfile_exists (rep_filename)) {
            FILE *file = fopen (rep_filename, "r");
            assert (file);
            reply = zmsg_load (NULL, file);
            zmsg_pushstr (reply, "200");
            fclose (file);
        }
        else {
            reply = zmsg_new ();
            if (zfile_exists (req_filename))
                zmsg_pushstr (reply, "300"); //Pending
            else
                zmsg_pushstr (reply, "400"); //Unknown
        }
        zmsg_destroy (&amp;request);
        free (uuid);
        free (req_filename);
        free (rep_filename);
    }
    mdwrk_destroy (&amp;worker);
    return 0;
}
</programlisting>

</example>
<para>The "titanic.close" task removes any waiting replies for the request (specified by UUID). It's idempotent, so safe to call more than once in a row: 
</para>

<example id="titanic-c-3">
<title>Titanic broker example (titanic.c) - Titanic close task</title>
<programlisting language="c">


static void *
titanic_close (void *context)
{
    mdwrk_t *worker = mdwrk_new (
        "tcp://localhost:5555", "titanic.close", 0);
    zmsg_t *reply = NULL;

    while (true) {
        zmsg_t *request = mdwrk_recv (worker, &amp;reply);
        if (!request)
            break;      //  Interrupted, exit

        char *uuid = zmsg_popstr (request);
        char *req_filename = s_request_filename (uuid);
        char *rep_filename = s_reply_filename (uuid);
        zfile_delete (req_filename);
        zfile_delete (rep_filename);
        free (uuid);
        free (req_filename);
        free (rep_filename);

        zmsg_destroy (&amp;request);
        reply = zmsg_new ();
        zmsg_addstr (reply, "200");
    }
    mdwrk_destroy (&amp;worker);
    return 0;
}
</programlisting>

</example>
<para>This is the main thread for the Titanic worker. It starts three child threads; for the request, reply, and close services. It then dispatches requests to workers using a simple brute-force disk queue. It receives request UUIDs from the titanic.request service, saves these to a disk file, and then throws each request at MDP workers until it gets a response: 
</para>

<example id="titanic-c-4">
<title>Titanic broker example (titanic.c) - worker task</title>
<programlisting language="c">


static int s_service_success (char *uuid);

int main (int argc, char *argv [])
{
    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], "-v"));
    zctx_t *ctx = zctx_new ();

    void *request_pipe = zthread_fork (ctx, titanic_request, NULL);
    zthread_new (titanic_reply, NULL);
    zthread_new (titanic_close, NULL);

    //  Main dispatcher loop
    while (true) {
        //  We'll dispatch once per second, if there's no activity
        zmq_pollitem_t items [] = { { request_pipe, 0, ZMQ_POLLIN, 0 } };
        int rc = zmq_poll (items, 1, 1000 * ZMQ_POLL_MSEC);
        if (rc == -1)
            break;              //  Interrupted
        if (items [0].revents &amp; ZMQ_POLLIN) {
            //  Ensure message directory exists
            zfile_mkdir (TITANIC_DIR);

            //  Append UUID to queue, prefixed with '-' for pending
            zmsg_t *msg = zmsg_recv (request_pipe);
            if (!msg)
                break;          //  Interrupted
            FILE *file = fopen (TITANIC_DIR "/queue", "a");
            char *uuid = zmsg_popstr (msg);
            fprintf (file, "-%s\n", uuid);
            fclose (file);
            free (uuid);
            zmsg_destroy (&amp;msg);
        }
        //  Brute-force dispatcher
        char entry [] = "?.......:.......:.......:.......:";
        FILE *file = fopen (TITANIC_DIR "/queue", "r+");
        while (file &amp;&amp; fread (entry, 33, 1, file) == 1) {
            //  UUID is prefixed with '-' if still waiting
            if (entry [0] == '-') {
                if (verbose)
                    printf ("I: processing request %s\n", entry + 1);
                if (s_service_success (entry + 1)) {
                    //  Mark queue entry as processed
                    fseek (file, -33, SEEK_CUR);
                    fwrite ("+", 1, 1, file);
                    fseek (file, 32, SEEK_CUR);
                }
            }
            //  Skip end of line, LF or CRLF
            if (fgetc (file) == '\r')
                fgetc (file);
            if (zctx_interrupted)
                break;
        }
        if (file)
            fclose (file);
    }
    return 0;
}
</programlisting>

</example>
<para>Here we first check if the requested MDP service is defined or not, using a MMI lookup to the Majordomo broker. If the service exists we send a request and wait for a reply using the conventional MDP client API. This is not meant to be fast, just very simple: 
</para>

<example id="titanic-c-5">
<title>Titanic broker example (titanic.c) - try to call a service</title>
<programlisting language="c">

static int
s_service_success (char *uuid)
{
    //  Load request message, service will be first frame
    char *filename = s_request_filename (uuid);
    FILE *file = fopen (filename, "r");
    free (filename);

    //  If the client already closed request, treat as successful
    if (!file)
        return 1;

    zmsg_t *request = zmsg_load (NULL, file);
    fclose (file);
    zframe_t *service = zmsg_pop (request);
    char *service_name = zframe_strdup (service);

    //  Create MDP client session with short timeout
    mdcli_t *client = mdcli_new ("tcp://localhost:5555", FALSE);
    mdcli_set_timeout (client, 1000);  //  1 sec
    mdcli_set_retries (client, 1);     //  only 1 retry

    //  Use MMI protocol to check if service is available
    zmsg_t *mmi_request = zmsg_new ();
    zmsg_add (mmi_request, service);
    zmsg_t *mmi_reply = mdcli_send (client, "mmi.service", &amp;mmi_request);
    int service_ok = (mmi_reply
        &amp;&amp; zframe_streq (zmsg_first (mmi_reply), "200"));
    zmsg_destroy (&amp;mmi_reply);

    int result = 0;
    if (service_ok) {
        zmsg_t *reply = mdcli_send (client, service_name, &amp;request);
        if (reply) {
            filename = s_reply_filename (uuid);
            FILE *file = fopen (filename, "w");
            assert (file);
            zmsg_save (reply, file);
            fclose (file);
            free (filename);
            result = 1;
        }
        zmsg_destroy (&amp;reply);
    }
    else
        zmsg_destroy (&amp;request);

    mdcli_destroy (&amp;client);
    free (service_name);
    return result;
}
</programlisting>

</example>
<para>To test this, start <literal>mdbroker</literal> and <literal>titanic</literal>, then run <literal>ticlient</literal>. Now start <literal>mdworker</literal> arbitrarily, and you should see the client getting a response and exiting happily.</para>

<para>Some notes about this code:</para>

<itemizedlist>
  <listitem><para>We use MMI to only send requests to services that appear to be running. This works as well as the MMI implementation in the broker.</para></listitem>
  <listitem><para>We use an inproc connection to send new request data from the <emphasis role="bold">titanic.request</emphasis> service through to the main dispatcher. This saves the dispatcher from having to scan the disk directory, load all request files, and sort them by date/time.</para></listitem>
</itemizedlist>
<para>The important thing about this example is not performance (which is surely terrible, I've not tested it), but how well it implements the reliability contract. To try it, start the mdbroker and titanic programs. Then start the ticlient, and then start the mdworker echo service. You can run all four of these using the '-v' option to do verbose tracing of activity. You can stop and restart any piece <emphasis>except</emphasis> the client and nothing will get lost.</para>

<para>If you want to use Titanic in real cases, you'll rapidly be asking "how do we make this faster?" Here's what I'd do, starting with the example implementation:</para>

<itemizedlist>
  <listitem><para>Use a single disk file for all data, rather than multiple files. Operating systems are usually better at handling a few large files than many smaller ones.</para></listitem>
  <listitem><para>Organize that disk file as a circular buffer so that new requests can be written contiguously (with very occasional wraparound). One thread, writing full speed to a disk file can work rapidly.</para></listitem>
  <listitem><para>Keep the index in memory and rebuild the index at startup time, from the disk buffer. This saves the extra disk head flutter needed to keep the index fully safe on disk. You would want an fsync after every message, or every N milliseconds if you were prepared to lose the last M messages in case of a system failure.</para></listitem>
  <listitem><para>Use a solid-state drive rather than spinning iron oxide platters.</para></listitem>
  <listitem><para>Preallocate the entire file, or allocate in large chunks allowing the circular buffer to grow and shrink as needed. This avoids fragmentation and ensures most reads and writes are contiguous.</para></listitem>
</itemizedlist>
<para>And so on. What I'd not recommend is storing messages in a database, not even a 'fast' key/value store, unless you really like a specific database and don't have performance worries. You will pay a steep price for the abstraction, 10 to 1000x over a raw disk file.</para>

<para>If you want to make Titanic <emphasis>even more reliable</emphasis>, you can do this by duplicating requests to a second server, which you'd place in a second location just far enough to survive nuclear attack on your primary location, yet not so far that you get too much latency.</para>

<para>If you want to make Titanic <emphasis>much faster and less reliable</emphasis>, you can store requests and replies purely in memory. This will give you the functionality of a disconnected network, but it won't survive a crash of the Titanic server itself.</para>

</sect1>
<sect1>
<title>High-availability Pair (Binary Star Pattern)</title>
<sect2>
<title>Overview</title>
<para>The Binary Star pattern puts two servers in a primary-backup high-availability pair(<xref linkend="figure-58"/>). At any given time, one of these accepts connections from client applications (it is the "master") and one does not (it is the "slave"). Each server monitors the other. If the master disappears from the network, after a certain time the slave takes over as master.</para>

<para>Binary Star pattern was developed by Pieter Hintjens and Martin Sustrik for the iMatix <ulink url="http://www.openamq.org">OpenAMQ server</ulink>. We designed it:</para>

<itemizedlist>
  <listitem><para>To provide a straight-forward high-availability solution.</para></listitem>
  <listitem><para>To be simple enough to actually understand and use.</para></listitem>
  <listitem><para>To fail-over reliably when needed, and only when needed.</para></listitem>
</itemizedlist>
<figure id="figure-58">
    <title>High-availability Pair, Normal Operation</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig58.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>Assuming we have a Binary Star pair running, here are the different scenarios that will result in fail-over happening(<xref linkend="figure-59"/>):</para>

<orderedlist>
  <listitem><para>The hardware running the primary server has a fatal problem (power supply explodes, machine catches fire, or someone simply unplugs it by mistake), and disappears. Applications see this, and reconnect to the backup server.</para></listitem>
  <listitem><para>The network segment on which the primary server sits crashes - perhaps a router gets hit by a power spike - and applications start to reconnect to the backup server.</para></listitem>
  <listitem><para>The primary server crashes or is killed by the operator and does not restart automatically.</para></listitem>
</orderedlist>
<figure id="figure-59">
    <title>High-availability Pair During Failover</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig59.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>Recovery from fail-over works as follows:</para>

<orderedlist>
  <listitem><para>The operators restart the primary server and fix whatever problems were causing it to disappear from the network.</para></listitem>
  <listitem><para>The operators stop the backup server, at a moment that will cause minimal disruption to applications.</para></listitem>
  <listitem><para>When applications have reconnected to the primary server, the operators restart the backup server.</para></listitem>
</orderedlist>
<para>Recovery (to using the primary server as master) is a manual operation. Painful experience teaches us that automatic recovery is undesirable. There are several reasons:</para>

<itemizedlist>
  <listitem><para>Failover creates an interruption of service to applications, possibly lasting 10-30 seconds. If there is a real emergency, this is much better than total outage. But if recovery creates a further 10-30 second outage, it is better that this happens off-peak, when users have gone off the network.</para></listitem>
  <listitem><para>When there is an emergency, it's a Good Idea to create predictability for those trying to fix things. Automatic recovery creates uncertainty for system admins, who can no longer be sure which server is in charge without double-checking.</para></listitem>
  <listitem><para>Last, you can get situations with automatic recovery where networks will fail over, and then recover, and operators are then placed in a difficult position to analyze what happened. There was an interruption of service, but the cause isn't clear.</para></listitem>
</itemizedlist>
<para>Having said this, the Binary Star pattern will fail back to the primary server if this is running (again) and the backup server fails. In fact this is how we provoke recovery.</para>

<para>The shutdown process for a Binary Star pair is to either:</para>

<orderedlist>
  <listitem><para>Stop the passive server and then stop the active server at any later time, or</para></listitem>
  <listitem><para>Stop both servers in any order but within a few seconds of each other.</para></listitem>
</orderedlist>
<para>Stopping the active and then the passive server with any delay longer than the fail-over timeout will cause applications to disconnect, then reconnect, then disconnect again, which may disturb users.</para>

</sect2>
<sect2>
<title>Detailed Requirements</title>
<para>Binary Star is as simple as it can be, while still working accurately. In fact the current design is the third complete redesign. Each of the previous designs we found to be too complex, trying to do too much, and we stripped out functionality until we came to a design that was understandable and use, and reliable enough to be worth using.</para>

<para>These are our requirements for a high-availability architecture:</para>

<itemizedlist>
  <listitem><para>The fail-over is meant to provide insurance against catastrophic system failures, such as hardware breakdown, fire, accident, etc. To guard against ordinary server crashes there are simpler ways to recover.</para></listitem>
  <listitem><para>Failover time should be under 60 seconds and preferably under 10 seconds.</para></listitem>
  <listitem><para>Failover has to happen automatically, whereas recover must happen manually. We want applications to switch over to the backup server automatically but we do not want them to switch back to the primary server except when the operators have fixed whatever problem there was, and decided that it is a good time to interrupt applications again.</para></listitem>
  <listitem><para>The semantics for client applications should be simple and easy for developers to understand. Ideally they should be hidden in the client API.</para></listitem>
  <listitem><para>There should be clear instructions for network architects on how to avoid designs that could lead to split brain syndrome in which both servers in a Binary Star pair think they are the master server.</para></listitem>
  <listitem><para>There should be no dependencies on the order in which the two servers are started.</para></listitem>
  <listitem><para>It must be possible to make planned stops and restarts of either server without stopping client applications (though they may be forced to reconnect).</para></listitem>
  <listitem><para>Operators must be able to monitor both servers at all times.</para></listitem>
  <listitem><para>It must be possible to connect the two servers using a high-speed dedicated network connection. That is, fail-over synchronization must be able to use a specific IP route.</para></listitem>
</itemizedlist>
<para>We make these assumptions:</para>

<itemizedlist>
  <listitem><para>A single backup server provides enough insurance, we don't need multiple levels of backup.</para></listitem>
  <listitem><para>The primary and backup servers are equally capable of carrying the application load. We do not attempt to balance load across the servers.</para></listitem>
  <listitem><para>There is sufficient budget to cover a fully redundant backup server that does nothing almost all the time.</para></listitem>
</itemizedlist>
<para>We don't attempt to cover:</para>

<itemizedlist>
  <listitem><para>The use of an active backup server or load balancing. In a Binary Star pair, the backup server is inactive and does no useful work until the primary server goes off-line.</para></listitem>
  <listitem><para>The handling of persistent messages or transactions in any way. We assuming a network of unreliable (and probably untrusted) servers or Binary Star pairs.</para></listitem>
  <listitem><para>Any automatic exploration of the network. The Binary Star pair is manually and explicitly defined in the network and is known to applications (at least in their configuration data).</para></listitem>
  <listitem><para>Replication of state or messages between servers. All server-side state much be recreated by applications when they fail over.</para></listitem>
</itemizedlist>
<para>Here is the key terminology we use in Binary Star:</para>

<itemizedlist>
  <listitem><para><emphasis role="bold">Primary</emphasis> - the primary server is the one that is normally 'master'.</para></listitem>
  <listitem><para><emphasis role="bold">Backup</emphasis> - the backup server is the one that is normally 'slave', it will become master if and when the primary server disappears from the network, and when client applications ask the backup server to connect.</para></listitem>
  <listitem><para><emphasis role="bold">Master</emphasis> - the master server is the one of a Binary Star pair that accepts client connections. There is at most one master server.</para></listitem>
  <listitem><para><emphasis role="bold">Slave</emphasis> - the slave server is the one that takes over if the master disappears. Note that when a Binary Star pair is running normally, the primary server is master, and the backup is slave. When a fail-over has happened, the roles are switched.</para></listitem>
</itemizedlist>
<para>To configure a Binary Star pair, you need to:</para>

<orderedlist>
  <listitem><para>Tell the primary server where the backup server is.</para></listitem>
  <listitem><para>Tell the backup server where the primary server is.</para></listitem>
  <listitem><para>Optionally, tune the fail-over response times, which must be the same for both servers.</para></listitem>
</orderedlist>
<para>The main tuning concern is how frequently you want the servers to check their peering status, and how quickly you want to activate fail-over. In our example, the fail-over timeout value defaults to 2000 msec. If you reduce this, the backup server will take over as master more rapidly but may take over in cases where the primary server could recover. You may for example have wrapped the primary server in a shell script that restarts it if it crashes. In that case the timeout should be higher than the time needed to restart the primary server.</para>

<para>For client applications to work properly with a Binary Star pair, they must:</para>

<orderedlist>
  <listitem><para>Know both server addresses.</para></listitem>
  <listitem><para>Try to connect to the primary server, and if that fails, to the backup server.</para></listitem>
  <listitem><para>Detect a failed connection, typically using heartbeating.</para></listitem>
  <listitem><para>Try to reconnect to primary, and then backup, with a delay between retries that is at least as high as the server fail-over timeout.</para></listitem>
  <listitem><para>Recreate all of the state they require on a server.</para></listitem>
  <listitem><para>Retransmit messages lost during a fail-over, if messages need to be reliable.</para></listitem>
</orderedlist>
<para>It's not trivial work, and we'd usually wrap this in an API that hides it from real end-user applications.</para>

<para>These are the main limitations of the Binary Star pattern:</para>

<itemizedlist>
  <listitem><para>A server process cannot be part of more than one Binary Star pair.</para></listitem>
  <listitem><para>A primary server can have a single backup server, no more.</para></listitem>
  <listitem><para>The backup server cannot do useful work while in slave mode.</para></listitem>
  <listitem><para>The backup server must be capable of handling full application loads.</para></listitem>
  <listitem><para>Failover configuration cannot be modified at runtime.</para></listitem>
  <listitem><para>Client applications must do some work to benefit from fail-over.</para></listitem>
</itemizedlist>
</sect2>
<sect2>
<title>Preventing Split-Brain Syndrome</title>
<para>"Split-brain syndrome" is when different parts of a cluster think they are 'master' at the same time. It causes applications to stop seeing each other. Binary Star has an algorithm for detecting and eliminating split brain, based on a three-way decision mechanism (a server will not decide to become master until it gets application connection requests and it cannot see its peer server).</para>

<para>However it is still possible to (mis)design a network to fool this algorithm. A typical scenario would a Binary Star pair distributed between two buildings, where each building also had a set of applications, and there was a single network link between both buildings. Breaking this link would create two sets of client applications, each with half of the Binary Star pair, and each fail-over server would become active.</para>

<para>To prevent split-brain situations, we <emphasis>MUST</emphasis> connect Binary Star pairs using a dedicated network link, which can be as simple as plugging them both into the same switch or better, using a cross-over cable directly between two machines.</para>

<para>We must not split a Binary Star architecture into two islands, each with a set of applications. While this may be a common type of network architecture, we'd use federation, not high-availability fail-over, in such cases.</para>

<para>A suitably paranoid network configuration would use two private cluster interconnects, rather than a single one. Further, the network cards used for the cluster would be different to those used for message in/out, and possibly even on different PCI paths on the server hardware. The goal being to separate possible failures in the network from possible failures in the cluster. Network ports have a relatively high failure rate.</para>

</sect2>
<sect2>
<title>Binary Star Implementation</title>
<para>Without further ado, here is a proof-of-concept implementation of the Binary Star server:</para>

<example id="bstarsrv-c">
<title>Binary Star server (bstarsrv.c)</title>
<programlisting language="c">
//
//  Binary Star server proof-of-concept implementation. This server does no
//  real work; it just demonstrates the Binary Star failover model.

#include "czmq.h"

//  States we can be in at any point in time
typedef enum {
    STATE_PRIMARY = 1,          //  Primary, waiting for peer to connect
    STATE_BACKUP = 2,           //  Backup, waiting for peer to connect
    STATE_ACTIVE = 3,           //  Active - accepting connections
    STATE_PASSIVE = 4           //  Passive - not accepting connections
} state_t;

//  Events, which start with the states our peer can be in
typedef enum {
    PEER_PRIMARY = 1,           //  HA peer is pending primary
    PEER_BACKUP = 2,            //  HA peer is pending backup
    PEER_ACTIVE = 3,            //  HA peer is active
    PEER_PASSIVE = 4,           //  HA peer is passive
    CLIENT_REQUEST = 5          //  Client makes request
} event_t;

//  Our finite state machine
typedef struct {
    state_t state;              //  Current state
    event_t event;              //  Current event
    int64_t peer_expiry;        //  When peer is considered 'dead'
} bstar_t;

//  We send state information every this often
//  If peer doesn't respond in two heartbeats, it is 'dead'
#define HEARTBEAT 1000          //  In msecs
</programlisting>

</example>
<para>The heart of the Binary Star design is its finite-state machine (FSM). The FSM runs one event at a time. We apply an event to the current state, which checks if the event is accepted, and if so sets a new state: 
</para>

<example id="bstarsrv-c-1">
<title>Binary Star server (bstarsrv.c) - Binary Star state machine</title>
<programlisting language="c">

static Bool
s_state_machine (bstar_t *fsm)
{
    Bool exception = FALSE;
    
    //  These are the PRIMARY and BACKUP states; we're waiting to become
    //  ACTIVE or PASSIVE depending on events we get from our peer:
    if (fsm-&gt;state == STATE_PRIMARY) {
        if (fsm-&gt;event == PEER_BACKUP) {
            printf ("I: connected to backup (slave), ready as master\n");
            fsm-&gt;state = STATE_ACTIVE;
        }
        else
        if (fsm-&gt;event == PEER_ACTIVE) {
            printf ("I: connected to backup (master), ready as slave\n");
            fsm-&gt;state = STATE_PASSIVE;
        }
        //  Accept client connections
    }
    else
    if (fsm-&gt;state == STATE_BACKUP) {
        if (fsm-&gt;event == PEER_ACTIVE) {
            printf ("I: connected to primary (master), ready as slave\n");
            fsm-&gt;state = STATE_PASSIVE;
        }
        else
        //  Reject client connections when acting as backup
        if (fsm-&gt;event == CLIENT_REQUEST)
            exception = TRUE;
    }
    else
</programlisting>

</example>
<para>These are the ACTIVE and PASSIVE states: 
</para>

<example id="bstarsrv-c-2">
<title>Binary Star server (bstarsrv.c) - active and passive states</title>
<programlisting language="c">
    if (fsm-&gt;state == STATE_ACTIVE) {
        if (fsm-&gt;event == PEER_ACTIVE) {
            //  Two masters would mean split-brain
            printf ("E: fatal error - dual masters, aborting\n");
            exception = TRUE;
        }
    }
    else
    //  Server is passive
    //  CLIENT_REQUEST events can trigger failover if peer looks dead
    if (fsm-&gt;state == STATE_PASSIVE) {
        if (fsm-&gt;event == PEER_PRIMARY) {
            //  Peer is restarting - become active, peer will go passive
            printf ("I: primary (slave) is restarting, ready as master\n");
            fsm-&gt;state = STATE_ACTIVE;
        }
        else
        if (fsm-&gt;event == PEER_BACKUP) {
            //  Peer is restarting - become active, peer will go passive
            printf ("I: backup (slave) is restarting, ready as master\n");
            fsm-&gt;state = STATE_ACTIVE;
        }
        else
        if (fsm-&gt;event == PEER_PASSIVE) {
            //  Two passives would mean cluster would be non-responsive
            printf ("E: fatal error - dual slaves, aborting\n");
            exception = TRUE;
        }
        else
        if (fsm-&gt;event == CLIENT_REQUEST) {
            //  Peer becomes master if timeout has passed
            //  It's the client request that triggers the failover
            assert (fsm-&gt;peer_expiry &gt; 0);
            if (zclock_time () &gt;= fsm-&gt;peer_expiry) {
                //  If peer is dead, switch to the active state
                printf ("I: failover successful, ready as master\n");
                fsm-&gt;state = STATE_ACTIVE;
            }
            else
                //  If peer is alive, reject connections
                exception = TRUE;
        }
    }
    return exception;
}
</programlisting>

</example>
<para>This is our main task. First we bind/connect our sockets with our peer and make sure we will get state messages correctly. We use three sockets; one to publish state, one to subscribe to state, and one for client requests/replies: 
</para>

<example id="bstarsrv-c-3">
<title>Binary Star server (bstarsrv.c) - main task</title>
<programlisting language="c">


int main (int argc, char *argv [])
{
    //  Arguments can be either of:
    //      -p  primary server, at tcp://localhost:5001
    //      -b  backup server, at tcp://localhost:5002
    zctx_t *ctx = zctx_new ();
    void *statepub = zsocket_new (ctx, ZMQ_PUB);
    void *statesub = zsocket_new (ctx, ZMQ_SUB);
    zsockopt_set_subscribe (statesub, "");
    void *frontend = zsocket_new (ctx, ZMQ_ROUTER);
    bstar_t fsm = { 0 };

    if (argc == 2 &amp;&amp; streq (argv [1], "-p")) {
        printf ("I: Primary master, waiting for backup (slave)\n");
        zsocket_bind (frontend, "tcp://*:5001");
        zsocket_bind (statepub, "tcp://*:5003");
        zsocket_connect (statesub, "tcp://localhost:5004");
        fsm.state = STATE_PRIMARY;
    }
    else
    if (argc == 2 &amp;&amp; streq (argv [1], "-b")) {
        printf ("I: Backup slave, waiting for primary (master)\n");
        zsocket_bind (frontend, "tcp://*:5002");
        zsocket_bind (statepub, "tcp://*:5004");
        zsocket_connect (statesub, "tcp://localhost:5003");
        fsm.state = STATE_BACKUP;
    }
    else {
        printf ("Usage: bstarsrv { -p | -b }\n");
        zctx_destroy (&amp;ctx);
        exit (0);
    }
</programlisting>

</example>
<para>We now process events on our two input sockets, and process these events one at a time via our finite-state machine. Our "work" for a client request is simply to echo it back: 
</para>

<example id="bstarsrv-c-4">
<title>Binary Star server (bstarsrv.c) - handling socket input</title>
<programlisting language="c">
    //  Set timer for next outgoing state message
    int64_t send_state_at = zclock_time () + HEARTBEAT;
    while (!zctx_interrupted) {
        zmq_pollitem_t items [] = {
            { frontend, 0, ZMQ_POLLIN, 0 },
            { statesub, 0, ZMQ_POLLIN, 0 }
        };
        int time_left = (int) ((send_state_at - zclock_time ()));
        if (time_left &lt; 0)
            time_left = 0;
        int rc = zmq_poll (items, 2, time_left * ZMQ_POLL_MSEC);
        if (rc == -1)
            break;              //  Context has been shut down

        if (items [0].revents &amp; ZMQ_POLLIN) {
            //  Have a client request
            zmsg_t *msg = zmsg_recv (frontend);
            fsm.event = CLIENT_REQUEST;
            if (s_state_machine (&amp;fsm) == FALSE)
                //  Answer client by echoing request back
                zmsg_send (&amp;msg, frontend);
            else
                zmsg_destroy (&amp;msg);
        }
        if (items [1].revents &amp; ZMQ_POLLIN) {
            //  Have state from our peer, execute as event
            char *message = zstr_recv (statesub);
            fsm.event = atoi (message);
            free (message);
            if (s_state_machine (&amp;fsm))
                break;          //  Error, so exit
            fsm.peer_expiry = zclock_time () + 2 * HEARTBEAT;
        }
        //  If we timed-out, send state to peer
        if (zclock_time () &gt;= send_state_at) {
            char message [2];
            sprintf (message, "%d", fsm.state);
            zstr_send (statepub, message);
            send_state_at = zclock_time () + HEARTBEAT;
        }
    }
    if (zctx_interrupted)
        printf ("W: interrupted\n");

    //  Shutdown sockets and context
    zctx_destroy (&amp;ctx);
    return 0;
}
</programlisting>

</example>
<para>And here is the client:</para>

<example id="bstarcli-c">
<title>Binary Star client (bstarcli.c)</title>
<programlisting language="c">
//
//  Binary Star client proof-of-concept implementation. This client does no
//  real work; it just demonstrates the Binary Star failover model.

#include "czmq.h"

#define REQUEST_TIMEOUT     1000    //  msecs
#define SETTLE_DELAY        2000    //  Before failing over

int main (void)
{
    zctx_t *ctx = zctx_new ();

    char *server [] = { "tcp://localhost:5001", "tcp://localhost:5002" };
    uint server_nbr = 0;

    printf ("I: connecting to server at %s...\n", server [server_nbr]);
    void *client = zsocket_new (ctx, ZMQ_REQ);
    zsocket_connect (client, server [server_nbr]);

    int sequence = 0;
    while (!zctx_interrupted) {
        //  We send a request, then we work to get a reply
        char request [10];
        sprintf (request, "%d", ++sequence);
        zstr_send (client, request);

        int expect_reply = 1;
        while (expect_reply) {
            //  Poll socket for a reply, with timeout
            zmq_pollitem_t items [] = { { client, 0, ZMQ_POLLIN, 0 } };
            int rc = zmq_poll (items, 1, REQUEST_TIMEOUT * ZMQ_POLL_MSEC);
            if (rc == -1)
                break;          //  Interrupted
</programlisting>

</example>
<para>We use a Lazy Pirate strategy in the client. If there's no reply within our timeout, we close the socket and try again. In Binary Star, it's the client vote which decides which server is primary; the client must therefore try to connect to each server in turn: 
</para>

<example id="bstarcli-c-1">
<title>Binary Star client (bstarcli.c) - main body of client</title>
<programlisting language="c">

            if (items [0].revents &amp; ZMQ_POLLIN) {
                //  We got a reply from the server, must match sequence
                char *reply = zstr_recv (client);
                if (atoi (reply) == sequence) {
                    printf ("I: server replied OK (%s)\n", reply);
                    expect_reply = 0;
                    sleep (1);  //  One request per second
                }
                else
                    printf ("E: bad reply from server: %s\n", reply);
                free (reply);
            }
            else {
                printf ("W: no response from server, failing over\n");
                
                //  Old socket is confused; close it and open a new one
                zsocket_destroy (ctx, client);
                server_nbr = (server_nbr + 1) % 2;
                zclock_sleep (SETTLE_DELAY);
                printf ("I: connecting to server at %s...\n",
                        server [server_nbr]);
                client = zsocket_new (ctx, ZMQ_REQ);
                zsocket_connect (client, server [server_nbr]);

                //  Send request again, on new socket
                zstr_send (client, request);
            }
        }
    }
    zctx_destroy (&amp;ctx);
    return 0;
}
</programlisting>

</example>
<para>To test Binary Star, start the servers and client in any order:</para>

<screen>bstarsrv -p     # Start primary
bstarsrv -b     # Start backup
bstarcli
</screen>

<para>You can then provoke fail-over by killing the primary server, and recovery by restarting the primary and killing the backup. Note how it's the client vote that triggers fail-over, and recovery.</para>

<para>Binary star is driven by a finite state machine(<xref linkend="figure-60"/>). States in green accept client requests, states in pink refuse them. Events are the peer state, so "Peer Active" means the other server has told us it's active. "Client Request" means we've received a client request. "Client Vote" means we've received a client request AND our peer is inactive for two heartbeats.</para>

<figure id="figure-60">
    <title>Binary Star Finite State Machine</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig60.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>Note that the servers use PUB-SUB sockets for state exchange. No other socket combination will work here. PUSH and DEALER block if there is no peer ready to receive a message. PAIR does not reconnect if the peer disappears and comes back. ROUTER needs the address of the peer before it can send it a message.</para>

<para>These are the main limitations of the Binary Star pattern:</para>

<itemizedlist>
  <listitem><para>A server process cannot be part of more than one Binary Star pair.</para></listitem>
  <listitem><para>A primary server can have a single backup server, no more.</para></listitem>
  <listitem><para>The backup server cannot do useful work while in slave mode.</para></listitem>
  <listitem><para>The backup server must be capable of handling full application loads.</para></listitem>
  <listitem><para>Failover configuration cannot be modified at runtime.</para></listitem>
  <listitem><para>Client applications must do some work to benefit from fail-over.</para></listitem>
</itemizedlist>
</sect2>
<sect2>
<title>Binary Star Reactor</title>
<para>Binary Star is useful and generic enough to package up as a reusable reactor class. The reactor then runs and calls our code whenever it has a message to process. This is much nicer than copying/pasting the Binary Star code into each server where we want that capability. In C we wrap the CZMQ <literal>zloop</literal> class, though your mileage may vary in other languages. Here is the <literal>bstar</literal> API:</para>

<programlisting language="c">
//  Create a new Binary Star instance, using local (bind) and
//  remote (connect) endpoints to set-up the server peering.
bstar_t *bstar_new (int primary, char *local, char *remote);

//  Destroy a Binary Star instance
void bstar_destroy (bstar_t **self_p);

//  Return underlying zloop reactor, for timer and reader
//  registration and cancelation.
zloop_t *bstar_zloop (bstar_t *self);

//  Register voting reader
int bstar_voter (bstar_t *self, char *endpoint, int type,
                 zloop_fn handler, void *arg);

//  Register main state change handlers
void bstar_new_master (bstar_t *self, zloop_fn handler, void *arg);
void bstar_new_slave (bstar_t *self, zloop_fn handler, void *arg);

//  Start the reactor, ends if a callback function returns -1, or the
//  process received SIGINT or SIGTERM.
int bstar_start (bstar_t *self);
</programlisting>

<para>And here is the class implementation:</para>

<example id="bstar-c">
<title>Binary Star core class (bstar.c)</title>
<programlisting language="c">
/*  =====================================================================
 *  bstar - Binary Star reactor
 *  ===================================================================== */

#include "bstar.h"

//  States we can be in at any point in time
typedef enum {
    STATE_PRIMARY = 1,          //  Primary, waiting for peer to connect
    STATE_BACKUP = 2,           //  Backup, waiting for peer to connect
    STATE_ACTIVE = 3,           //  Active - accepting connections
    STATE_PASSIVE = 4           //  Passive - not accepting connections
} state_t;

//  Events, which start with the states our peer can be in
typedef enum {
    PEER_PRIMARY = 1,           //  HA peer is pending primary
    PEER_BACKUP = 2,            //  HA peer is pending backup
    PEER_ACTIVE = 3,            //  HA peer is active
    PEER_PASSIVE = 4,           //  HA peer is passive
    CLIENT_REQUEST = 5          //  Client makes request
} event_t;

//  Structure of our class

struct _bstar_t {
    zctx_t *ctx;                //  Our private context
    zloop_t *loop;              //  Reactor loop
    void *statepub;             //  State publisher
    void *statesub;             //  State subscriber
    state_t state;              //  Current state
    event_t event;              //  Current event
    int64_t peer_expiry;        //  When peer is considered 'dead'
    zloop_fn *voter_fn;         //  Voting socket handler
    void *voter_arg;            //  Arguments for voting handler
    zloop_fn *master_fn;        //  Call when become master
    void *master_arg;           //  Arguments for handler
    zloop_fn *slave_fn;         //  Call when become slave
    void *slave_arg;            //  Arguments for handler
};

//  The finite-state machine is the same as in the proof-of-concept server.
//  To understand this reactor in detail, first read the CZMQ zloop class.
...
</programlisting>

</example>
<para>This is the constructor for our bstar class. We have to tell it whether we're primary or backup server, and our local and remote endpoints to bind and connect to: 
</para>

<example id="bstar-c-1">
<title>Binary Star core class (bstar.c) - constructor</title>
<programlisting language="c">
bstar_t *
bstar_new (int primary, char *local, char *remote)
{
    bstar_t
        *self;

    self = (bstar_t *) zmalloc (sizeof (bstar_t));

    //  Initialize the Binary Star
    self-&gt;ctx = zctx_new ();
    self-&gt;loop = zloop_new ();
    self-&gt;state = primary? STATE_PRIMARY: STATE_BACKUP;

    //  Create publisher for state going to peer
    self-&gt;statepub = zsocket_new (self-&gt;ctx, ZMQ_PUB);
    zsocket_bind (self-&gt;statepub, local);

    //  Create subscriber for state coming from peer
    self-&gt;statesub = zsocket_new (self-&gt;ctx, ZMQ_SUB);
    zsockopt_set_subscribe (self-&gt;statesub, "");
    zsocket_connect (self-&gt;statesub, remote);

    //  Set-up basic reactor events
    zloop_timer (self-&gt;loop, BSTAR_HEARTBEAT, 0, s_send_state, self);
    zmq_pollitem_t poller = { self-&gt;statesub, 0, ZMQ_POLLIN };
    zloop_poller (self-&gt;loop, &amp;poller, s_recv_state, self);
    return self;
}
</programlisting>

</example>
<para>The destructor shuts down the bstar reactor: 
</para>

<example id="bstar-c-2">
<title>Binary Star core class (bstar.c) - destructor</title>
<programlisting language="c">


void
bstar_destroy (bstar_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        bstar_t *self = *self_p;
        zloop_destroy (&amp;self-&gt;loop);
        zctx_destroy (&amp;self-&gt;ctx);
        free (self);
        *self_p = NULL;
    }
}
</programlisting>

</example>
<para>The zloop method returns the underlying zloop reactor, so we can add additional timers and readers: 
</para>

<example id="bstar-c-3">
<title>Binary Star core class (bstar.c) - zloop method</title>
<programlisting language="c">


zloop_t *
bstar_zloop (bstar_t *self)
{
    return self-&gt;loop;
}
</programlisting>

</example>
<para>The voter method registers a client voter socket. Messages received on this socket provide the CLIENT_REQUEST events for the Binary Star FSM and are passed to the provided application handler. We require exactly one voter per bstar instance: 
</para>

<example id="bstar-c-4">
<title>Binary Star core class (bstar.c) - voter method</title>
<programlisting language="c">


int
bstar_voter (bstar_t *self, char *endpoint, int type, zloop_fn handler,
             void *arg)
{
    //  Hold actual handler+arg so we can call this later
    void *socket = zsocket_new (self-&gt;ctx, type);
    zsocket_bind (socket, endpoint);
    assert (!self-&gt;voter_fn);
    self-&gt;voter_fn = handler;
    self-&gt;voter_arg = arg;
    zmq_pollitem_t poller = { socket, 0, ZMQ_POLLIN };
    return zloop_poller (self-&gt;loop, &amp;poller, s_voter_ready, self);
}
</programlisting>

</example>
<para>Register handlers to be called each time there's a state change: 
</para>

<example id="bstar-c-5">
<title>Binary Star core class (bstar.c) - register state-change handlers</title>
<programlisting language="c">

void
bstar_new_master (bstar_t *self, zloop_fn handler, void *arg)
{
    assert (!self-&gt;master_fn);
    self-&gt;master_fn = handler;
    self-&gt;master_arg = arg;
}

void
bstar_new_slave (bstar_t *self, zloop_fn handler, void *arg)
{
    assert (!self-&gt;slave_fn);
    self-&gt;slave_fn = handler;
    self-&gt;slave_arg = arg;
}
</programlisting>

</example>
<para>Enable/disable verbose tracing, for debugging: 
</para>

<example id="bstar-c-6">
<title>Binary Star core class (bstar.c) - enable/disable tracing</title>
<programlisting language="c">

void bstar_set_verbose (bstar_t *self, Bool verbose)
{
    zloop_set_verbose (self-&gt;loop, verbose);
}
</programlisting>

</example>
<para>Finally, start the configured reactor. It will end if any handler returns -1 to the reactor, or if the process receives SIGINT or SIGTERM: 
</para>

<example id="bstar-c-7">
<title>Binary Star core class (bstar.c) - start the reactor</title>
<programlisting language="c">

int
bstar_start (bstar_t *self)
{
    assert (self-&gt;voter_fn);
    s_update_peer_expiry (self);
    return zloop_start (self-&gt;loop);
}
</programlisting>

</example>
<para>Which gives us the following short main program for the server:</para>

<example id="bstarsrv2-c">
<title>Binary Star server, using core class (bstarsrv2.c)</title>
<programlisting language="c">
//
//  Binary Star server, using bstar reactor
//

//  Lets us build this source without creating a library
#include "bstar.c"

//  Echo service
int s_echo (zloop_t *loop, zmq_pollitem_t *poller, void *arg)
{
    zmsg_t *msg = zmsg_recv (poller-&gt;socket);
    zmsg_send (&amp;msg, poller-&gt;socket);
    return 0;
}

int main (int argc, char *argv [])
{
    //  Arguments can be either of:
    //      -p  primary server, at tcp://localhost:5001
    //      -b  backup server, at tcp://localhost:5002
    bstar_t *bstar;
    if (argc == 2 &amp;&amp; streq (argv [1], "-p")) {
        printf ("I: Primary master, waiting for backup (slave)\n");
        bstar = bstar_new (BSTAR_PRIMARY,
            "tcp://*:5003", "tcp://localhost:5004");
        bstar_voter (bstar, "tcp://*:5001", ZMQ_ROUTER, s_echo, NULL);
    }
    else
    if (argc == 2 &amp;&amp; streq (argv [1], "-b")) {
        printf ("I: Backup slave, waiting for primary (master)\n");
        bstar = bstar_new (BSTAR_BACKUP,
            "tcp://*:5004", "tcp://localhost:5003");
        bstar_voter (bstar, "tcp://*:5002", ZMQ_ROUTER, s_echo, NULL);
    }
    else {
        printf ("Usage: bstarsrvs { -p | -b }\n");
        exit (0);
    }
    bstar_start (bstar);
    bstar_destroy (&amp;bstar);
    return 0;
}
</programlisting>

</example>
</sect2>
</sect1>
<sect1>
<title>Brokerless Reliability (Freelance Pattern)</title>
<para>It might seem ironic to focus so much on broker-based reliability, when we often explain &Oslash;MQ as "brokerless messaging". However in messaging, as in real life, the middleman is both a burden and a benefit. In practice, most messaging architectures benefit from a mix of distributed and brokered messaging. You get the best results when you can decide freely what tradeoffs you want to make. This is why I can drive 10km to a wholesaler to buy five cases of wine for a party, but I can also walk 10 minutes to a corner store to buy one bottle for a dinner. Our highly context-sensitive relative valuations of time, energy, and cost are essential to the real world economy. And they are essential to an optimal message-based architecture.</para>

<para>Which is why &Oslash;MQ does not <emphasis>impose</emphasis> a broker-centric architecture, though it gives you the tools to build brokers, aka "devices", and we've built a dozen or so different ones so far, just for practice.</para>

<para>So we'll end this chapter by deconstructing the broker-based reliability we've built so far, and turning it back into a distributed peer-to-peer architecture I call the Freelance pattern. Our use case will be a name resolution service. This is a common problem with &Oslash;MQ architectures: how do we know the endpoint to connect to? Hard-coding TCP/IP addresses in code is insanely fragile. Using configuration files creates an administration nightmare. Imagine if you had to hand-configure your web browser, on every PC or mobile phone you used, to realize that "google.com" was "74.125.230.82".</para>

<para>A &Oslash;MQ name service (and we'll make a simple implementation) has to:</para>

<itemizedlist>
  <listitem><para>Resolve a logical name into at least a bind endpoint, and a connect endpoint. A realistic name service would provide multiple bind endpoints, and possibly multiple connect endpoints too.</para></listitem>
  <listitem><para>Allow us to manage multiple parallel environments, e.g. "test" vs. "production" without modifying code.</para></listitem>
  <listitem><para>Be reliable, because if it is unavailable, applications won't be able to connect to the network.</para></listitem>
</itemizedlist>
<para>Putting a name service behind a service-oriented Majordomo broker is clever from some points of view. However it's simpler and much less surprising to just expose the name service as a server that clients can connect to directly. If we do this right, the name service becomes the <emphasis>only</emphasis> global network endpoint we need to hard-code in our code or configuration files.</para>

<para>The types of failure we aim to handle are server crashes and restarts, server busy looping, server overload, and network issues. To get reliability, we'll create a pool of name servers so if one crashes or goes away, clients can connect to another, and so on. In practice, two would be enough. But for the example, we'll assume the pool can be any size(<xref linkend="figure-61"/>).</para>

<figure id="figure-61">
    <title>The Freelance Pattern</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig61.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>In this architecture a large set of clients connect to a small set of servers directly. The servers bind to their respective addresses. It's fundamentally different from a broker-based approach like Majordomo, where workers connect to the broker. For clients, there are a couple of options:</para>

<itemizedlist>
  <listitem><para>Clients could use REQ sockets and the Lazy Pirate pattern. Easy, but would need some additional intelligence to not stupidly reconnect to dead servers over and over.</para></listitem>
  <listitem><para>Clients could use DEALER sockets and blast out requests (which will be load balanced to all connected servers) until they get a reply. Brutal, but not elegant.</para></listitem>
  <listitem><para>Clients could use ROUTER sockets so they can address specific servers. But how does the client know the identity of the server sockets? Either the server has to ping the client first (complex), or the each server has to use a hard-coded, fixed identity known to the client (nasty).</para></listitem>
</itemizedlist>
<sect2>
<title>Model One - Simple Retry and Failover</title>
<para>So our menu appears to offer: simple, brutal, complex, or nasty. Let's start with 'simple' and then work out the kinks. We take Lazy Pirate and rewrite it to work with multiple server endpoints. Start the server first, specifying a bind endpoint as argument. Run one or several servers:</para>

<example id="flserver1-c">
<title>Freelance server, Model One (flserver1.c)</title>
<programlisting language="c">
//
//  Freelance server - Model 1
//  Trivial echo service
//
#include "czmq.h"

int main (int argc, char *argv [])
{
    if (argc &lt; 2) {
        printf ("I: syntax: %s &lt;endpoint&gt;\n", argv [0]);
        exit (EXIT_SUCCESS);
    }
    zctx_t *ctx = zctx_new ();
    void *server = zsocket_new (ctx, ZMQ_REP);
    zsocket_bind (server, argv [1]);

    printf ("I: echo service is ready at %s\n", argv [1]);
    while (true) {
        zmsg_t *msg = zmsg_recv (server);
        if (!msg)
            break;          //  Interrupted
        zmsg_send (&amp;msg, server);
    }
    if (zctx_interrupted)
        printf ("W: interrupted\n");

    zctx_destroy (&amp;ctx);
    return 0;
}
</programlisting>

</example>
<para>Then start the client, specifying one or more connect endpoints as arguments:</para>

<example id="flclient1-c">
<title>Freelance client, Model One (flclient1.c)</title>
<programlisting language="c">
//
//  Freelance client - Model 1
//  Uses REQ socket to query one or more services
//
#include "czmq.h"

#define REQUEST_TIMEOUT     1000
#define MAX_RETRIES         3       //  Before we abandon

static zmsg_t *
s_try_request (zctx_t *ctx, char *endpoint, zmsg_t *request)
{
    printf ("I: trying echo service at %s...\n", endpoint);
    void *client = zsocket_new (ctx, ZMQ_REQ);
    zsocket_connect (client, endpoint);

    //  Send request, wait safely for reply
    zmsg_t *msg = zmsg_dup (request);
    zmsg_send (&amp;msg, client);
    zmq_pollitem_t items [] = { { client, 0, ZMQ_POLLIN, 0 } };
    zmq_poll (items, 1, REQUEST_TIMEOUT * ZMQ_POLL_MSEC);
    zmsg_t *reply = NULL;
    if (items [0].revents &amp; ZMQ_POLLIN)
        reply = zmsg_recv (client);

    //  Close socket in any case, we're done with it now
    zsocket_destroy (ctx, client);
    return reply;
}
</programlisting>

</example>
<para>The client uses a Lazy Pirate strategy if it only has one server to talk to. If it has 2 or more servers to talk to, it will try each server just once: 
</para>

<example id="flclient1-c-1">
<title>Freelance client, Model One (flclient1.c) - client task</title>
<programlisting language="c">

int main (int argc, char *argv [])
{
    zctx_t *ctx = zctx_new ();
    zmsg_t *request = zmsg_new ();
    zmsg_addstr (request, "Hello world");
    zmsg_t *reply = NULL;

    int endpoints = argc - 1;
    if (endpoints == 0)
        printf ("I: syntax: %s &lt;endpoint&gt; ...\n", argv [0]);
    else
    if (endpoints == 1) {
        //  For one endpoint, we retry N times
        int retries;
        for (retries = 0; retries &lt; MAX_RETRIES; retries++) {
            char *endpoint = argv [1];
            reply = s_try_request (ctx, endpoint, request);
            if (reply)
                break;          //  Successful
            printf ("W: no response from %s, retrying...\n", endpoint);
        }
    }
    else {
        //  For multiple endpoints, try each at most once
        int endpoint_nbr;
        for (endpoint_nbr = 0; endpoint_nbr &lt; endpoints; endpoint_nbr++) {
            char *endpoint = argv [endpoint_nbr + 1];
            reply = s_try_request (ctx, endpoint, request);
            if (reply)
                break;          //  Successful
            printf ("W: no response from %s\n", endpoint);
        }
    }
    if (reply)
        printf ("Service is running OK\n");

    zmsg_destroy (&amp;request);
    zmsg_destroy (&amp;reply);
    zctx_destroy (&amp;ctx);
    return 0;
}
</programlisting>

</example>
<para>For example:</para>

<screen>flserver1 tcp://*:5555 &amp;
flserver1 tcp://*:5556 &amp;
flclient1 tcp://localhost:5555 tcp://localhost:5556
</screen>

<para>While the basic approach is Lazy Pirate, the client aims to just get one successful reply. It has two techniques, depending on whether you are running a single server, or multiple servers:</para>

<itemizedlist>
  <listitem><para>With a single server, the client will retry several times, exactly as for Lazy Pirate.</para></listitem>
  <listitem><para>With multiple servers, the client will try each server at most once, until it's received a reply, or has tried all servers.</para></listitem>
</itemizedlist>
<para>This solves the main weakness of Lazy Pirate, namely that it could not do fail-over to backup / alternate servers.</para>

<para>However this design won't work well in a real application. If we're connecting many sockets, and our primary name server is down, we're going to do this painful timeout each time.</para>

</sect2>
<sect2>
<title>Model Two - Brutal Shotgun Massacre</title>
<para>Let's switch our client to using a DEALER socket. Our goal here is to make sure we get a reply back within the shortest possible time, no matter whether the primary server is down or not. Our client takes this approach:</para>

<itemizedlist>
  <listitem><para>We set things up, connecting to all servers.</para></listitem>
  <listitem><para>When we have a request, we blast it out as many times as we have servers.</para></listitem>
  <listitem><para>We wait for the first reply, and take that.</para></listitem>
  <listitem><para>We ignore any other replies.</para></listitem>
</itemizedlist>
<para>What will happen in practice is that when all servers are running, &Oslash;MQ will distribute the requests so each server gets one request, and sends one reply. When any server is offline, and disconnected, &Oslash;MQ will distribute the requests to the remaining servers. So a server may in some cases get the same request more than once.</para>

<para>What's more annoying for the client is that we'll get multiple replies back, but there's no guarantee we'll get a precise number of replies. Requests and replies can get lost (e.g. if the server crashes while processing a request).</para>

<para>So, we have to number requests, and ignore any replies that don't match the request number. Our Model One server will work, since it's an echo server, but coincidence is not a great basis for understanding. So we'll make a Model Two server that chews up the message, returns a correctly-numbered reply with the content "OK". We'll use messages consisting of two parts, a sequence number and a body.</para>

<para>Start the server once or more, specifying a bind endpoint each time:</para>

<example id="flserver2-c">
<title>Freelance server, Model Two (flserver2.c)</title>
<programlisting language="c">
//
//  Freelance server - Model 2
//  Does some work, replies OK, with message sequencing
//
#include "czmq.h"

int main (int argc, char *argv [])
{
    if (argc &lt; 2) {
        printf ("I: syntax: %s &lt;endpoint&gt;\n", argv [0]);
        exit (EXIT_SUCCESS);
    }
    zctx_t *ctx = zctx_new ();
    void *server = zsocket_new (ctx, ZMQ_REP);
    zsocket_bind (server, argv [1]);

    printf ("I: service is ready at %s\n", argv [1]);
    while (true) {
        zmsg_t *request = zmsg_recv (server);
        if (!request)
            break;          //  Interrupted
        //  Fail nastily if run against wrong client
        assert (zmsg_size (request) == 2);

        zframe_t *address = zmsg_pop (request);
        zmsg_destroy (&amp;request);

        zmsg_t *reply = zmsg_new ();
        zmsg_add (reply, address);
        zmsg_addstr (reply, "OK");
        zmsg_send (&amp;reply, server);
    }
    if (zctx_interrupted)
        printf ("W: interrupted\n");

    zctx_destroy (&amp;ctx);
    return 0;
}
</programlisting>

</example>
<para>Then start the client, specifying the connect endpoints as arguments:</para>

<example id="flclient2-c">
<title>Freelance client, Model Two (flclient2.c)</title>
<programlisting language="c">
//
//  Freelance client - Model 2
//  Uses DEALER socket to blast one or more services
//
#include "czmq.h"

//  We design our client API as a class, using the CZMQ style
#ifdef __cplusplus
extern "C" {
#endif

typedef struct _flclient_t flclient_t;
flclient_t *flclient_new (void);
void        flclient_destroy (flclient_t **self_p);
void        flclient_connect (flclient_t *self, char *endpoint);
zmsg_t     *flclient_request (flclient_t *self, zmsg_t **request_p);

#ifdef __cplusplus
}
#endif

//  If not a single service replies within this time, give up
#define GLOBAL_TIMEOUT 2500

int main (int argc, char *argv [])
{
    if (argc == 1) {
        printf ("I: syntax: %s &lt;endpoint&gt; ...\n", argv [0]);
        exit (EXIT_SUCCESS);
    }
    //  Create new freelance client object
    flclient_t *client = flclient_new ();

    //  Connect to each endpoint
    int argn;
    for (argn = 1; argn &lt; argc; argn++)
        flclient_connect (client, argv [argn]);

    //  Send a bunch of name resolution 'requests', measure time
    int requests = 10000;
    uint64_t start = zclock_time ();
    while (requests--) {
        zmsg_t *request = zmsg_new ();
        zmsg_addstr (request, "random name");
        zmsg_t *reply = flclient_request (client, &amp;request);
        if (!reply) {
            printf ("E: name service not available, aborting\n");
            break;
        }
        zmsg_destroy (&amp;reply);
    }
    printf ("Average round trip cost: %d usec\n",
        (int) (zclock_time () - start) / 10);

    flclient_destroy (&amp;client);
    return 0;
}
</programlisting>

</example>
<para>Here is the flclient class implementation. Each instance has a context, a DEALER socket it uses to talk to the servers, a counter of how many servers it's connected to, and a request sequence number: 
</para>

<example id="flclient2-c-1">
<title>Freelance client, Model Two (flclient2.c) - class implementation</title>
<programlisting language="c">


struct _flclient_t {
    zctx_t *ctx;        //  Our context wrapper
    void *socket;       //  DEALER socket talking to servers
    size_t servers;     //  How many servers we have connected to
    uint sequence;      //  Number of requests ever sent
};

//  --------------------------------------------------------------------
//  Constructor

flclient_t *
flclient_new (void)
{
    flclient_t
        *self;

    self = (flclient_t *) zmalloc (sizeof (flclient_t));
    self-&gt;ctx = zctx_new ();
    self-&gt;socket = zsocket_new (self-&gt;ctx, ZMQ_DEALER);
    return self;
}

//  --------------------------------------------------------------------
//  Destructor

void
flclient_destroy (flclient_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        flclient_t *self = *self_p;
        zctx_destroy (&amp;self-&gt;ctx);
        free (self);
        *self_p = NULL;
    }
}

//  --------------------------------------------------------------------
//  Connect to new server endpoint

void
flclient_connect (flclient_t *self, char *endpoint)
{
    assert (self);
    zsocket_connect (self-&gt;socket, endpoint);
    self-&gt;servers++;
}
</programlisting>

</example>
<para>The request method does the hard work. It sends a request to all connected servers in parallel (for this to work, all connections have to be successful and completed by this time). It then waits for a single successful reply, and returns that to the caller. Any other replies are just dropped: 
</para>

<example id="flclient2-c-2">
<title>Freelance client, Model Two (flclient2.c) - request method</title>
<programlisting language="c">

zmsg_t *
flclient_request (flclient_t *self, zmsg_t **request_p)
{
    assert (self);
    assert (*request_p);
    zmsg_t *request = *request_p;

    //  Prefix request with sequence number and empty envelope
    char sequence_text [10];
    sprintf (sequence_text, "%u", ++self-&gt;sequence);
    zmsg_pushstr (request, sequence_text);
    zmsg_pushstr (request, "");

    //  Blast the request to all connected servers
    int server;
    for (server = 0; server &lt; self-&gt;servers; server++) {
        zmsg_t *msg = zmsg_dup (request);
        zmsg_send (&amp;msg, self-&gt;socket);
    }
    //  Wait for a matching reply to arrive from anywhere
    //  Since we can poll several times, calculate each one
    zmsg_t *reply = NULL;
    uint64_t endtime = zclock_time () + GLOBAL_TIMEOUT;
    while (zclock_time () &lt; endtime) {
        zmq_pollitem_t items [] = { { self-&gt;socket, 0, ZMQ_POLLIN, 0 } };
        zmq_poll (items, 1, (endtime - zclock_time ()) * ZMQ_POLL_MSEC);
        if (items [0].revents &amp; ZMQ_POLLIN) {
            //  Reply is [empty][sequence][OK]
            reply = zmsg_recv (self-&gt;socket);
            assert (zmsg_size (reply) == 3);
            free (zmsg_popstr (reply));
            char *sequence = zmsg_popstr (reply);
            int sequence_nbr = atoi (sequence);
            free (sequence);
            if (sequence_nbr == self-&gt;sequence)
                break;
        }
    }
    zmsg_destroy (request_p);
    return reply;
}
</programlisting>

</example>
<para>Some notes on this code:</para>

<itemizedlist>
  <listitem><para>The client is structured as a nice little class-based API that hides the dirty work of creating &Oslash;MQ contexts and sockets, and talking to the server. If a shotgun blast to the midriff can be called "talking".</para></listitem>
  <listitem><para>The client will abandon the chase if it can't find <emphasis>any</emphasis> responsive server within a few seconds.</para></listitem>
  <listitem><para>The client has to create a valid REP envelope, i.e. add an empty message frame to the front of the message.</para></listitem>
</itemizedlist>
<para>The client does 10,000 name resolution requests (fake ones, since our server does essentially nothing), and measures the average cost. On my test box, talking to one server, it's about 60 usec. Talking to three servers, it's about 80 usec.</para>

<para>So pros and cons of our shotgun approach:</para>

<itemizedlist>
  <listitem><para>Pro: it is simple, easy to make and easy to understand.</para></listitem>
  <listitem><para>Pro: it does the job of fail-over, and works rapidly, so long as there is at least one server running.</para></listitem>
  <listitem><para>Con: it creates redundant network traffic.</para></listitem>
  <listitem><para>Con: we can't prioritize our servers, i.e. Primary, then Secondary.</para></listitem>
  <listitem><para>Con: the server can do at most one request at a time, period.</para></listitem>
</itemizedlist>
</sect2>
<sect2>
<title>Model Three - Complex and Nasty</title>
<para>The shotgun approach seems too good to be true. Let's be scientific and work through all the alternatives. We're going to explore the complex/nasty option, even if it's only to finally realize that we preferred brutal. Ah, the story of my life.</para>

<para>We can solve the main problems of the client by switching to a ROUTER socket. That lets us send requests to specific servers, avoid servers we know are dead, and in general be as smart as we want to make it. We can also solve the main problem of the server (single-threadedness) by switching to a ROUTER socket.</para>

<para>But doing ROUTER-to-ROUTER between two anonymous sockets (which haven't set an identity) is not possible. Both sides generate an identity (for the other peer) only when they receive a first message, and thus neither can talk to the other until it has first received a message. The only way out of this conundrum is to cheat, and use hard-coded identities in one direction. The proper way to cheat, in a client server case, is that the client 'knows' the identity of the server. Vice-versa would be insane, on top of complex and nasty. Insane, complex, and nasty are great attributes for a genocidal dictator, but terrible ones for software.</para>

<para>Rather than invent yet another concept to manage, we'll use the connection endpoint as identity. This is a unique string both sides can agree on without more prior knowledge than they already have for the shotgun model. It's a sneaky and effective way to connect two ROUTER sockets.</para>

<para>Remember how &Oslash;MQ identities work. The server ROUTER socket sets an identity before it binds its socket. When a client connects, they do a little handshake to exchange identities, before either side sends a real message. The client ROUTER socket, having not set an identity, sends a null identity to the server. The server generates a random UUID for the client, for its own use. The server sends its identity (which we've agreed is going to be an endpoint string) to the client.</para>

<para>This means our client can route a message to the server (i.e. send on its ROUTER socket, specifying the server endpoint as identity) as soon as the connection is established. That's not <emphasis>immediately</emphasis> after doing a <literal>zmq_connect()</literal>, but some random time thereafter. Herein lies one problem: we don't know when the server will actually be available and complete its connection handshake. If the server is actually online, it could be after a few milliseconds. If the server is down, and the sysadmin is out to lunch, it could be an hour.</para>

<para>There's a small paradox here. We need to know when servers become connected and available for work. In the Freelance pattern, unlike the broker-based patterns we saw earlier in this chapter, servers are silent until spoken to. Thus we can't talk to a server until it's told us it's on-line, which it can't do until we've asked it.</para>

<para>My solution is to mix in a little of the shotgun approach from model 2, meaning we'll fire (harmless) shots at anything we can, and if anything moves, we know it's alive. We're not going to fire real requests, but rather a kind of ping-pong heartbeat.</para>

<para>This brings us to the realm of protocols again, so here's a short spec that defines how a Freelance client and server exchange PING-PONG commands, and request-reply commands:</para>

<itemizedlist>
  <listitem><para>http://rfc.zeromq.org/spec:10</para></listitem>
</itemizedlist>
<para>It is short and sweet to implement as a server. Here's our echo server, Model Three, now speaking FLP.</para>

<para>Model Three of the server is just slightly different:</para>

<example id="flserver3-c">
<title>Freelance server, Model Three (flserver3.c)</title>
<programlisting language="c">
//
//  Freelance server - Model 3
//  Uses an ROUTER/ROUTER socket but just one thread
//
#include "czmq.h"

int main (int argc, char *argv [])
{
    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], "-v"));

    zctx_t *ctx = zctx_new ();

    //  Prepare server socket with predictable identity
    char *bind_endpoint = "tcp://*:5555";
    char *connect_endpoint = "tcp://localhost:5555";
    void *server = zsocket_new (ctx, ZMQ_ROUTER);
    zmq_setsockopt (server,
        ZMQ_IDENTITY, connect_endpoint, strlen (connect_endpoint));
    zsocket_bind (server, bind_endpoint);
    printf ("I: service is ready at %s\n", bind_endpoint);

    while (!zctx_interrupted) {
        zmsg_t *request = zmsg_recv (server);
        if (verbose &amp;&amp; request)
            zmsg_dump (request);
        if (!request)
            break;          //  Interrupted

        //  Frame 0: identity of client
        //  Frame 1: PING, or client control frame
        //  Frame 2: request body
        zframe_t *address = zmsg_pop (request);
        zframe_t *control = zmsg_pop (request);
        zmsg_t *reply = zmsg_new ();
        if (zframe_streq (control, "PING"))
            zmsg_addstr (reply, "PONG");
        else {
            zmsg_add (reply, control);
            zmsg_addstr (reply, "OK");
        }
        zmsg_destroy (&amp;request);
        zmsg_push (reply, address);
        if (verbose &amp;&amp; reply)
            zmsg_dump (reply);
        zmsg_send (&amp;reply, server);
    }
    if (zctx_interrupted)
        printf ("W: interrupted\n");

    zctx_destroy (&amp;ctx);
    return 0;
}
</programlisting>

</example>
<para>The Freelance client, however, has gotten large. For clarity, it's split into an example application and a class that does the hard work. Here's the top-level application:</para>

<example id="flclient3-c">
<title>Freelance client, Model Three (flclient3.c)</title>
<programlisting language="c">
//
//  Freelance client - Model 3
//  Uses flcliapi class to encapsulate Freelance pattern
//
//  Lets us build this source without creating a library
#include "flcliapi.c"

int main (void)
{
    //  Create new freelance client object
    flcliapi_t *client = flcliapi_new ();

    //  Connect to several endpoints
    flcliapi_connect (client, "tcp://localhost:5555");
    flcliapi_connect (client, "tcp://localhost:5556");
    flcliapi_connect (client, "tcp://localhost:5557");

    //  Send a bunch of name resolution 'requests', measure time
    int requests = 1000;
    uint64_t start = zclock_time ();
    while (requests--) {
        zmsg_t *request = zmsg_new ();
        zmsg_addstr (request, "random name");
        zmsg_t *reply = flcliapi_request (client, &amp;request);
        if (!reply) {
            printf ("E: name service not available, aborting\n");
            break;
        }
        zmsg_destroy (&amp;reply);
    }
    printf ("Average round trip cost: %d usec\n",
        (int) (zclock_time () - start) / 10);

    flcliapi_destroy (&amp;client);
    return 0;
}
</programlisting>

</example>
<para>And here, almost as complex and large as the Majordomo broker, is the client API class:</para>

<example id="flcliapi-c">
<title>Freelance client API (flcliapi.c)</title>
<programlisting language="c">
/*  =====================================================================
 *  flcliapi - Freelance Pattern agent class
 *  Implements the Freelance Protocol at http://rfc.zeromq.org/spec:10.
 *  ===================================================================== */

#include "flcliapi.h"

//  If no server replies within this time, abandon request
#define GLOBAL_TIMEOUT  3000    //  msecs
//  PING interval for servers we think are alive
#define PING_INTERVAL   2000    //  msecs
//  Server considered dead if silent for this long
#define SERVER_TTL      6000    //  msecs
</programlisting>

</example>
<para>This API works in two halves, a common pattern for APIs that need to run in the background. One half is an front-end object our application creates and works with; the other half is a back-end "agent" that runs in a background thread. The front-end talks to the back-end over an inproc pipe socket: 
</para>

<example id="flcliapi-c-1">
<title>Freelance client API (flcliapi.c) - API structure</title>
<programlisting language="c">


//  ---------------------------------------------------------------------
//  Structure of our front-end class

struct _flcliapi_t {
    zctx_t *ctx;        //  Our context wrapper
    void *pipe;         //  Pipe through to flcliapi agent
};

//  This is the thread that handles our real flcliapi class
static void flcliapi_agent (void *args, zctx_t *ctx, void *pipe);

//  ---------------------------------------------------------------------
//  Constructor

flcliapi_t *
flcliapi_new (void)
{
    flcliapi_t
        *self;

    self = (flcliapi_t *) zmalloc (sizeof (flcliapi_t));
    self-&gt;ctx = zctx_new ();
    self-&gt;pipe = zthread_fork (self-&gt;ctx, flcliapi_agent, NULL);
    return self;
}

//  ---------------------------------------------------------------------
//  Destructor

void
flcliapi_destroy (flcliapi_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        flcliapi_t *self = *self_p;
        zctx_destroy (&amp;self-&gt;ctx);
        free (self);
        *self_p = NULL;
    }
}
</programlisting>

</example>
<para>To implement the connect method, the front-end object sends a multi-part message to the back-end agent. The first part is a string "CONNECT", and the second part is the endpoint. It waits 100msec for the connection to come up, which isn't pretty, but saves us from sending all requests to a single server, at start-up time: 
</para>

<example id="flcliapi-c-2">
<title>Freelance client API (flcliapi.c) - connect method</title>
<programlisting language="c">

void
flcliapi_connect (flcliapi_t *self, char *endpoint)
{
    assert (self);
    assert (endpoint);
    zmsg_t *msg = zmsg_new ();
    zmsg_addstr (msg, "CONNECT");
    zmsg_addstr (msg, endpoint);
    zmsg_send (&amp;msg, self-&gt;pipe);
    zclock_sleep (100);      //  Allow connection to come up
}
</programlisting>

</example>
<para>To implement the request method, the front-end object sends a message to the back-end, specifying a command "REQUEST" and the request message: 
</para>

<example id="flcliapi-c-3">
<title>Freelance client API (flcliapi.c) - request method</title>
<programlisting language="c">

zmsg_t *
flcliapi_request (flcliapi_t *self, zmsg_t **request_p)
{
    assert (self);
    assert (*request_p);

    zmsg_pushstr (*request_p, "REQUEST");
    zmsg_send (request_p, self-&gt;pipe);
    zmsg_t *reply = zmsg_recv (self-&gt;pipe);
    if (reply) {
        char *status = zmsg_popstr (reply);
        if (streq (status, "FAILED"))
            zmsg_destroy (&amp;reply);
        free (status);
    }
    return reply;
}
</programlisting>

</example>
<para>Here we see the back-end agent. It runs as an attached thread, talking to its parent over a pipe socket. It is a fairly complex piece of work so we'll break it down into pieces. First, the agent manages a set of servers, using our familiar class approach: 
</para>

<example id="flcliapi-c-4">
<title>Freelance client API (flcliapi.c) - back-end agent</title>
<programlisting language="c">


//  ---------------------------------------------------------------------
//  Simple class for one server we talk to

typedef struct {
    char *endpoint;             //  Server identity/endpoint
    uint alive;                 //  1 if known to be alive
    int64_t ping_at;            //  Next ping at this time
    int64_t expires;            //  Expires at this time
} server_t;

server_t *
server_new (char *endpoint)
{
    server_t *self = (server_t *) zmalloc (sizeof (server_t));
    self-&gt;endpoint = strdup (endpoint);
    self-&gt;alive = 0;
    self-&gt;ping_at = zclock_time () + PING_INTERVAL;
    self-&gt;expires = zclock_time () + SERVER_TTL;
    return self;
}

void
server_destroy (server_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        server_t *self = *self_p;
        free (self-&gt;endpoint);
        free (self);
        *self_p = NULL;
    }
}

int
server_ping (const char *key, void *server, void *socket)
{
    server_t *self = (server_t *) server;
    if (zclock_time () &gt;= self-&gt;ping_at) {
        zmsg_t *ping = zmsg_new ();
        zmsg_addstr (ping, self-&gt;endpoint);
        zmsg_addstr (ping, "PING");
        zmsg_send (&amp;ping, socket);
        self-&gt;ping_at = zclock_time () + PING_INTERVAL;
    }
    return 0;
}

int
server_tickless (const char *key, void *server, void *arg)
{
    server_t *self = (server_t *) server;
    uint64_t *tickless = (uint64_t *) arg;
    if (*tickless &gt; self-&gt;ping_at)
        *tickless = self-&gt;ping_at;
    return 0;
}
</programlisting>

</example>
<para>We build the agent as a class that's capable of processing messages coming in from its various sockets: 
</para>

<example id="flcliapi-c-5">
<title>Freelance client API (flcliapi.c) - back-end agent class</title>
<programlisting language="c">


//  ---------------------------------------------------------------------
//  Simple class for one background agent

typedef struct {
    zctx_t *ctx;                //  Own context
    void *pipe;                 //  Socket to talk back to application
    void *router;               //  Socket to talk to servers
    zhash_t *servers;           //  Servers we've connected to
    zlist_t *actives;           //  Servers we know are alive
    uint sequence;              //  Number of requests ever sent
    zmsg_t *request;            //  Current request if any
    zmsg_t *reply;              //  Current reply if any
    int64_t expires;            //  Timeout for request/reply
} agent_t;

agent_t *
agent_new (zctx_t *ctx, void *pipe)
{
    agent_t *self = (agent_t *) zmalloc (sizeof (agent_t));
    self-&gt;ctx = ctx;
    self-&gt;pipe = pipe;
    self-&gt;router = zsocket_new (self-&gt;ctx, ZMQ_ROUTER);
    self-&gt;servers = zhash_new ();
    self-&gt;actives = zlist_new ();
    return self;
}

void
agent_destroy (agent_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        agent_t *self = *self_p;
        zhash_destroy (&amp;self-&gt;servers);
        zlist_destroy (&amp;self-&gt;actives);
        zmsg_destroy (&amp;self-&gt;request);
        zmsg_destroy (&amp;self-&gt;reply);
        free (self);
        *self_p = NULL;
    }
}
</programlisting>

</example>
<para>The control_message method processes one message from our front-end class (it's going to be CONNECT or REQUEST): 
</para>

<example id="flcliapi-c-6">
<title>Freelance client API (flcliapi.c) - control messages</title>
<programlisting language="c">

//  Callback when we remove server from agent 'servers' hash table

static void
s_server_free (void *argument)
{
    server_t *server = (server_t *) argument;
    server_destroy (&amp;server);
}

void
agent_control_message (agent_t *self)
{
    zmsg_t *msg = zmsg_recv (self-&gt;pipe);
    char *command = zmsg_popstr (msg);

    if (streq (command, "CONNECT")) {
        char *endpoint = zmsg_popstr (msg);
        printf ("I: connecting to %s...\n", endpoint);
        int rc = zmq_connect (self-&gt;router, endpoint);
        assert (rc == 0);
        server_t *server = server_new (endpoint);
        zhash_insert (self-&gt;servers, endpoint, server);
        zhash_freefn (self-&gt;servers, endpoint, s_server_free);
        zlist_append (self-&gt;actives, server);
        server-&gt;ping_at = zclock_time () + PING_INTERVAL;
        server-&gt;expires = zclock_time () + SERVER_TTL;
        free (endpoint);
    }
    else
    if (streq (command, "REQUEST")) {
        assert (!self-&gt;request);    //  Strict request-reply cycle
        //  Prefix request with sequence number and empty envelope
        char sequence_text [10];
        sprintf (sequence_text, "%u", ++self-&gt;sequence);
        zmsg_pushstr (msg, sequence_text);
        //  Take ownership of request message
        self-&gt;request = msg;
        msg = NULL;
        //  Request expires after global timeout
        self-&gt;expires = zclock_time () + GLOBAL_TIMEOUT;
    }
    free (command);
    zmsg_destroy (&amp;msg);
}
</programlisting>

</example>
<para>The router_message method processes one message from a connected server: 
</para>

<example id="flcliapi-c-7">
<title>Freelance client API (flcliapi.c) - router messages</title>
<programlisting language="c">

void
agent_router_message (agent_t *self)
{
    zmsg_t *reply = zmsg_recv (self-&gt;router);

    //  Frame 0 is server that replied
    char *endpoint = zmsg_popstr (reply);
    server_t *server =
        (server_t *) zhash_lookup (self-&gt;servers, endpoint);
    assert (server);
    free (endpoint);
    if (!server-&gt;alive) {
        zlist_append (self-&gt;actives, server);
        server-&gt;alive = 1;
    }
    server-&gt;ping_at = zclock_time () + PING_INTERVAL;
    server-&gt;expires = zclock_time () + SERVER_TTL;

    //  Frame 1 may be sequence number for reply
    char *sequence = zmsg_popstr (reply);
    if (atoi (sequence) == self-&gt;sequence) {
        zmsg_pushstr (reply, "OK");
        zmsg_send (&amp;reply, self-&gt;pipe);
        zmsg_destroy (&amp;self-&gt;request);
    }
    else
        zmsg_destroy (&amp;reply);
}
</programlisting>

</example>
<para>Finally here's the agent task itself, which polls its two sockets and processes incoming messages: 
</para>

<example id="flcliapi-c-8">
<title>Freelance client API (flcliapi.c) - back-end agent implementation</title>
<programlisting language="c">


static void
flcliapi_agent (void *args, zctx_t *ctx, void *pipe)
{
    agent_t *self = agent_new (ctx, pipe);

    zmq_pollitem_t items [] = {
        { self-&gt;pipe, 0, ZMQ_POLLIN, 0 },
        { self-&gt;router, 0, ZMQ_POLLIN, 0 }
    };
    while (!zctx_interrupted) {
        //  Calculate tickless timer, up to 1 hour
        uint64_t tickless = zclock_time () + 1000 * 3600;
        if (self-&gt;request
        &amp;&amp;  tickless &gt; self-&gt;expires)
            tickless = self-&gt;expires;
        zhash_foreach (self-&gt;servers, server_tickless, &amp;tickless);

        int rc = zmq_poll (items, 2,
            (tickless - zclock_time ()) * ZMQ_POLL_MSEC);
        if (rc == -1)
            break;              //  Context has been shut down

        if (items [0].revents &amp; ZMQ_POLLIN)
            agent_control_message (self);

        if (items [1].revents &amp; ZMQ_POLLIN)
            agent_router_message (self);

        //  If we're processing a request, dispatch to next server
        if (self-&gt;request) {
            if (zclock_time () &gt;= self-&gt;expires) {
                //  Request expired, kill it
                zstr_send (self-&gt;pipe, "FAILED");
                zmsg_destroy (&amp;self-&gt;request);
            }
            else {
                //  Find server to talk to, remove any expired ones
                while (zlist_size (self-&gt;actives)) {
                    server_t *server =
                        (server_t *) zlist_first (self-&gt;actives);
                    if (zclock_time () &gt;= server-&gt;expires) {
                        zlist_pop (self-&gt;actives);
                        server-&gt;alive = 0;
                    }
                    else {
                        zmsg_t *request = zmsg_dup (self-&gt;request);
                        zmsg_pushstr (request, server-&gt;endpoint);
                        zmsg_send (&amp;request, self-&gt;router);
                        break;
                    }
                }
            }
        }
        //  Disconnect and delete any expired servers
        //  Send heartbeats to idle servers if needed
        zhash_foreach (self-&gt;servers, server_ping, self-&gt;router);
    }
    agent_destroy (&amp;self);
}
</programlisting>

</example>
<para>This API implementation is fairly sophisticated and uses a couple of techniques that we've not seen before:</para>

<para><emphasis role="bold">Multithreaded API</emphasis></para>

<para>The client API consists of two parts, a synchronous 'flcliapi' class that runs in the application thread, and an asynchronous 'agent' class that runs as a background thread. Remember how &Oslash;MQ makes it easy to create multithreaded apps. The flcliapi and agent classes talk to each other with messages over an <literal>inproc</literal> socket. All &Oslash;MQ aspects (such as creating and destroying a context) are hidden in the API. The agent in effect acts like a mini-broker, talking to servers in the background, so that when we make a request, it can make a best effort to reach a server it believes is available.</para>

<para><emphasis role="bold">Tickless poll timer</emphasis></para>

<para>In previous poll loops we always used a fixed tick interval, e.g. 1 second, which is simple enough but not excellent on power-sensitive clients, such as notebooks or mobile phones, where waking the CPU costs power. For fun, and to help save the planet, the agent uses a 'tickless timer', which calculates the poll delay based on the next timeout we're expecting. A proper implementation would keep an ordered list of timeouts. We just check all timeouts and calculate the poll delay until the next one.</para>

</sect2>
</sect1>
<sect1>
<title>Conclusion</title>
<para>In this chapter we've seen a variety of reliable request-reply mechanisms, each with certain costs and benefits. The example code is largely ready for real use, though it is not optimized. Of all the different patterns, the two that stand out are the Majordomo pattern, for broker-based reliability, and the Freelance pattern for brokerless reliability.</para>

</sect1>
</chapter>
<chapter id="advanced-pub-sub">
<title>Advanced Publish-Subscribe Patterns</title>
<para>In Advanced Request-Reply Patterns<xref linkend="advanced-request-reply"/> and Reliable Request-Reply Patterns<xref linkend="reliable-request-reply"/> we looked at advanced use of &Oslash;MQ's request-reply pattern. If you managed to digest all that, congratulations. In this chapter we'll focus on publish-subscribe, and extend &Oslash;MQ's core pub-sub pattern with higher-level patterns for performance, reliability, state distribution, and monitoring.</para>

<para>We'll cover:</para>

<itemizedlist>
  <listitem><para>How to handle too-slow subscribers (the <emphasis>Suicidal Snail</emphasis> pattern).</para></listitem>
  <listitem><para>How to design high-speed subscribers (the <emphasis>Black Box</emphasis> pattern).</para></listitem>
  <listitem><para>How to build a shared key-value cache (the <emphasis>Clone</emphasis> pattern).</para></listitem>
  <listitem><para>How to use reactors to simplify complex servers.</para></listitem>
  <listitem><para>How to use the Binary Star pattern to add failover to a server.</para></listitem>
  <listitem><para>How to monitor a publish-subscribe network (the <emphasis>Espresso</emphasis> pattern).</para></listitem>
</itemizedlist>
<sect1>
<title>Slow Subscriber Detection (Suicidal Snail Pattern)</title>
<para>A common problem you will hit when using the pub-sub pattern in real life is the slow subscriber. In an ideal world, we stream data at full speed from publishers to subscribers. In reality, subscriber applications are often written in interpreted languages, or just do a lot of work, or are just badly written, to the extent that they can't keep up with publishers.</para>

<para>How do we handle a slow subscriber? The ideal fix is to make the subscriber faster, but that might take work and time. Some of the classic strategies for handling a slow subscriber are:</para>

<itemizedlist>
  <listitem><para><emphasis role="bold">Queue messages on the publisher</emphasis>. This is what Gmail does when I don't read my email for a couple of hours. But in high-volume messaging, pushing queues upstream has the thrilling but unprofitable result of making publishers run out of memory and crash. Especially if there are lots of subscribers and it's not possible to flush to disk for performance reasons.</para></listitem>
  <listitem><para><emphasis role="bold">Queue messages on the subscriber</emphasis>. This is much better, and it's what &Oslash;MQ does by default if the network can keep up with things. If anyone's going to run out of memory and crash, it'll be the subscriber rather than the publisher, which is fair. This is perfect for "peaky" streams where a subscriber can't keep up for a while, but can catch up when the stream slows down. However it's no answer to a subscriber that's simply too slow in general.</para></listitem>
  <listitem><para><emphasis role="bold">Stop queuing new messages after a while</emphasis>. This is what Gmail does when my mailbox overflows its 7.554GB, no 7.555GB of space. New messages just get rejected or dropped. This is a great strategy from the perspective of the publisher, and it's what &Oslash;MQ does when the publisher sets a high water mark or HWM. However it still doesn't help us fix the slow subscriber. Now we just get gaps in our message stream.</para></listitem>
  <listitem><para><emphasis role="bold">Punish slow subscribers with disconnect</emphasis>. This is what Hotmail does when I don't login for two weeks, which is why I'm on my fifteenth Hotmail account. It's a nice brutal strategy that forces subscribers to sit up and pay attention, and would be ideal, but &Oslash;MQ doesn't do this, and there's no way to layer it on top since subscribers are invisible to publisher applications.</para></listitem>
</itemizedlist>
<para>None of these classic strategies fit. So we need to get creative. Rather than disconnect the publisher, let's convince the subscriber to kill itself. This is the Suicidal Snail pattern. When a subscriber detects that it's running too slowly (where "too slowly" is presumably a configured option that really means "so slowly that if you ever get here, shout really loudly because I need to know, so I can fix this!"), it croaks and dies.</para>

<para>How can a subscriber detect this? One way would be to sequence messages (number them in order), and use a HWM at the publisher. Now, if the subscriber detects a gap (i.e. the numbering isn't consecutive), it knows something is wrong. We then tune the HWM to the "croak and die if you hit this" level.</para>

<para>There are two problems with this solution. One, if we have many publishers, how do we sequence messages? The solution is to give each publisher a unique ID and add that to the sequencing. Second, if subscribers use <literal>ZMQ_SUBSCRIBE</literal> filters, they will get gaps by definition. Our precious sequencing will be for nothing.</para>

<para>Some use-cases won't use filters, and sequencing will work for them. But a more general solution is that the publisher timestamps each message. When a subscriber gets a message it checks the time, and if the difference is more than, say, one second, it does the "croak and die" thing. Possibly firing off a squawk to some operator console first.</para>

<para>The Suicide Snail pattern works especially when subscribers have their own clients and service-level agreements and need to guarantee certain maximum latencies. Aborting a subscriber may not seem like a constructive way to guarantee a maximum latency, but it's the assertion model. Abort today, and the problem will be fixed. Allow late data to flow downstream, and the problem may cause wider damage and take longer to appear on the radar.</para>

<para>So here is a minimal example of a Suicidal Snail:</para>

<example id="suisnail-c">
<title>Suicidal Snail (suisnail.c)</title>
<programlisting language="c">
//
//  Suicidal Snail
//
#include "czmq.h"

//  This is our subscriber. It connects to the publisher and subscribes to
//  everything. It sleeps for a short time between messages to simulate doing
//  too much work. If a message is more than 1 second late, it croaks:

#define MAX_ALLOWED_DELAY   1000    //  msecs

static void
subscriber (void *args, zctx_t *ctx, void *pipe)
{
    //  Subscribe to everything
    void *subscriber = zsocket_new (ctx, ZMQ_SUB);
    zsockopt_set_subscribe (subscriber, "");
    zsocket_connect (subscriber, "tcp://localhost:5556");

    //  Get and process messages
    while (true) {
        char *string = zstr_recv (subscriber);
        printf("%s\n", string);
        int64_t clock;
        int terms = sscanf (string, "%" PRId64, &amp;clock);
        assert (terms == 1);
        free (string);

        //  Suicide snail logic
        if (zclock_time () - clock &gt; MAX_ALLOWED_DELAY) {
            fprintf (stderr, "E: subscriber cannot keep up, aborting\n");
            break;
        }
        //  Work for 1 msec plus some random additional time
        zclock_sleep (1 + randof (2));
    }
    zstr_send (pipe, "gone and died");
}
</programlisting>

</example>
<para>This is our publisher task. It publishes a time-stamped message to its PUB socket every 1 msec: 
</para>

<example id="suisnail-c-1">
<title>Suicidal Snail (suisnail.c) - publisher task</title>
<programlisting language="c">

static void
publisher (void *args, zctx_t *ctx, void *pipe)
{
    //  Prepare publisher
    void *publisher = zsocket_new (ctx, ZMQ_PUB);
    zsocket_bind (publisher, "tcp://*:5556");

    while (true) {
        //  Send current clock (msecs) to subscribers
        char string [20];
        sprintf (string, "%" PRId64, zclock_time ());
        zstr_send (publisher, string);
        char *signal = zstr_recv_nowait (pipe);
        if (signal) {
            free (signal);
            break;
        }
        zclock_sleep (1);            //  1msec wait
    }
}
</programlisting>

</example>
<para>The main task simply starts a client, and a server, and then waits for the client to signal that it has died: 
</para>

<example id="suisnail-c-2">
<title>Suicidal Snail (suisnail.c) - main task</title>
<programlisting language="c">

int main (void)
{
    zctx_t *ctx = zctx_new ();
    void *pubpipe = zthread_fork (ctx, publisher, NULL);
    void *subpipe = zthread_fork (ctx, subscriber, NULL);
    free (zstr_recv (subpipe));
    zstr_send (pubpipe, "break");
    zclock_sleep (100);
    zctx_destroy (&amp;ctx);
    return 0;
}
</programlisting>

</example>
<para>Notes about this example:</para>

<itemizedlist>
  <listitem><para>The message here consists simply of the current system clock as a number of milliseconds. In a realistic application you'd have at least a message header with the timestamp, and a message body with data.</para></listitem>
  <listitem><para>The example has subscriber and publisher in a single process, as two threads. In reality they would be separate processes. Using threads is just convenient for the demonstration.</para></listitem>
</itemizedlist>
</sect1>
<sect1>
<title>High-speed Subscribers (Black Box Pattern)</title>
<para>A common use-case for pub-sub is distributing large data streams. For example, 'market data' coming from stock exchanges. A typical set-up would have a publisher connected to a stock exchange, taking price quotes, and sending them out to a number of subscribers. If there are a handful of subscribers, we could use TCP. If we have a larger number of subscribers, we'd probably use reliable multicast, i.e. <literal>pgm</literal>.</para>

<para>Let's imagine our feed has an average of 100,000 100-byte messages a second. That's a typical rate, after filtering market data we don't need to send on to subscribers. Now we decide to record a day's data (maybe 250 GB in 8 hours), and then replay it to a simulation network, i.e. a small group of subscribers. While 100K messages a second is easy for a &Oslash;MQ application, we want to replay <emphasis>much faster</emphasis>.</para>

<para>So we set-up our architecture with a bunch of boxes, one for the publisher, and one for each subscriber. These are well-specified boxes, eight cores, twelve for the publisher. (If you're reading this in 2015, which is when the Guide is scheduled to be finished, please add a zero to those numbers.)</para>

<para>And as we pump data into our subscribers, we notice two things:</para>

<orderedlist>
  <listitem><para>When we do even the slightest amount of work with a message, it slows down our subscriber to the point where it can't catch up with the publisher again.</para></listitem>
  <listitem><para>We're hitting a ceiling, at both publisher and subscriber, to around say 6M messages a second, even after careful optimization and TCP tuning.</para></listitem>
</orderedlist>
<para>The first thing we have to do is break our subscriber into a multithreaded design so that we can do work with messages in one set of threads, while reading messages in another. Typically we don't want to process every message the same way. Rather, the subscriber will filter some messages, perhaps by prefix key. When a message matches some criteria, the subscriber will call a worker to deal with it. In &Oslash;MQ terms this means sending the message to a worker thread.</para>

<para>So the subscriber looks something like a queue device. We could use various sockets to connect the subscriber and workers. If we assume one-way traffic, and workers that are all identical, we can use PUSH and PULL, and delegate all the routing work to &Oslash;MQ(<xref linkend="figure-62"/>). This is the simplest and fastest approach.</para>

<figure id="figure-62">
    <title>The Simple Black Box Pattern</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig62.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>The subscriber talks to the publisher over TCP or PGM. The subscriber talks to its workers, which are all in the same process, over inproc.</para>

<para>Now to break that ceiling. What happens is that the subscriber thread hits 100% of CPU, and since it is one thread, it cannot use more than one core. A single thread will always hit a ceiling, be it at 2M, 6M, or more messages per second. We want to split the work across multiple threads that can run in parallel.</para>

<para>The approach used by many high-performance products, which works here, is <emphasis>sharding</emphasis>, meaning we split the work into parallel and independent streams. E.g. half of the topic keys are in one stream, half in another(<xref linkend="figure-63"/>). We could use many streams, but performance won't scale unless we have free cores.</para>

<para>So let's see how to shard into two streams:</para>

<figure id="figure-63">
    <title>Mad Black Box Pattern</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig63.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>With two streams, working at full speed, we would configure &Oslash;MQ as follows:</para>

<itemizedlist>
  <listitem><para>Two I/O threads, rather than one.</para></listitem>
  <listitem><para>Two network interfaces (NIC), one per subscriber.</para></listitem>
  <listitem><para>Each I/O thread bound to a specific NIC.</para></listitem>
  <listitem><para>Two subscriber threads, bound to specific cores.</para></listitem>
  <listitem><para>Two SUB sockets, one per subscriber thread.</para></listitem>
  <listitem><para>The remaining cores assigned to worker threads.</para></listitem>
  <listitem><para>Worker threads connected to both subscriber PUSH sockets.</para></listitem>
</itemizedlist>
<para>With ideally, no more threads in our architecture than we had cores. Once we create more threads than cores, we get contention between threads, and diminishing returns. There would be no benefit, for example, in creating more I/O threads.</para>

</sect1>
<sect1>
<title>A Shared Key-Value Cache (Clone Pattern)</title>
<para>Pub-sub is like a radio broadcast, you miss everything before you join, and then how much information you get depends on the quality of your reception. Surprisingly, for engineers who are used to aiming for "perfection", this model is useful and wide-spread, because it maps perfectly to real-world distribution of information. Think of Facebook and Twitter, the BBC World Service, and the sports results.</para>

<para>However, there are also a whole lot of cases where more reliable pub-sub would be valuable, if we could do it. As we did for request-reply, let's define ''reliability' in terms of what can go wrong. Here are the classic problems with pub-sub:</para>

<itemizedlist>
  <listitem><para>Subscribers join late, so miss messages the server already sent.</para></listitem>
  <listitem><para>Subscriber connections are slow, and can lose messages during that time.</para></listitem>
  <listitem><para>Subscribers go away, and lose messages while they are away.</para></listitem>
</itemizedlist>
<para>Less often, we see problems like these:</para>

<itemizedlist>
  <listitem><para>Subscribers can crash, and restart, and lose whatever data they already received.</para></listitem>
  <listitem><para>Subscribers can fetch messages too slowly, so queues build up and then overflow.</para></listitem>
  <listitem><para>Networks can become overloaded and drop data (specifically, for PGM).</para></listitem>
  <listitem><para>Networks can become too slow, so publisher-side queues overflow, and publishers crash.</para></listitem>
</itemizedlist>
<para>A lot more can go wrong but these are the typical failures we see in a realistic system.</para>

<para>We've already solved some of these, such as the slow subscriber, which we handle with the Suicidal Snail pattern. But for the rest, it would be nice to have a generic, reusable framework for reliable pub-sub.</para>

<para>The difficulty is that we have no idea what our target applications actually want to do with their data. Do they filter it, and process only a subset of messages? Do they log the data somewhere for later reuse? Do they distribute the data further to workers? There are dozens of plausible scenarios, and each will have its own ideas about what reliability means and how much it's worth in terms of effort and performance.</para>

<para>So we'll build an abstraction that we can implement once, and then reuse for many applications. This abstraction is a <emphasis role="bold">shared key-value cache</emphasis>, which stores a set of blobs indexed by unique keys.</para>

<para>Don't confuse this with <emphasis>distributed hash tables</emphasis>, which solve the wider problem of connecting peers in a distributed network, or with <emphasis>distributed key-value tables</emphasis>, which act like non-SQL databases. All we will build is a system that reliably clones some in-memory state from a server to a set of clients. We want to:</para>

<itemizedlist>
  <listitem><para>Let a client join the network at any time, and reliably get the current server state.</para></listitem>
  <listitem><para>Let any client update the key-value cache (inserting new key-value pairs, updating existing ones, or deleting them).</para></listitem>
  <listitem><para>Reliably propagate changes to all clients, and do this with minimum latency overhead.</para></listitem>
  <listitem><para>Handle very large numbers of clients, e.g. tens of thousands or more.</para></listitem>
</itemizedlist>
<para>The key aspect of the Clone pattern is that clients talk back to servers, which is more than we do in a simple pub-sub dialog. This is why I use the terms 'server' and 'client' instead of 'publisher' and 'subscriber'. We'll use pub-sub as the core of Clone but it is a bit more than that.</para>

<sect2>
<title>Distributing Key-Value Updates</title>
<para>We'll develop Clone in stages, solving one problem at a time. First, let's look at how to distribute key-value updates from a server to a set of clients. We'll take our weather server from Basics<xref linkend="basics"/> and refactor it to send messages as key-value pairs(<xref linkend="figure-64"/>). We'll modify our client to store these in a hash table.</para>

<figure id="figure-64">
    <title>Simplest Clone Model</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig64.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>This is the server:</para>

<example id="clonesrv1-c">
<title>Clone server, Model One (clonesrv1.c)</title>
<programlisting language="c">
//
//  Clone server Model One
//

//  Lets us build this source without creating a library
#include "kvsimple.c"

int main (void)
{
    //  Prepare our context and publisher socket
    zctx_t *ctx = zctx_new ();
    void *publisher = zsocket_new (ctx, ZMQ_PUB);
    zsocket_bind (publisher, "tcp://*:5556");
    zclock_sleep (200);

    zhash_t *kvmap = zhash_new ();
    int64_t sequence = 0;
    srandom ((unsigned) time (NULL));

    while (!zctx_interrupted) {
        //  Distribute as key-value message
        kvmsg_t *kvmsg = kvmsg_new (++sequence);
        kvmsg_fmt_key  (kvmsg, "%d", randof (10000));
        kvmsg_fmt_body (kvmsg, "%d", randof (1000000));
        kvmsg_send     (kvmsg, publisher);
        kvmsg_store   (&amp;kvmsg, kvmap);
    }
    printf (" Interrupted\n%d messages out\n", (int) sequence);
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);
    return 0;
}
</programlisting>

</example>
<para>And here is the client:</para>

<example id="clonecli1-c">
<title>Clone client, Model One (clonecli1.c)</title>
<programlisting language="c">
//
//  Clone client Model One
//

//  Lets us build this source without creating a library
#include "kvsimple.c"

int main (void)
{
    //  Prepare our context and updates socket
    zctx_t *ctx = zctx_new ();
    void *updates = zsocket_new (ctx, ZMQ_SUB);
    zsockopt_set_subscribe (updates, "");
    zsocket_connect (updates, "tcp://localhost:5556");

    zhash_t *kvmap = zhash_new ();
    int64_t sequence = 0;

    while (true) {
        kvmsg_t *kvmsg = kvmsg_recv (updates);
        if (!kvmsg)
            break;          //  Interrupted
        kvmsg_store (&amp;kvmsg, kvmap);
        sequence++;
    }
    printf (" Interrupted\n%d messages in\n", (int) sequence);
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);
    return 0;
}
</programlisting>

</example>
<para>Some notes about this code:</para>

<itemizedlist>
  <listitem><para>All the hard work is done in a <emphasis role="bold">kvmsg</emphasis> class. This class works with key-value message objects, which are multi-part &Oslash;MQ messages structured as three frames: a key (a &Oslash;MQ string), a sequence number (64-bit value, in network byte order), and a binary body (holds everything else).</para></listitem>
  <listitem><para>The server generates messages with a randomized 4-digit key, which lets us simulate a large but not enormous hash table (10K entries).</para></listitem>
  <listitem><para>The server does a 200 millisecond pause after binding its socket. This is to prevent "slow joiner syndrome" where the subscriber loses messages as it connects to the server's socket. We'll remove that in later models.</para></listitem>
  <listitem><para>We'll use the terms 'publisher' and 'subscriber' in the code to refer to sockets. This will help later when we have multiple sockets doing different things.</para></listitem>
</itemizedlist>
<para>Here is the kvmsg class, in the simplest form that works for now:</para>

<example id="kvsimple-c">
<title>Key-value message class (kvsimple.c)</title>
<programlisting language="c">
/*  =====================================================================
 *  kvsimple - simple key-value message class for example applications
 *  ===================================================================== */

#include "kvsimple.h"
#include "zlist.h"

//  Keys are short strings
#define KVMSG_KEY_MAX   255

//  Message is formatted on wire as 4 frames:
//  frame 0: key (0MQ string)
//  frame 1: sequence (8 bytes, network order)
//  frame 2: body (blob)
#define FRAME_KEY       0
#define FRAME_SEQ       1
#define FRAME_BODY      2
#define KVMSG_FRAMES    3

//  The kvmsg class holds a single key-value message consisting of a
//  list of 0 or more frames:

struct _kvmsg {
    //  Presence indicators for each frame
    int present [KVMSG_FRAMES];
    //  Corresponding 0MQ message frames, if any
    zmq_msg_t frame [KVMSG_FRAMES];
    //  Key, copied into safe C string
    char key [KVMSG_KEY_MAX + 1];
};
</programlisting>

</example>
<para>Here are the constructor and destructor for the class: 
</para>

<example id="kvsimple-c-1">
<title>Key-value message class (kvsimple.c) - constructor and destructor</title>
<programlisting language="c">


//  Constructor, takes a sequence number for the new kvmsg instance:
kvmsg_t *
kvmsg_new (int64_t sequence)
{
    kvmsg_t
        *self;

    self = (kvmsg_t *) zmalloc (sizeof (kvmsg_t));
    kvmsg_set_sequence (self, sequence);
    return self;
}

//  zhash_free_fn callback helper that does the low level destruction:
void
kvmsg_free (void *ptr)
{
    if (ptr) {
        kvmsg_t *self = (kvmsg_t *) ptr;
        //  Destroy message frames if any
        int frame_nbr;
        for (frame_nbr = 0; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++)
            if (self-&gt;present [frame_nbr])
                zmq_msg_close (&amp;self-&gt;frame [frame_nbr]);

        //  Free object itself
        free (self);
    }
}

//  Destructor
void
kvmsg_destroy (kvmsg_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        kvmsg_free (*self_p);
        *self_p = NULL;
    }
}
</programlisting>

</example>
<para>The recv method reads a key-value message from socket, and returns a new kvmsg instance: 
</para>

<example id="kvsimple-c-2">
<title>Key-value message class (kvsimple.c) - recv method</title>
<programlisting language="c">


kvmsg_t *
kvmsg_recv (void *socket)
{
    assert (socket);
    kvmsg_t *self = kvmsg_new (0);

    //  Read all frames off the wire, reject if bogus
    int frame_nbr;
    for (frame_nbr = 0; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++) {
        if (self-&gt;present [frame_nbr])
            zmq_msg_close (&amp;self-&gt;frame [frame_nbr]);
        zmq_msg_init (&amp;self-&gt;frame [frame_nbr]);
        self-&gt;present [frame_nbr] = 1;
        if (zmq_msg_recv (&amp;self-&gt;frame [frame_nbr], socket, 0) == -1) {
            kvmsg_destroy (&amp;self);
            break;
        }
        //  Verify multipart framing
        int rcvmore = (frame_nbr &lt; KVMSG_FRAMES - 1)? 1: 0;
        if (zsockopt_rcvmore (socket) != rcvmore) {
            kvmsg_destroy (&amp;self);
            break;
        }
    }
    return self;
}
</programlisting>

</example>
<para>The send method sends a multi-frame key-value message to a socket: 
</para>

<example id="kvsimple-c-3">
<title>Key-value message class (kvsimple.c) - send method</title>
<programlisting language="c">


void
kvmsg_send (kvmsg_t *self, void *socket)
{
    assert (self);
    assert (socket);

    int frame_nbr;
    for (frame_nbr = 0; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++) {
        zmq_msg_t copy;
        zmq_msg_init (&amp;copy);
        if (self-&gt;present [frame_nbr])
            zmq_msg_copy (&amp;copy, &amp;self-&gt;frame [frame_nbr]);
        zmq_msg_send (&amp;copy, socket, 
            (frame_nbr &lt; KVMSG_FRAMES - 1)? ZMQ_SNDMORE: 0);
        zmq_msg_close (&amp;copy);
    }
}
</programlisting>

</example>
<para>These methods let the caller get and set the message key, as a fixed string and as a printf formatted string: 
</para>

<example id="kvsimple-c-4">
<title>Key-value message class (kvsimple.c) - key methods</title>
<programlisting language="c">


char *
kvmsg_key (kvmsg_t *self)
{
    assert (self);
    if (self-&gt;present [FRAME_KEY]) {
        if (!*self-&gt;key) {
            size_t size = zmq_msg_size (&amp;self-&gt;frame [FRAME_KEY]);
            if (size &gt; KVMSG_KEY_MAX)
                size = KVMSG_KEY_MAX;
            memcpy (self-&gt;key,
                zmq_msg_data (&amp;self-&gt;frame [FRAME_KEY]), size);
            self-&gt;key [size] = 0;
        }
        return self-&gt;key;
    }
    else
        return NULL;
}

void
kvmsg_set_key (kvmsg_t *self, char *key)
{
    assert (self);
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_KEY];
    if (self-&gt;present [FRAME_KEY])
        zmq_msg_close (msg);
    zmq_msg_init_size (msg, strlen (key));
    memcpy (zmq_msg_data (msg), key, strlen (key));
    self-&gt;present [FRAME_KEY] = 1;
}

void
kvmsg_fmt_key (kvmsg_t *self, char *format, ...)
{
    char value [KVMSG_KEY_MAX + 1];
    va_list args;

    assert (self);
    va_start (args, format);
    vsnprintf (value, KVMSG_KEY_MAX, format, args);
    va_end (args);
    kvmsg_set_key (self, value);
}
</programlisting>

</example>
<para>These two methods let the caller get and set the message sequence number: 
</para>

<example id="kvsimple-c-5">
<title>Key-value message class (kvsimple.c) - sequence methods</title>
<programlisting language="c">


int64_t
kvmsg_sequence (kvmsg_t *self)
{
    assert (self);
    if (self-&gt;present [FRAME_SEQ]) {
        assert (zmq_msg_size (&amp;self-&gt;frame [FRAME_SEQ]) == 8);
        byte *source = zmq_msg_data (&amp;self-&gt;frame [FRAME_SEQ]);
        int64_t sequence = ((int64_t) (source [0]) &lt;&lt; 56)
                         + ((int64_t) (source [1]) &lt;&lt; 48)
                         + ((int64_t) (source [2]) &lt;&lt; 40)
                         + ((int64_t) (source [3]) &lt;&lt; 32)
                         + ((int64_t) (source [4]) &lt;&lt; 24)
                         + ((int64_t) (source [5]) &lt;&lt; 16)
                         + ((int64_t) (source [6]) &lt;&lt; 8)
                         +  (int64_t) (source [7]);
        return sequence;
    }
    else
        return 0;
}

void
kvmsg_set_sequence (kvmsg_t *self, int64_t sequence)
{
    assert (self);
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_SEQ];
    if (self-&gt;present [FRAME_SEQ])
        zmq_msg_close (msg);
    zmq_msg_init_size (msg, 8);

    byte *source = zmq_msg_data (msg);
    source [0] = (byte) ((sequence &gt;&gt; 56) &amp; 255);
    source [1] = (byte) ((sequence &gt;&gt; 48) &amp; 255);
    source [2] = (byte) ((sequence &gt;&gt; 40) &amp; 255);
    source [3] = (byte) ((sequence &gt;&gt; 32) &amp; 255);
    source [4] = (byte) ((sequence &gt;&gt; 24) &amp; 255);
    source [5] = (byte) ((sequence &gt;&gt; 16) &amp; 255);
    source [6] = (byte) ((sequence &gt;&gt; 8)  &amp; 255);
    source [7] = (byte) ((sequence)       &amp; 255);

    self-&gt;present [FRAME_SEQ] = 1;
}
</programlisting>

</example>
<para>These methods let the caller get and set the message body, as a fixed string and as a printf formatted string: 
</para>

<example id="kvsimple-c-6">
<title>Key-value message class (kvsimple.c) - message body methods</title>
<programlisting language="c">

byte *
kvmsg_body (kvmsg_t *self)
{
    assert (self);
    if (self-&gt;present [FRAME_BODY])
        return (byte *) zmq_msg_data (&amp;self-&gt;frame [FRAME_BODY]);
    else
        return NULL;
}

void
kvmsg_set_body (kvmsg_t *self, byte *body, size_t size)
{
    assert (self);
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_BODY];
    if (self-&gt;present [FRAME_BODY])
        zmq_msg_close (msg);
    self-&gt;present [FRAME_BODY] = 1;
    zmq_msg_init_size (msg, size);
    memcpy (zmq_msg_data (msg), body, size);
}

void
kvmsg_fmt_body (kvmsg_t *self, char *format, ...)
{
    char value [255 + 1];
    va_list args;

    assert (self);
    va_start (args, format);
    vsnprintf (value, 255, format, args);
    va_end (args);
    kvmsg_set_body (self, (byte *) value, strlen (value));
}
</programlisting>

</example>
<para>The size method returns the body size of the last-read message, if any: 
</para>

<example id="kvsimple-c-7">
<title>Key-value message class (kvsimple.c) - size method</title>
<programlisting language="c">


size_t
kvmsg_size (kvmsg_t *self)
{
    assert (self);
    if (self-&gt;present [FRAME_BODY])
        return zmq_msg_size (&amp;self-&gt;frame [FRAME_BODY]);
    else
        return 0;
}
</programlisting>

</example>
<para>The store method stores the key-value message into a hash map, unless the key and value are both null. It nullifies the kvmsg reference so that the object is owned by the hash map, not the caller: 
</para>

<example id="kvsimple-c-8">
<title>Key-value message class (kvsimple.c) - store method</title>
<programlisting language="c">

void
kvmsg_store (kvmsg_t **self_p, zhash_t *hash)
{
    assert (self_p);
    if (*self_p) {
        kvmsg_t *self = *self_p;
        assert (self);
        if (self-&gt;present [FRAME_KEY]
        &amp;&amp;  self-&gt;present [FRAME_BODY]) {
            zhash_update (hash, kvmsg_key (self), self);
            zhash_freefn (hash, kvmsg_key (self), kvmsg_free);
        }
        *self_p = NULL;
    }
}
</programlisting>

</example>
<para>The dump method prints the key-value message to stderr, for debugging and tracing: 
</para>

<example id="kvsimple-c-9">
<title>Key-value message class (kvsimple.c) - dump method</title>
<programlisting language="c">

void
kvmsg_dump (kvmsg_t *self)
{
    if (self) {
        if (!self) {
            fprintf (stderr, "NULL");
            return;
        }
        size_t size = kvmsg_size (self);
        byte  *body = kvmsg_body (self);
        fprintf (stderr, "[seq:%" PRId64 "]", kvmsg_sequence (self));
        fprintf (stderr, "[key:%s]", kvmsg_key (self));
        fprintf (stderr, "[size:%zd] ", size);
        int char_nbr;
        for (char_nbr = 0; char_nbr &lt; size; char_nbr++)
            fprintf (stderr, "%02X", body [char_nbr]);
        fprintf (stderr, "\n");
    }
    else
        fprintf (stderr, "NULL message\n");
}
</programlisting>

</example>
<para>It's good practice to have a self-test method that tests the class; this also shows how it's used in applications: 
</para>

<example id="kvsimple-c-10">
<title>Key-value message class (kvsimple.c) - test method</title>
<programlisting language="c">

int
kvmsg_test (int verbose)
{
    kvmsg_t
        *kvmsg;

    printf (" * kvmsg: ");

    //  Prepare our context and sockets
    zctx_t *ctx = zctx_new ();
    void *output = zsocket_new (ctx, ZMQ_DEALER);
    int rc = zmq_bind (output, "ipc://kvmsg_selftest.ipc");
    assert (rc == 0);
    void *input = zsocket_new (ctx, ZMQ_DEALER);
    rc = zmq_connect (input, "ipc://kvmsg_selftest.ipc");
    assert (rc == 0);

    zhash_t *kvmap = zhash_new ();

    //  Test send and receive of simple message
    kvmsg = kvmsg_new (1);
    kvmsg_set_key  (kvmsg, "key");
    kvmsg_set_body (kvmsg, (byte *) "body", 4);
    if (verbose)
        kvmsg_dump (kvmsg);
    kvmsg_send (kvmsg, output);
    kvmsg_store (&amp;kvmsg, kvmap);

    kvmsg = kvmsg_recv (input);
    if (verbose)
        kvmsg_dump (kvmsg);
    assert (streq (kvmsg_key (kvmsg), "key"));
    kvmsg_store (&amp;kvmsg, kvmap);

    //  Shutdown and destroy all objects
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);

    printf ("OK\n");
    return 0;
}
</programlisting>

</example>
<para>We'll make a more sophisticated kvmsg class later, for using in real applications.</para>

<para>Both the server and client maintain hash tables, but this first model only works properly if we start all clients before the server, and the clients never crash. That's not 'reliability'.</para>

</sect2>
<sect2>
<title>Getting a Snapshot</title>
<para>In order to allow a late (or recovering) client to catch up with a server it has to get a snapshot of the server's state. Just as we've reduced "message" to mean "a sequenced key-value pair", we can reduce "state" to mean "a hash table". To get the server state, a client opens a DEALER socket and asks for it explicitly(<xref linkend="figure-65"/>).</para>

<figure id="figure-65">
    <title>State Replication</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig65.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>To make this work, we have to solve the timing problem. Getting a state snapshot will take a certain time, possibly fairly long if the snapshot is large. We need to correctly apply updates to the snapshot. But the server won't know when to start sending us updates. One way would be to start subscribing, get a first update, and then ask for "state for update N". This would require the server storing one snapshot for each update, which isn't practical.</para>

<para>So we will do the synchronization in the client, as follows:</para>

<itemizedlist>
  <listitem><para>The client first subscribes to updates and then makes a state request. This guarantees that the state is going to be newer than the oldest update it has.</para></listitem>
  <listitem><para>The client waits for the server to reply with state, and meanwhile queues all updates. It does this simply by not reading them: &Oslash;MQ keeps them queued on the socket queue, since we don't set a HWM.</para></listitem>
  <listitem><para>When the client receives its state update, it begins once again to read updates. However it discards any updates that are older than the state update. So if the state update includes updates up to 200, the client will discard updates up to 201.</para></listitem>
  <listitem><para>The client then applies updates to its own state snapshot.</para></listitem>
</itemizedlist>
<para>It's a simple model that exploits &Oslash;MQ's own internal queues. Here's the server:</para>

<example id="clonesrv2-c">
<title>Clone server, Model Two (clonesrv2.c)</title>
<programlisting language="c">
//
//  Clone server Model Two
//

//  Lets us build this source without creating a library
#include "kvsimple.c"

static int s_send_single (const char *key, void *data, void *args);
static void state_manager (void *args, zctx_t *ctx, void *pipe);

int main (void)
{
    //  Prepare our context and sockets
    zctx_t *ctx = zctx_new ();
    void *publisher = zsocket_new (ctx, ZMQ_PUB);
    zsocket_bind (publisher, "tcp://*:5557");

    int64_t sequence = 0;
    srandom ((unsigned) time (NULL));

    //  Start state manager and wait for synchronization signal
    void *updates = zthread_fork (ctx, state_manager, NULL);
    free (zstr_recv (updates));

    while (!zctx_interrupted) {
        //  Distribute as key-value message
        kvmsg_t *kvmsg = kvmsg_new (++sequence);
        kvmsg_fmt_key  (kvmsg, "%d", randof (10000));
        kvmsg_fmt_body (kvmsg, "%d", randof (1000000));
        kvmsg_send     (kvmsg, publisher);
        kvmsg_send     (kvmsg, updates);
        kvmsg_destroy (&amp;kvmsg);
    }
    printf (" Interrupted\n%d messages out\n", (int) sequence);
    zctx_destroy (&amp;ctx);
    return 0;
}

//  Routing information for a key-value snapshot
typedef struct {
    void *socket;           //  ROUTER socket to send to
    zframe_t *identity;     //  Identity of peer who requested state
} kvroute_t;

//  Send one state snapshot key-value pair to a socket
//  Hash item data is our kvmsg object, ready to send
static int
s_send_single (const char *key, void *data, void *args)
{
    kvroute_t *kvroute = (kvroute_t *) args;
    //  Send identity of recipient first
    zframe_send (&amp;kvroute-&gt;identity,
        kvroute-&gt;socket, ZFRAME_MORE + ZFRAME_REUSE);
    kvmsg_t *kvmsg = (kvmsg_t *) data;
    kvmsg_send (kvmsg, kvroute-&gt;socket);
    return 0;
}
</programlisting>

</example>
<para>The state manager task maintains the state and handles requests from clients for snapshots: 
</para>

<example id="clonesrv2-c-1">
<title>Clone server, Model Two (clonesrv2.c) - state manager</title>
<programlisting language="c">

static void
state_manager (void *args, zctx_t *ctx, void *pipe)
{
    zhash_t *kvmap = zhash_new ();

    zstr_send (pipe, "READY");
    void *snapshot = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (snapshot, "tcp://*:5556");

    zmq_pollitem_t items [] = {
        { pipe, 0, ZMQ_POLLIN, 0 },
        { snapshot, 0, ZMQ_POLLIN, 0 }
    };
    int64_t sequence = 0;       //  Current snapshot version number
    while (!zctx_interrupted) {
        int rc = zmq_poll (items, 2, -1);
        if (rc == -1 &amp;&amp; errno == ETERM)
            break;              //  Context has been shut down

        //  Apply state update from main thread
        if (items [0].revents &amp; ZMQ_POLLIN) {
            kvmsg_t *kvmsg = kvmsg_recv (pipe);
            if (!kvmsg)
                break;          //  Interrupted
            sequence = kvmsg_sequence (kvmsg);
            kvmsg_store (&amp;kvmsg, kvmap);
        }
        //  Execute state snapshot request
        if (items [1].revents &amp; ZMQ_POLLIN) {
            zframe_t *identity = zframe_recv (snapshot);
            if (!identity)
                break;          //  Interrupted

            //  Request is in second frame of message
            char *request = zstr_recv (snapshot);
            if (streq (request, "ICANHAZ?"))
                free (request);
            else {
                printf ("E: bad request, aborting\n");
                break;
            }
            //  Send state snapshot to client
            kvroute_t routing = { snapshot, identity };

            //  For each entry in kvmap, send kvmsg to client
            zhash_foreach (kvmap, s_send_single, &amp;routing);

            //  Now send END message with sequence number
            printf ("Sending state shapshot=%d\n", (int) sequence);
            zframe_send (&amp;identity, snapshot, ZFRAME_MORE);
            kvmsg_t *kvmsg = kvmsg_new (sequence);
            kvmsg_set_key  (kvmsg, "KTHXBAI");
            kvmsg_set_body (kvmsg, (byte *) "", 0);
            kvmsg_send     (kvmsg, snapshot);
            kvmsg_destroy (&amp;kvmsg);
        }
    }
    zhash_destroy (&amp;kvmap);
}
</programlisting>

</example>
<para>And here is the client:</para>

<example id="clonecli2-c">
<title>Clone client, Model Two (clonecli2.c)</title>
<programlisting language="c">
//
//  Clone client Model Two
//

//  Lets us build this source without creating a library
#include "kvsimple.c"

int main (void)
{
    //  Prepare our context and subscriber
    zctx_t *ctx = zctx_new ();
    void *snapshot = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_connect (snapshot, "tcp://localhost:5556");
    void *subscriber = zsocket_new (ctx, ZMQ_SUB);
    zsockopt_set_subscribe (subscriber, "");
    zsocket_connect (subscriber, "tcp://localhost:5557");

    zhash_t *kvmap = zhash_new ();

    //  Get state snapshot
    int64_t sequence = 0;
    zstr_send (snapshot, "ICANHAZ?");
    while (true) {
        kvmsg_t *kvmsg = kvmsg_recv (snapshot);
        if (!kvmsg)
            break;          //  Interrupted
        if (streq (kvmsg_key (kvmsg), "KTHXBAI")) {
            sequence = kvmsg_sequence (kvmsg);
            printf ("Received snapshot=%d\n", (int) sequence);
            kvmsg_destroy (&amp;kvmsg);
            break;          //  Done
        }
        kvmsg_store (&amp;kvmsg, kvmap);
    }
    //  Now apply pending updates, discard out-of-sequence messages
    while (!zctx_interrupted) {
        kvmsg_t *kvmsg = kvmsg_recv (subscriber);
        if (!kvmsg)
            break;          //  Interrupted
        if (kvmsg_sequence (kvmsg) &gt; sequence) {
            sequence = kvmsg_sequence (kvmsg);
            kvmsg_store (&amp;kvmsg, kvmap);
        }
        else
            kvmsg_destroy (&amp;kvmsg);
    }
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);
    return 0;
}
</programlisting>

</example>
<para>Some notes about this code:</para>

<itemizedlist>
  <listitem><para>The server uses two threads, for simpler design. One thread produces random updates, and the second thread handles state. The two communicate across PAIR sockets. You might like to use SUB sockets but you'd hit the "slow joiner" problem where the subscriber would randomly miss some messages while connecting. PAIR sockets let us explicitly synchronize the two threads.</para></listitem>
  <listitem><para>We set a HWM on the updates socket pair, since hash table insertions are relatively slow. Without this, the server runs out of memory. On <literal>inproc</literal> connections, the real HWM is the sum of the HWM of <emphasis>both</emphasis> sockets, so we set the HWM on each socket.</para></listitem>
  <listitem><para>The client is really simple. In C, under 60 lines of code. A lot of the heavy lifting is done in the kvmsg class, but still, the basic Clone pattern is easier to implement than it seemed at first.</para></listitem>
  <listitem><para>We don't use anything fancy for serializing the state. The hash table holds a set of kvmsg objects, and the server sends these, as a batch of messages, to the client requesting state. If multiple clients request state at once, each will get a different snapshot.</para></listitem>
  <listitem><para>We assume that the client has exactly one server to talk to. The server <emphasis role="bold">must</emphasis> be running; we do not try to solve the question of what happens if the server crashes.</para></listitem>
</itemizedlist>
<para>Right now, these two programs don't do anything real, but they correctly synchronize state. It's a neat example of how to mix different patterns: PAIR-over-inproc, PUB-SUB, and ROUTER-DEALER.</para>

</sect2>
<sect2>
<title>Republishing Updates</title>
<para>In our second model, changes to the key-value cache came from the server itself. This is a centralized model, useful for example if we have a central configuration file we want to distribute, with local caching on each node. A more interesting model takes updates from clients, not the server. The server thus becomes a stateless broker. This gives us some benefits:</para>

<itemizedlist>
  <listitem><para>We're less worried about the reliability of the server. If it crashes, we can start a new instance, and feed it new values.</para></listitem>
  <listitem><para>We can use the key-value cache to share knowledge between dynamic peers.</para></listitem>
</itemizedlist>
<para>Updates from clients go via a PUSH-PULL socket flow from client to server(<xref linkend="figure-66"/>).</para>

<figure id="figure-66">
    <title>Republishing Updates</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig66.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>Why don't we allow clients to publish updates directly to other clients? While this would reduce latency, it makes it impossible to assign ascending unique sequence numbers to messages. The server can do this. There's a more subtle second reason. In many applications it's important that updates have a single order, across many clients. Forcing all updates through the server ensures that they have the same order when they finally get to clients.</para>

<para>With unique sequencing, clients can detect the nastier failures - network congestion and queue overflow. If a client discovers that its incoming message stream has a hole, it can take action. It seems sensible that the client contact the server and ask for the missing messages, but in practice that isn't useful. If there are holes, they're caused by network stress, and adding more stress to the network will make things worse. All the client can really do is warn its users "Unable to continue", and stop, and not restart until someone has manually checked the cause of the problem.</para>

<para>We'll now generate state updates in the client. Here's the server:</para>

<example id="clonesrv3-c">
<title>Clone server, Model Three (clonesrv3.c)</title>
<programlisting language="c">
//
//  Clone server Model Three
//

//  Lets us build this source without creating a library
#include "kvsimple.c"

//  Routing information for a key-value snapshot
typedef struct {
    void *socket;           //  ROUTER socket to send to
    zframe_t *identity;     //  Identity of peer who requested state
} kvroute_t;

//  Send one state snapshot key-value pair to a socket
//  Hash item data is our kvmsg object, ready to send
static int
s_send_single (const char *key, void *data, void *args)
{
    kvroute_t *kvroute = (kvroute_t *) args;
    //  Send identity of recipient first
    zframe_send (&amp;kvroute-&gt;identity,
        kvroute-&gt;socket, ZFRAME_MORE + ZFRAME_REUSE);
    kvmsg_t *kvmsg = (kvmsg_t *) data;
    kvmsg_send (kvmsg, kvroute-&gt;socket);
    return 0;
}

int main (void)
{
    //  Prepare our context and sockets
    zctx_t *ctx = zctx_new ();
    void *snapshot = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (snapshot, "tcp://*:5556");
    void *publisher = zsocket_new (ctx, ZMQ_PUB);
    zsocket_bind (publisher, "tcp://*:5557");
    void *collector = zsocket_new (ctx, ZMQ_PULL);
    zsocket_bind (collector, "tcp://*:5558");
</programlisting>

</example>
<para>The body of the main task collects updates from clients and publishes them back out to clients: 
</para>

<example id="clonesrv3-c-1">
<title>Clone server, Model Three (clonesrv3.c) - body of main task</title>
<programlisting language="c">

    int64_t sequence = 0;
    zhash_t *kvmap = zhash_new ();

    zmq_pollitem_t items [] = {
        { collector, 0, ZMQ_POLLIN, 0 },
        { snapshot, 0, ZMQ_POLLIN, 0 }
    };
    while (!zctx_interrupted) {
        int rc = zmq_poll (items, 2, 1000 * ZMQ_POLL_MSEC);

        //  Apply state update sent from client
        if (items [0].revents &amp; ZMQ_POLLIN) {
            kvmsg_t *kvmsg = kvmsg_recv (collector);
            if (!kvmsg)
                break;          //  Interrupted
            kvmsg_set_sequence (kvmsg, ++sequence);
            kvmsg_send (kvmsg, publisher);
            kvmsg_store (&amp;kvmsg, kvmap);
            printf ("I: publishing update %5d\n", (int) sequence);
        }
        //  Execute state snapshot request
        if (items [1].revents &amp; ZMQ_POLLIN) {
            zframe_t *identity = zframe_recv (snapshot);
            if (!identity)
                break;          //  Interrupted

            //  Request is in second frame of message
            char *request = zstr_recv (snapshot);
            if (streq (request, "ICANHAZ?"))
                free (request);
            else {
                printf ("E: bad request, aborting\n");
                break;
            }
            //  Send state snapshot to client
            kvroute_t routing = { snapshot, identity };

            //  For each entry in kvmap, send kvmsg to client
            zhash_foreach (kvmap, s_send_single, &amp;routing);

            //  Now send END message with sequence number
            printf ("I: sending shapshot=%d\n", (int) sequence);
            zframe_send (&amp;identity, snapshot, ZFRAME_MORE);
            kvmsg_t *kvmsg = kvmsg_new (sequence);
            kvmsg_set_key  (kvmsg, "KTHXBAI");
            kvmsg_set_body (kvmsg, (byte *) "", 0);
            kvmsg_send     (kvmsg, snapshot);
            kvmsg_destroy (&amp;kvmsg);
        }
    }
    printf (" Interrupted\n%d messages handled\n", (int) sequence);
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);

    return 0;
}
</programlisting>

</example>
<para>And here is the client:</para>

<example id="clonecli3-c">
<title>Clone client, Model Three (clonecli3.c)</title>
<programlisting language="c">
//
//  Clone client Model Three
//

//  Lets us build this source without creating a library
#include "kvsimple.c"

int main (void)
{
    //  Prepare our context and subscriber
    zctx_t *ctx = zctx_new ();
    void *snapshot = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_connect (snapshot, "tcp://localhost:5556");
    void *subscriber = zsocket_new (ctx, ZMQ_SUB);
    zsockopt_set_subscribe (subscriber, "");
    zsocket_connect (subscriber, "tcp://localhost:5557");
    void *publisher = zsocket_new (ctx, ZMQ_PUSH);
    zsocket_connect (publisher, "tcp://localhost:5558");

    zhash_t *kvmap = zhash_new ();
    srandom ((unsigned) time (NULL));
</programlisting>

</example>
<para>We first request a state snapshot: 
</para>

<example id="clonecli3-c-1">
<title>Clone client, Model Three (clonecli3.c) - getting a state snapshot</title>
<programlisting language="c">

    zstr_send (snapshot, "ICANHAZ?");
    while (true) {
        kvmsg_t *kvmsg = kvmsg_recv (snapshot);
        if (!kvmsg)
            break;          //  Interrupted
        if (streq (kvmsg_key (kvmsg), "KTHXBAI")) {
            sequence = kvmsg_sequence (kvmsg);
            printf ("I: received snapshot=%d\n", (int) sequence);
            kvmsg_destroy (&amp;kvmsg);
            break;          //  Done
        }
        kvmsg_store (&amp;kvmsg, kvmap);
    }
</programlisting>

</example>
<para>Now we wait for updates from the server, and every so often, we send a random key-value update to the server: 
</para>

<example id="clonecli3-c-2">
<title>Clone client, Model Three (clonecli3.c) - processing state updates</title>
<programlisting language="c">
    int64_t alarm = zclock_time () + 1000;
    while (!zctx_interrupted) {
        zmq_pollitem_t items [] = { { subscriber, 0, ZMQ_POLLIN, 0 } };
        int tickless = (int) ((alarm - zclock_time ()));
        if (tickless &lt; 0)
            tickless = 0;
        int rc = zmq_poll (items, 1, tickless * ZMQ_POLL_MSEC);
        if (rc == -1)
            break;              //  Context has been shut down

        if (items [0].revents &amp; ZMQ_POLLIN) {
            kvmsg_t *kvmsg = kvmsg_recv (subscriber);
            if (!kvmsg)
                break;          //  Interrupted

            //  Discard out-of-sequence kvmsgs, incl. heartbeats
            if (kvmsg_sequence (kvmsg) &gt; sequence) {
                sequence = kvmsg_sequence (kvmsg);
                kvmsg_store (&amp;kvmsg, kvmap);
                printf ("I: received update=%d\n", (int) sequence);
            }
            else
                kvmsg_destroy (&amp;kvmsg);
        }
        //  If we timed-out, generate a random kvmsg
        if (zclock_time () &gt;= alarm) {
            kvmsg_t *kvmsg = kvmsg_new (0);
            kvmsg_fmt_key  (kvmsg, "%d", randof (10000));
            kvmsg_fmt_body (kvmsg, "%d", randof (1000000));
            kvmsg_send     (kvmsg, publisher);
            kvmsg_destroy (&amp;kvmsg);
            alarm = zclock_time () + 1000;
        }
    }
    printf (" Interrupted\n%d messages in\n", (int) sequence);
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);
    return 0;
}
</programlisting>

</example>
<para>Some notes about this code:</para>

<itemizedlist>
  <listitem><para>The server has collapsed to a single task. It manages a PULL socket for incoming updates, a ROUTER socket for state requests, and a PUB socket for outgoing updates.</para></listitem>
  <listitem><para>The client uses a simple tickless timer to send a random update to the server once a second. In a real implementation we would drive updates from application code.</para></listitem>
</itemizedlist>
</sect2>
<sect2>
<title>Clone Subtrees</title>
<para>A realistic key-value cache will get large, and clients will usually be interested only in parts of the cache. Working with a subtree is fairly simple. The client has to tell the server the subtree when it makes a state request, and it has to specify the same subtree when it subscribes to updates.</para>

<para>There are a couple of common syntaxes for trees. One is the "path hierarchy", and another is the "topic tree". These look like:</para>

<itemizedlist>
  <listitem><para>Path hierarchy: "/some/list/of/paths"</para></listitem>
  <listitem><para>Topic tree: "some.list.of.topics"</para></listitem>
</itemizedlist>
<para>We'll use the path hierarchy, and extend our client and server so that a client can work with a single subtree. Working with multiple subtrees is not much more difficult, we won't do that here but it's a trivial extension.</para>

<para>Here's the server, a small variation on Model Three:</para>

<example id="clonesrv4-c">
<title>Clone server, Model Four (clonesrv4.c)</title>
<programlisting language="c">
//
//  Clone server Model Four
//

//  Lets us build this source without creating a library
#include "kvsimple.c"

//  Routing information for a key-value snapshot
typedef struct {
    void *socket;           //  ROUTER socket to send to
    zframe_t *identity;     //  Identity of peer who requested state
    char *subtree;          //  Client subtree specification
} kvroute_t;

//  Send one state snapshot key-value pair to a socket
//  Hash item data is our kvmsg object, ready to send
static int
s_send_single (const char *key, void *data, void *args)
{
    kvroute_t *kvroute = (kvroute_t *) args;
    kvmsg_t *kvmsg = (kvmsg_t *) data;
    if (strlen (kvroute-&gt;subtree) &lt;= strlen (kvmsg_key (kvmsg))
    &amp;&amp;  memcmp (kvroute-&gt;subtree,
                kvmsg_key (kvmsg), strlen (kvroute-&gt;subtree)) == 0) {
        //  Send identity of recipient first
        zframe_send (&amp;kvroute-&gt;identity,
            kvroute-&gt;socket, ZFRAME_MORE + ZFRAME_REUSE);
        kvmsg_send (kvmsg, kvroute-&gt;socket);
    }
    return 0;
}

//  The main task is identical to clonesrv3 except for where it
//  handles subtrees.
...
            //  Request is in second frame of message
            char *request = zstr_recv (snapshot);
            char *subtree = NULL;
            if (streq (request, "ICANHAZ?")) {
                free (request);
                subtree = zstr_recv (snapshot);
            }
...
            //  Send state snapshot to client
            kvroute_t routing = { snapshot, identity, subtree };
...
            //  Now send END message with sequence number
            printf ("I: sending shapshot=%d\n", (int) sequence);
            zframe_send (&amp;identity, snapshot, ZFRAME_MORE);
            kvmsg_t *kvmsg = kvmsg_new (sequence);
            kvmsg_set_key  (kvmsg, "KTHXBAI");
            kvmsg_set_body (kvmsg, (byte *) subtree, 0);
            kvmsg_send     (kvmsg, snapshot);
            kvmsg_destroy (&amp;kvmsg);
            free (subtree);
        }
    }
...
</programlisting>

</example>
<para>And here is the client:</para>

<example id="clonecli4-c">
<title>Clone client, Model Four (clonecli4.c)</title>
<programlisting language="c">
//
//  Clone client Model Four
//

//  Lets us build this source without creating a library
#include "kvsimple.c"

//  This client is identical to clonecli3 except for where we
//  handles subtrees.
#define SUBTREE "/client/"
...
    zsocket_connect (subscriber, "tcp://localhost:5557");
    zsockopt_set_subscribe (subscriber, SUBTREE);
...
    //  We first request a state snapshot:
    int64_t sequence = 0;
    zstr_sendm (snapshot, "ICANHAZ?");
    zstr_send  (snapshot, SUBTREE);
...
        //  If we timed-out, generate a random kvmsg
        if (zclock_time () &gt;= alarm) {
            kvmsg_t *kvmsg = kvmsg_new (0);
            kvmsg_fmt_key  (kvmsg, "%s%d", SUBTREE, randof (10000));
            kvmsg_fmt_body (kvmsg, "%d", randof (1000000));
            kvmsg_send     (kvmsg, publisher);
            kvmsg_destroy (&amp;kvmsg);
            alarm = zclock_time () + 1000;
        }
...
</programlisting>

</example>
</sect2>
<sect2>
<title>Ephemeral Values</title>
<para>An ephemeral value is one that expires dynamically. If you think of Clone being used for a DNS-like service, then ephemeral values would let you do dynamic DNS. A node joins the network, publishes its address, and refreshes this regularly. If the node dies, its address eventually gets removed.</para>

<para>The usual abstraction for ephemeral values is to attach them to a "session", and delete them when the session ends. In Clone, sessions would be defined by clients, and would end if the client died.</para>

<para>The simpler alternative to using sessions is to define every ephemeral value with a "time to live" that tells the server when to expire the value. Clients then refresh values, and if they don't, the values expire.</para>

<para>I'm going to implement that simpler model because we don't know yet that it's worth making a more complex one. The difference is really in performance. If clients have a handful of ephemeral values, it's fine to set a TTL on each one. If clients use masses of ephemeral values, it's more efficient to attach them to sessions, and expire them in bulk.</para>

<para>First off, we need a way to encode the TTL in the key-value message. We could add a frame. The problem with using frames for properties is that each time we want to add a new property, we have to change the structure of our kvmsg class. It breaks compatibility. So let's add a 'properties' frame to the message, and code to let us get and put property values.</para>

<para>Next, we need a way to say, "delete this value". Up to now servers and clients have always blindly inserted or updated new values into their hash table. We'll say that if the value is empty, that means "delete this key".</para>

<para>Here's a more complete version of the kvmsg class, which implements a 'properties' frame (and adds a UUID frame, which we'll need later on). It also handles empty values by deleting the key from the hash, if necessary:</para>

<example id="kvmsg-c">
<title>Key-value message class - full (kvmsg.c)</title>
<programlisting language="c">
/*  =====================================================================
 *  kvmsg - key-value message class for example applications
 *  ===================================================================== */

#include "kvmsg.h"
#include &lt;uuid/uuid.h&gt;
#include "zlist.h"

//  Keys are short strings
#define KVMSG_KEY_MAX   255

//  Message is formatted on wire as 4 frames:
//  frame 0: key (0MQ string)
//  frame 1: sequence (8 bytes, network order)
//  frame 2: uuid (blob, 16 bytes)
//  frame 3: properties (0MQ string)
//  frame 4: body (blob)
#define FRAME_KEY       0
#define FRAME_SEQ       1
#define FRAME_UUID      2
#define FRAME_PROPS     3
#define FRAME_BODY      4
#define KVMSG_FRAMES    5

//  Structure of our class
struct _kvmsg {
    //  Presence indicators for each frame
    int present [KVMSG_FRAMES];
    //  Corresponding 0MQ message frames, if any
    zmq_msg_t frame [KVMSG_FRAMES];
    //  Key, copied into safe C string
    char key [KVMSG_KEY_MAX + 1];
    //  List of properties, as name=value strings
    zlist_t *props;
    size_t props_size;
};
</programlisting>

</example>
<para>These two helpers serialize a list of properties to and from a message frame: 
</para>

<example id="kvmsg-c-1">
<title>Key-value message class - full (kvmsg.c) - property encoding</title>
<programlisting language="c">

static void
s_encode_props (kvmsg_t *self)
{
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_PROPS];
    if (self-&gt;present [FRAME_PROPS])
        zmq_msg_close (msg);

    zmq_msg_init_size (msg, self-&gt;props_size);
    char *prop = zlist_first (self-&gt;props);
    char *dest = (char *) zmq_msg_data (msg);
    while (prop) {
        strcpy (dest, prop);
        dest += strlen (prop);
        *dest++ = '\n';
        prop = zlist_next (self-&gt;props);
    }
    self-&gt;present [FRAME_PROPS] = 1;
}

static void
s_decode_props (kvmsg_t *self)
{
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_PROPS];
    self-&gt;props_size = 0;
    while (zlist_size (self-&gt;props))
        free (zlist_pop (self-&gt;props));

    size_t remainder = zmq_msg_size (msg);
    char *prop = (char *) zmq_msg_data (msg);
    char *eoln = memchr (prop, '\n', remainder);
    while (eoln) {
        *eoln = 0;
        zlist_append (self-&gt;props, strdup (prop));
        self-&gt;props_size += strlen (prop) + 1;
        remainder -= strlen (prop) + 1;
        prop = eoln + 1;
        eoln = memchr (prop, '\n', remainder);
    }
}
</programlisting>

</example>
<para>Here are the constructor and destructor for the class: 
</para>

<example id="kvmsg-c-2">
<title>Key-value message class - full (kvmsg.c) - constructor and destructor</title>
<programlisting language="c">

//  Constructor, takes a sequence number for the new kvmsg instance:
kvmsg_t *
kvmsg_new (int64_t sequence)
{
    kvmsg_t
        *self;

    self = (kvmsg_t *) zmalloc (sizeof (kvmsg_t));
    self-&gt;props = zlist_new ();
    kvmsg_set_sequence (self, sequence);
    return self;
}

//  zhash_free_fn callback helper that does the low level destruction:
void
kvmsg_free (void *ptr)
{
    if (ptr) {
        kvmsg_t *self = (kvmsg_t *) ptr;
        //  Destroy message frames if any
        int frame_nbr;
        for (frame_nbr = 0; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++)
            if (self-&gt;present [frame_nbr])
                zmq_msg_close (&amp;self-&gt;frame [frame_nbr]);

        //  Destroy property list
        while (zlist_size (self-&gt;props))
            free (zlist_pop (self-&gt;props));
        zlist_destroy (&amp;self-&gt;props);

        //  Free object itself
        free (self);
    }
}

//  Destructor
void
kvmsg_destroy (kvmsg_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        kvmsg_free (*self_p);
        *self_p = NULL;
    }
}
</programlisting>

</example>
<para>The recv method reads a key-value message from socket, and returns a new kvmsg instance: 
</para>

<example id="kvmsg-c-3">
<title>Key-value message class - full (kvmsg.c) - recv method</title>
<programlisting language="c">

kvmsg_t *
kvmsg_recv (void *socket)
{
    //  This method is almost unchanged from kvsimple
...
    if (self)
        s_decode_props (self);
    return self;
}


//  ---------------------------------------------------------------------
//  Send key-value message to socket; any empty frames are sent as such.

void
kvmsg_send (kvmsg_t *self, void *socket)
{
    assert (self);
    assert (socket);

    s_encode_props (self);
    //  The rest of the method is unchanged from kvsimple
...
</programlisting>

</example>
<para>The dup method duplicates a kvmsg instance, returns the new instance: 
</para>

<example id="kvmsg-c-4">
<title>Key-value message class - full (kvmsg.c) - dup method</title>
<programlisting language="c">

kvmsg_t *
kvmsg_dup (kvmsg_t *self)
{
    kvmsg_t *kvmsg = kvmsg_new (0);
    int frame_nbr;
    for (frame_nbr = 0; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++) {
        if (self-&gt;present [frame_nbr]) {
            zmq_msg_t *src = &amp;self-&gt;frame [frame_nbr];
            zmq_msg_t *dst = &amp;kvmsg-&gt;frame [frame_nbr];
            zmq_msg_init_size (dst, zmq_msg_size (src));
            memcpy (zmq_msg_data (dst),
                    zmq_msg_data (src), zmq_msg_size (src));
            kvmsg-&gt;present [frame_nbr] = 1;
        }
    }
    kvmsg-&gt;props_size = zlist_size (self-&gt;props);
    char *prop = (char *) zlist_first (self-&gt;props);
    while (prop) {
        zlist_append (kvmsg-&gt;props, strdup (prop));
        prop = (char *) zlist_next (self-&gt;props);
    }
    return kvmsg;
}

//  The key, sequence, body, and size methods are the same as in kvsimple.
...
</programlisting>

</example>
<para>These methods get/set the UUID for the key-value message: 
</para>

<example id="kvmsg-c-5">
<title>Key-value message class - full (kvmsg.c) - UUID methods</title>
<programlisting language="c">

byte *
kvmsg_uuid (kvmsg_t *self)
{
    assert (self);
    if (self-&gt;present [FRAME_UUID]
    &amp;&amp;  zmq_msg_size (&amp;self-&gt;frame [FRAME_UUID]) == sizeof (uuid_t))
        return (byte *) zmq_msg_data (&amp;self-&gt;frame [FRAME_UUID]);
    else
        return NULL;
}

//  Sets the UUID to a random generated value
void
kvmsg_set_uuid (kvmsg_t *self)
{
    assert (self);
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_UUID];
    uuid_t uuid;
    uuid_generate (uuid);
    if (self-&gt;present [FRAME_UUID])
        zmq_msg_close (msg);
    zmq_msg_init_size (msg, sizeof (uuid));
    memcpy (zmq_msg_data (msg), uuid, sizeof (uuid));
    self-&gt;present [FRAME_UUID] = 1;
}
</programlisting>

</example>
<para>These methods get/set a specified message property: 
</para>

<example id="kvmsg-c-6">
<title>Key-value message class - full (kvmsg.c) - property methods</title>
<programlisting language="c">


//  Get message property, return "" if no such property is defined.
char *
kvmsg_get_prop (kvmsg_t *self, char *name)
{
    assert (strchr (name, '=') == NULL);
    char *prop = zlist_first (self-&gt;props);
    size_t namelen = strlen (name);
    while (prop) {
        if (strlen (prop) &gt; namelen
        &amp;&amp;  memcmp (prop, name, namelen) == 0
        &amp;&amp;  prop [namelen] == '=')
            return prop + namelen + 1;
        prop = zlist_next (self-&gt;props);
    }
    return "";
}


//  Set message property. Property name cannot contain '='. Max length of
//  value is 255 chars.
void
kvmsg_set_prop (kvmsg_t *self, char *name, char *format, ...)
{
    assert (strchr (name, '=') == NULL);

    char value [255 + 1];
    va_list args;
    assert (self);
    va_start (args, format);
    vsnprintf (value, 255, format, args);
    va_end (args);

    //  Allocate name=value string
    char *prop = malloc (strlen (name) + strlen (value) + 2);

    //  Remove existing property if any
    sprintf (prop, "%s=", name);
    char *existing = zlist_first (self-&gt;props);
    while (existing) {
        if (memcmp (prop, existing, strlen (prop)) == 0) {
            self-&gt;props_size -= strlen (existing) + 1;
            zlist_remove (self-&gt;props, existing);
            free (existing);
            break;
        }
        existing = zlist_next (self-&gt;props);
    }
    //  Add new name=value property string
    strcat (prop, value);
    zlist_append (self-&gt;props, prop);
    self-&gt;props_size += strlen (prop) + 1;
}
</programlisting>

</example>
<para>The store method stores the key-value message into a hash map, unless the key and value are both null. It nullifies the kvmsg reference so that the object is owned by the hash map, not the caller: 
</para>

<example id="kvmsg-c-7">
<title>Key-value message class - full (kvmsg.c) - store method</title>
<programlisting language="c">

void
kvmsg_store (kvmsg_t **self_p, zhash_t *hash)
{
    assert (self_p);
    if (*self_p) {
        kvmsg_t *self = *self_p;
        assert (self);
        if (kvmsg_size (self)) {
            if (self-&gt;present [FRAME_KEY]
            &amp;&amp;  self-&gt;present [FRAME_BODY]) {
                zhash_update (hash, kvmsg_key (self), self);
                zhash_freefn (hash, kvmsg_key (self), kvmsg_free);
            }
        }
        else
            zhash_delete (hash, kvmsg_key (self));

        *self_p = NULL;
    }
}
</programlisting>

</example>
<para>The dump method extends the kvsimple implementation with support for message properties: 
</para>

<example id="kvmsg-c-8">
<title>Key-value message class - full (kvmsg.c) - dump method</title>
<programlisting language="c">

void
kvmsg_dump (kvmsg_t *self)
{
...
        fprintf (stderr, "[size:%zd] ", size);
        if (zlist_size (self-&gt;props)) {
            fprintf (stderr, "[");
            char *prop = zlist_first (self-&gt;props);
            while (prop) {
                fprintf (stderr, "%s;", prop);
                prop = zlist_next (self-&gt;props);
            }
            fprintf (stderr, "]");
        }
...
</programlisting>

</example>
<para>The selftest method is the same as in kvsimple with added support for the uuid and property features of kvmsg: 
</para>

<example id="kvmsg-c-9">
<title>Key-value message class - full (kvmsg.c) - test method</title>
<programlisting language="c">

int
kvmsg_test (int verbose)
{
...
    //  Test send and receive of simple message
    kvmsg = kvmsg_new (1);
    kvmsg_set_key  (kvmsg, "key");
    kvmsg_set_uuid (kvmsg);
    kvmsg_set_body (kvmsg, (byte *) "body", 4);
    if (verbose)
        kvmsg_dump (kvmsg);
    kvmsg_send (kvmsg, output);
    kvmsg_store (&amp;kvmsg, kvmap);

    kvmsg = kvmsg_recv (input);
    if (verbose)
        kvmsg_dump (kvmsg);
    assert (streq (kvmsg_key (kvmsg), "key"));
    kvmsg_store (&amp;kvmsg, kvmap);

    //  Test send and receive of message with properties
    kvmsg = kvmsg_new (2);
    kvmsg_set_prop (kvmsg, "prop1", "value1");
    kvmsg_set_prop (kvmsg, "prop2", "value1");
    kvmsg_set_prop (kvmsg, "prop2", "value2");
    kvmsg_set_key  (kvmsg, "key");
    kvmsg_set_uuid (kvmsg);
    kvmsg_set_body (kvmsg, (byte *) "body", 4);
    assert (streq (kvmsg_get_prop (kvmsg, "prop2"), "value2"));
    if (verbose)
        kvmsg_dump (kvmsg);
    kvmsg_send (kvmsg, output);
    kvmsg_destroy (&amp;kvmsg);

    kvmsg = kvmsg_recv (input);
    if (verbose)
        kvmsg_dump (kvmsg);
    assert (streq (kvmsg_key (kvmsg), "key"));
    assert (streq (kvmsg_get_prop (kvmsg, "prop2"), "value2"));
    kvmsg_destroy (&amp;kvmsg);
...
</programlisting>

</example>
<para>The Model Five client is almost identical to Model Four. Diff is your friend. It uses the full kvmsg class instead of kvsimple, and sets a randomized 'ttl' property (measured in seconds) on each message:</para>

<programlisting language="c">
kvmsg_set_prop (kvmsg, "ttl", "%d", randof (30));
</programlisting>

<para>The Model Five server has totally changed. Instead of a poll loop, we're now using a reactor. This just makes it simpler to mix timers and socket events. Unfortunately in C the reactor style is more verbose. Your mileage will vary in other languages. But reactors seem to be a better way of building more complex &Oslash;MQ applications. Here's the server:</para>

<example id="clonesrv5-c">
<title>Clone server, Model Five (clonesrv5.c)</title>
<programlisting language="c">
//
//  Clone server Model Five
//

//  Lets us build this source without creating a library
#include "kvmsg.c"

//  zloop reactor handlers
static int s_snapshots  (zloop_t *loop, zmq_pollitem_t *poller, void *args);
static int s_collector  (zloop_t *loop, zmq_pollitem_t *poller, void *args);
static int s_flush_ttl  (zloop_t *loop, zmq_pollitem_t *poller, void *args);

//  Our server is defined by these properties
typedef struct {
    zctx_t *ctx;                //  Context wrapper
    zhash_t *kvmap;             //  Key-value store
    zloop_t *loop;              //  zloop reactor
    int port;                   //  Main port we're working on
    int64_t sequence;           //  How many updates we're at
    void *snapshot;             //  Handle snapshot requests
    void *publisher;            //  Publish updates to clients
    void *collector;            //  Collect updates from clients
} clonesrv_t;


int main (void)
{
    clonesrv_t *self = (clonesrv_t *) zmalloc (sizeof (clonesrv_t));

    self-&gt;port = 5556;
    self-&gt;ctx = zctx_new ();
    self-&gt;kvmap = zhash_new ();
    self-&gt;loop = zloop_new ();
    zloop_set_verbose (self-&gt;loop, FALSE);

    //  Set up our clone server sockets
    self-&gt;snapshot  = zsocket_new (self-&gt;ctx, ZMQ_ROUTER);
    self-&gt;publisher = zsocket_new (self-&gt;ctx, ZMQ_PUB);
    self-&gt;collector = zsocket_new (self-&gt;ctx, ZMQ_PULL);
    zsocket_bind (self-&gt;snapshot,  "tcp://*:%d", self-&gt;port);
    zsocket_bind (self-&gt;publisher, "tcp://*:%d", self-&gt;port + 1);
    zsocket_bind (self-&gt;collector, "tcp://*:%d", self-&gt;port + 2);

    //  Register our handlers with reactor
    zmq_pollitem_t poller = { self-&gt;snapshot, 0, ZMQ_POLLIN };
    zloop_poller (self-&gt;loop, &amp;poller, s_snapshots, self);
    poller.socket = self-&gt;collector;
    zloop_poller (self-&gt;loop, &amp;poller, s_collector, self);
    zloop_timer  (self-&gt;loop, 1000, 0, s_flush_ttl, self);

    //  Run reactor until process interrupted
    zloop_start (self-&gt;loop);

    zloop_destroy (&amp;self-&gt;loop);
    zhash_destroy (&amp;self-&gt;kvmap);
    zctx_destroy (&amp;self-&gt;ctx);
    free (self);
    return 0;
}
</programlisting>

</example>
<para>We handle ICANHAZ? requests by sending snapshot data to the client that requested it: 
</para>

<example id="clonesrv5-c-1">
<title>Clone server, Model Five (clonesrv5.c) - send snapshots</title>
<programlisting language="c">

//  Routing information for a key-value snapshot
typedef struct {
    void *socket;           //  ROUTER socket to send to
    zframe_t *identity;     //  Identity of peer who requested state
    char *subtree;          //  Client subtree specification
} kvroute_t;

//  We call this function for each key-value pair in our hash table
static int
s_send_single (const char *key, void *data, void *args)
{
    kvroute_t *kvroute = (kvroute_t *) args;
    kvmsg_t *kvmsg = (kvmsg_t *) data;
    if (strlen (kvroute-&gt;subtree) &lt;= strlen (kvmsg_key (kvmsg))
    &amp;&amp;  memcmp (kvroute-&gt;subtree,
                kvmsg_key (kvmsg), strlen (kvroute-&gt;subtree)) == 0) {
        zframe_send (&amp;kvroute-&gt;identity,    //  Choose recipient
            kvroute-&gt;socket, ZFRAME_MORE + ZFRAME_REUSE);
        kvmsg_send (kvmsg, kvroute-&gt;socket);
    }
    return 0;
}
</programlisting>

</example>
<para>This is the reactor handler for the snapshot socket; it accepts just the ICANHAZ? request and replies with a state snapshot ending with a KTHXBAI message: 
</para>

<example id="clonesrv5-c-2">
<title>Clone server, Model Five (clonesrv5.c) - snapshot handler</title>
<programlisting language="c">

static int
s_snapshots (zloop_t *loop, zmq_pollitem_t *poller, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;

    zframe_t *identity = zframe_recv (poller-&gt;socket);
    if (identity) {
        //  Request is in second frame of message
        char *request = zstr_recv (poller-&gt;socket);
        char *subtree = NULL;
        if (streq (request, "ICANHAZ?")) {
            free (request);
            subtree = zstr_recv (poller-&gt;socket);
        }
        else
            printf ("E: bad request, aborting\n");

        if (subtree) {
            //  Send state socket to client
            kvroute_t routing = { poller-&gt;socket, identity, subtree };
            zhash_foreach (self-&gt;kvmap, s_send_single, &amp;routing);

            //  Now send END message with sequence number
            zclock_log ("I: sending shapshot=%d", (int) self-&gt;sequence);
            zframe_send (&amp;identity, poller-&gt;socket, ZFRAME_MORE);
            kvmsg_t *kvmsg = kvmsg_new (self-&gt;sequence);
            kvmsg_set_key  (kvmsg, "KTHXBAI");
            kvmsg_set_body (kvmsg, (byte *) subtree, 0);
            kvmsg_send     (kvmsg, poller-&gt;socket);
            kvmsg_destroy (&amp;kvmsg);
            free (subtree);
        }
        zframe_destroy(&amp;identity);
    }
    return 0;
}
</programlisting>

</example>
<para>We store each update with a new sequence number, and if necessary, a time-to-live. We publish updates immediately on our publisher socket: 
</para>

<example id="clonesrv5-c-3">
<title>Clone server, Model Five (clonesrv5.c) - collect updates</title>
<programlisting language="c">

static int
s_collector (zloop_t *loop, zmq_pollitem_t *poller, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;

    kvmsg_t *kvmsg = kvmsg_recv (poller-&gt;socket);
    if (kvmsg) {
        kvmsg_set_sequence (kvmsg, ++self-&gt;sequence);
        kvmsg_send (kvmsg, self-&gt;publisher);
        int ttl = atoi (kvmsg_get_prop (kvmsg, "ttl"));
        if (ttl)
            kvmsg_set_prop (kvmsg, "ttl",
                "%" PRId64, zclock_time () + ttl * 1000);
        kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
        zclock_log ("I: publishing update=%d", (int) self-&gt;sequence);
    }
    return 0;
}
</programlisting>

</example>
<para>At regular intervals we flush ephemeral values that have expired. This could be slow on very large data sets: 
</para>

<example id="clonesrv5-c-4">
<title>Clone server, Model Five (clonesrv5.c) - flush ephemeral values</title>
<programlisting language="c">

//  If key-value pair has expired, delete it and publish the
//  fact to listening clients.
static int
s_flush_single (const char *key, void *data, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;

    kvmsg_t *kvmsg = (kvmsg_t *) data;
    int64_t ttl;
    sscanf (kvmsg_get_prop (kvmsg, "ttl"), "%" PRId64, &amp;ttl);
    if (ttl &amp;&amp; zclock_time () &gt;= ttl) {
        kvmsg_set_sequence (kvmsg, ++self-&gt;sequence);
        kvmsg_set_body (kvmsg, (byte *) "", 0);
        kvmsg_send (kvmsg, self-&gt;publisher);
        kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
        zclock_log ("I: publishing delete=%d", (int) self-&gt;sequence);
    }
    return 0;
}

static int
s_flush_ttl (zloop_t *loop, zmq_pollitem_t *poller, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;
    if (self-&gt;kvmap)
        zhash_foreach (self-&gt;kvmap, s_flush_single, args);
    return 0;
}
</programlisting>

</example>
</sect2>
<sect2>
<title>Clone Server Reliability</title>
<para>Clone models one to five are relatively simple. We're now going to get into unpleasantly complex territory here that has me getting up for another espresso. You should appreciate that making "reliable" messaging is complex enough that you always need to ask, "do we actually need this?" before jumping into it. If you can get away with unreliable, or "good enough" reliability, you can make a huge win in terms of cost and complexity. Sure, you may lose some data now and then. It is often a good trade-off. Having said, that, and (sips) since the espresso is really good, let's jump in!</para>

<para>As you play with model three, you'll stop and restart the server. It might look like it recovers, but of course it's applying updates to an empty state, instead of the proper current state. Any new client joining the network will get just the latest updates, instead of all of them. So let's work out a design for making Clone work despite server failures.</para>

<para>Let's list the failures we want to be able to handle:</para>

<itemizedlist>
  <listitem><para>Clone server process crashes and is automatically or manually restarted. The process loses its state and has to get it back from somewhere.</para></listitem>
  <listitem><para>Clone server machine dies and is off-line for a significant time. Clients have to switch to an alternate server somewhere.</para></listitem>
  <listitem><para>Clone server process or machine gets disconnected from the network, e.g. a switch dies. It may come back at some point, but in the meantime clients need an alternate server.</para></listitem>
</itemizedlist>
<para>Our first step is to add a second server. We can use the Binary Star pattern from Reliable Request-Reply Patterns<xref linkend="reliable-request-reply"/> to organize these into primary and backup. Binary Star is a reactor, so it's useful that we already refactored the last server model into a reactor style.</para>

<para>We need to ensure that updates are not lost if the primary server crashes. The simplest technique is to send them to both servers.</para>

<para>The backup server can then act as a client, and keep its state synchronized by receiving updates as all clients do. It'll also get new updates from clients. It can't yet store these in its hash table, but it can hold onto them for a while.</para>

<para>So, Model Six introduces these changes over Model Five:</para>

<itemizedlist>
  <listitem><para>We use a pub-sub flow instead of a push-pull flow for client updates (to the servers). The reasons: push sockets will block if there is no recipient, and they round-robin, so we'd need to open two of them. We'll bind the servers' SUB sockets and connect the clients' PUB sockets to them. This takes care of fanning out from one client to two servers.</para></listitem>
  <listitem><para>We add heartbeats to server updates (to clients), so that a client can detect when the primary server has died. It can then switch over to the backup server.</para></listitem>
  <listitem><para>We connect the two servers using the Binary Star <literal>bstar</literal> reactor class. Binary Star relies on the clients to 'vote' by making an explicit request to the server they consider "master". We'll use snapshot requests for this.</para></listitem>
  <listitem><para>We make all update messages uniquely identifiable by adding a UUID field. The client generates this, and the server propagates it back on re-published updates.</para></listitem>
  <listitem><para>The slave server keeps a "pending list" of updates that it has received from clients, but not yet from the master server. Or, updates it's received from the master, but not yet clients. The list is ordered from oldest to newest, so that it is easy to remove updates off the head.</para></listitem>
</itemizedlist>
<para>It's useful to design the client logic as a finite state machine. The client cycles through three states:</para>

<itemizedlist>
  <listitem><para>The client opens and connects its sockets, and then requests a snapshot from the first server. To avoid request storms, it will ask any given server only twice. One request might get lost, that'd be bad luck. Two getting lost would be carelessness.</para></listitem>
  <listitem><para>The client waits for a reply (snapshot data) from the current server, and if it gets it, it stores it. If there is no reply within some timeout, it fails over to the next server.</para></listitem>
  <listitem><para>When the client has gotten its snapshot, it waits for and processes updates. Again, if it doesn't hear anything from the server within some timeout, it fails over to the next server.</para></listitem>
</itemizedlist>
<para>The client loops forever. It's quite likely during startup or fail-over that some clients may be trying to talk to the primary server while others are trying to talk to the backup server. The Binary Star state machine handles this(<xref linkend="figure-67"/>), hopefully accurately. (One of the joys of making designs like this is we cannot prove they are right, we can only prove them wrong. So it's like a guy falling off a tall building. So far, so good... so far, so good...)</para>

<figure id="figure-67">
    <title>Clone Client Finite State Machine</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig67.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>Fail-over happens as follows:</para>

<itemizedlist>
  <listitem><para>The client detects that primary server is no longer sending heartbeats, so has died. The client connects to the backup server and requests a new state snapshot.</para></listitem>
  <listitem><para>The backup server starts to receive snapshot requests from clients, and detects that primary server has gone, so takes over as primary.</para></listitem>
  <listitem><para>The backup server applies its pending list to its own hash table, and then starts to process state snapshot requests.</para></listitem>
</itemizedlist>
<para>When the primary server comes back on-line, it will:</para>

<itemizedlist>
  <listitem><para>Start up as slave server, and connect to the backup server as a Clone client.</para></listitem>
  <listitem><para>Start to receive updates from clients, via its SUB socket.</para></listitem>
</itemizedlist>
<para>We make some assumptions:</para>

<itemizedlist>
  <listitem><para>That at least one server will keep running. If both servers crash, we lose all server state and there's no way to recover it.</para></listitem>
  <listitem><para>That multiple clients do not update the same hash keys, at the same time. Client updates will arrive at the two servers in a different order. So, the backup server may apply updates from its pending list in a different order than the primary server would or did. Updates from one client will always arrive in the same order on both servers, so that is safe.</para></listitem>
</itemizedlist>
<para>So the architecture for our high-availability server pair using the Binary Star pattern has two servers and a set of clients that talk to both servers(<xref linkend="figure-68"/>).</para>

<figure id="figure-68">
    <title>High-availability Clone Server Pair</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig68.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>As a first step to building this, we're going to refactor the client as a reusable class. This is partly for fun (writing asynchronous classes with &Oslash;MQ is like an exercise in elegance), but mainly because we want Clone to be really easy to plug-in to random applications. Since resilience depends on clients behaving correctly, it's much easier to guarantee this when there's a reusable client API. When we start to handle fail-over in clients, it does get a little complex (imagine mixing a Freelance client with a Clone client). So, reusability ahoy!</para>

<para>My usual design approach is to first design an API that feels right, then to implement that. So, we start by taking the clone client, and rewriting it to sit on top of some presumed class API called <emphasis role="bold">clone</emphasis>. Turning random code into an API means defining a reasonably stable and abstract contract with applications. For example, in Model Five, the client opened three separate sockets to the server, using endpoints that were hard-coded in the source. We could make an API with three methods, like this:</para>

<programlisting language="c">
//  Specify endpoints for each socket we need
clone_subscribe (clone, "tcp://localhost:5556");
clone_snapshot  (clone, "tcp://localhost:5557");
clone_updates   (clone, "tcp://localhost:5558");

//  Times two, since we have two servers
clone_subscribe (clone, "tcp://localhost:5566");
clone_snapshot  (clone, "tcp://localhost:5567");
clone_updates   (clone, "tcp://localhost:5568");
</programlisting>

<para>But this is both verbose and fragile. It's not a good idea to expose the internals of a design to applications. Today, we use three sockets. Tomorrow, two, or four. Do we really want to go and change every application that uses the clone class? So to hide these sausage factory details, we make a small abstraction, like this:</para>

<programlisting language="c">
//  Specify primary and backup servers
clone_connect (clone, "tcp://localhost:5551");
clone_connect (clone, "tcp://localhost:5561");
</programlisting>

<para>Which has the advantage of simplicity (one server sits at one endpoint) but has an impact on our internal design. We now need to somehow turn that single endpoint into three endpoints. One way would be to bake the knowledge "client and server talk over three consecutive ports" into our client-server protocol. Another way would be to get the two missing endpoints from the server. We'll take the simplest way, which is:</para>

<itemizedlist>
  <listitem><para>The server state router (ROUTER) is at port P.</para></listitem>
  <listitem><para>The server updates publisher (PUB) is at port P + 1.</para></listitem>
  <listitem><para>The server updates subscriber (SUB) is at port P + 2.</para></listitem>
</itemizedlist>
<para>The clone class has the same structure as the flcliapi class from Reliable Request-Reply Patterns<xref linkend="reliable-request-reply"/>. It consists of two parts:</para>

<itemizedlist>
  <listitem><para>An asynchronous clone agent that runs in a background thread. The agent handles all network I/O, talking to servers in real-time, no matter what the application is doing.</para></listitem>
  <listitem><para>A synchronous 'clone' class which runs in the caller's thread. When you create a clone object, that automatically launches an agent thread, and when you destroy a clone object, it kills the agent thread.</para></listitem>
</itemizedlist>
<para>The frontend class talks to the agent class over an <literal>inproc</literal> 'pipe' socket. In C, the CZMQ thread layer creates this pipe automatically for us as it starts an "attached thread". This is a natural pattern for multithreading over &Oslash;MQ.</para>

<para>Without &Oslash;MQ, this kind of asynchronous class design would be weeks of really hard work. With &Oslash;MQ, it was a day or two of work. The results are kind of complex, given the simplicity of the Clone protocol it's actually running. There are some reasons for this. We could turn this into a reactor, but that'd make it harder to use in applications. So the API looks a bit like a key-value table that magically talks to some servers:</para>

<programlisting language="c">
clone_t *clone_new (void);
void clone_destroy (clone_t **self_p);
void clone_connect (clone_t *self, char *address, char *service);
void clone_set (clone_t *self, char *key, char *value);
char *clone_get (clone_t *self, char *key);
</programlisting>

<para>So here is Model Six of the clone client, which has now become just a thin shell using the clone class:</para>

<example id="clonecli6-c">
<title>Clone client, Model Six (clonecli6.c)</title>
<programlisting language="c">
//
//  Clone client Model Six
//

//  Lets us build this source without creating a library
#include "clone.c"

#define SUBTREE "/client/"

int main (void)
{
    //  Create distributed hash instance
    clone_t *clone = clone_new ();

    //  Specify configuration
    clone_subtree (clone, SUBTREE);
    clone_connect (clone, "tcp://localhost", "5556");
    clone_connect (clone, "tcp://localhost", "5566");

    //  Set random tuples into the distributed hash
    while (!zctx_interrupted) {
        //  Set random value, check it was stored
        char key [255];
        char value [10];
        sprintf (key, "%s%d", SUBTREE, randof (10000));
        sprintf (value, "%d", randof (1000000));
        clone_set (clone, key, value, randof (30));
        sleep (1);
    }
    clone_destroy (&amp;clone);
    return 0;
</programlisting>

</example>
<para>And here is the actual clone class implementation:</para>

<example id="clone-c">
<title>Clone class (clone.c)</title>
<programlisting language="c">
/*  =====================================================================
 *  clone - client-side Clone Pattern class
 *  ===================================================================== */

#include "clone.h"

//  If no server replies within this time, abandon request
#define GLOBAL_TIMEOUT  4000    //  msecs


//  =====================================================================
//  Synchronous part, works in our application thread

//  ---------------------------------------------------------------------
//  Structure of our class

struct _clone_t {
    zctx_t *ctx;                //  Our context wrapper
    void *pipe;                 //  Pipe through to clone agent
};

//  This is the thread that handles our real clone class
static void clone_agent (void *args, zctx_t *ctx, void *pipe);
</programlisting>

</example>
<para>Constructor and destructor for the clone class: 
</para>

<example id="clone-c-1">
<title>Clone class (clone.c) - constructor and destructor</title>
<programlisting language="c">

clone_t *
clone_new (void)
{
    clone_t
        *self;

    self = (clone_t *) zmalloc (sizeof (clone_t));
    self-&gt;ctx = zctx_new ();
    self-&gt;pipe = zthread_fork (self-&gt;ctx, clone_agent, NULL);
    return self;
}

void
clone_destroy (clone_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        clone_t *self = *self_p;
        zctx_destroy (&amp;self-&gt;ctx);
        free (self);
        *self_p = NULL;
    }
}
</programlisting>

</example>
<para>Specify subtree for snapshot and updates, do before connect. Sends [SUBTREE][subtree] to the agent: 
</para>

<example id="clone-c-2">
<title>Clone class (clone.c) - subtree method</title>
<programlisting language="c">

void clone_subtree (clone_t *self, char *subtree)
{
    assert (self);
    zmsg_t *msg = zmsg_new ();
    zmsg_addstr (msg, "SUBTREE");
    zmsg_addstr (msg, subtree);
    zmsg_send (&amp;msg, self-&gt;pipe);
}
</programlisting>

</example>
<para>Connect to new server endpoint. Sends [CONNECT][endpoint][service] to the agent: 
</para>

<example id="clone-c-3">
<title>Clone class (clone.c) - connect method</title>
<programlisting language="c">

void
clone_connect (clone_t *self, char *address, char *service)
{
    assert (self);
    zmsg_t *msg = zmsg_new ();
    zmsg_addstr (msg, "CONNECT");
    zmsg_addstr (msg, address);
    zmsg_addstr (msg, service);
    zmsg_send (&amp;msg, self-&gt;pipe);
}
</programlisting>

</example>
<para>Set new value in distributed hash table. Sends [SET][key][value][ttl] to the agent: 
</para>

<example id="clone-c-4">
<title>Clone class (clone.c) - set method</title>
<programlisting language="c">

void
clone_set (clone_t *self, char *key, char *value, int ttl)
{
    char ttlstr [10];
    sprintf (ttlstr, "%d", ttl);

    assert (self);
    zmsg_t *msg = zmsg_new ();
    zmsg_addstr (msg, "SET");
    zmsg_addstr (msg, key);
    zmsg_addstr (msg, value);
    zmsg_addstr (msg, ttlstr);
    zmsg_send (&amp;msg, self-&gt;pipe);
}
</programlisting>

</example>
<para>Lookup value in distributed hash table. Sends [GET][key] to the agent and waits for a value response. If there is no clone available, will eventually return NULL: 
</para>

<example id="clone-c-5">
<title>Clone class (clone.c) - get method</title>
<programlisting language="c">

char *
clone_get (clone_t *self, char *key)
{
    assert (self);
    assert (key);
    zmsg_t *msg = zmsg_new ();
    zmsg_addstr (msg, "GET");
    zmsg_addstr (msg, key);
    zmsg_send (&amp;msg, self-&gt;pipe);

    zmsg_t *reply = zmsg_recv (self-&gt;pipe);
    if (reply) {
        char *value = zmsg_popstr (reply);
        zmsg_destroy (&amp;reply);
        return value;
    }
    return NULL;
}
</programlisting>

</example>
<para>The back-end agent manages a set of servers, which we implement using our simple class model: 
</para>

<example id="clone-c-6">
<title>Clone class (clone.c) - working with servers</title>
<programlisting language="c">


typedef struct {
    char *address;              //  Server address
    int port;                   //  Server port
    void *snapshot;             //  Snapshot socket
    void *subscriber;           //  Incoming updates
    uint64_t expiry;            //  When server expires
    uint requests;              //  How many snapshot requests made?
} server_t;

static server_t *
server_new (zctx_t *ctx, char *address, int port, char *subtree)
{
    server_t *self = (server_t *) zmalloc (sizeof (server_t));

    zclock_log ("I: adding server %s:%d...", address, port);
    self-&gt;address = strdup (address);
    self-&gt;port = port;

    self-&gt;snapshot = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_connect (self-&gt;snapshot, "%s:%d", address, port);
    self-&gt;subscriber = zsocket_new (ctx, ZMQ_SUB);
    zsocket_connect (self-&gt;subscriber, "%s:%d", address, port + 1);
    zsockopt_set_subscribe (self-&gt;subscriber, subtree);
    return self;
}

static void
server_destroy (server_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        server_t *self = *self_p;
        free (self-&gt;address);
        free (self);
        *self_p = NULL;
    }
}
</programlisting>

</example>
<para>Here is the implementation of the back-end agent itself: 
</para>

<example id="clone-c-7">
<title>Clone class (clone.c) - back-end agent class</title>
<programlisting language="c">

//  Number of servers we will talk to
#define SERVER_MAX      2

//  Server considered dead if silent for this long
#define SERVER_TTL      5000    //  msecs

//  States we can be in
#define STATE_INITIAL       0   //  Before asking server for state
#define STATE_SYNCING       1   //  Getting state from server
#define STATE_ACTIVE        2   //  Getting new updates from server

typedef struct {
    zctx_t *ctx;                //  Context wrapper
    void *pipe;                 //  Pipe back to application
    zhash_t *kvmap;             //  Actual key/value table
    char *subtree;              //  Subtree specification, if any
    server_t *server [SERVER_MAX];
    uint nbr_servers;           //  0 to SERVER_MAX
    uint state;                 //  Current state
    uint cur_server;            //  If active, server 0 or 1
    int64_t sequence;           //  Last kvmsg processed
    void *publisher;            //  Outgoing updates
} agent_t;

static agent_t *
agent_new (zctx_t *ctx, void *pipe)
{
    agent_t *self = (agent_t *) zmalloc (sizeof (agent_t));
    self-&gt;ctx = ctx;
    self-&gt;pipe = pipe;
    self-&gt;kvmap = zhash_new ();
    self-&gt;subtree = strdup ("");
    self-&gt;state = STATE_INITIAL;
    self-&gt;publisher = zsocket_new (self-&gt;ctx, ZMQ_PUB);
    return self;
}

static void
agent_destroy (agent_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        agent_t *self = *self_p;
        int server_nbr;
        for (server_nbr = 0; server_nbr &lt; self-&gt;nbr_servers; server_nbr++)
            server_destroy (&amp;self-&gt;server [server_nbr]);
        zhash_destroy (&amp;self-&gt;kvmap);
        free (self-&gt;subtree);
        free (self);
        *self_p = NULL;
    }
}
</programlisting>

</example>
<para>Here we handle the different control messages from the front-end; SUBTREE, CONNECT, SET, and GET: 
</para>

<example id="clone-c-8">
<title>Clone class (clone.c) - handling a control message</title>
<programlisting language="c">

static int
agent_control_message (agent_t *self)
{
    zmsg_t *msg = zmsg_recv (self-&gt;pipe);
    char *command = zmsg_popstr (msg);
    if (command == NULL)
        return -1;      //  Interrupted

    if (streq (command, "SUBTREE")) {
        free (self-&gt;subtree);
        self-&gt;subtree = zmsg_popstr (msg);
    }
    else
    if (streq (command, "CONNECT")) {
        char *address = zmsg_popstr (msg);
        char *service = zmsg_popstr (msg);
        if (self-&gt;nbr_servers &lt; SERVER_MAX) {
            self-&gt;server [self-&gt;nbr_servers++] = server_new (
                self-&gt;ctx, address, atoi (service), self-&gt;subtree);
            //  We broadcast updates to all known servers
            zsocket_connect (self-&gt;publisher, "%s:%d",
                address, atoi (service) + 2);
        }
        else
            zclock_log ("E: too many servers (max. %d)", SERVER_MAX);
        free (address);
        free (service);
    }
    else
</programlisting>

</example>
<para>When we set a property, we push the new key-value pair onto all our connected servers: 
</para>

<example id="clone-c-9">
<title>Clone class (clone.c) - set and get commands</title>
<programlisting language="c">
        char *key = zmsg_popstr (msg);
        char *value = zmsg_popstr (msg);
        char *ttl = zmsg_popstr (msg);
        zhash_update (self-&gt;kvmap, key, (byte *) value);
        zhash_freefn (self-&gt;kvmap, key, free);

        //  Send key-value pair on to server
        kvmsg_t *kvmsg = kvmsg_new (0);
        kvmsg_set_key  (kvmsg, key);
        kvmsg_set_uuid (kvmsg);
        kvmsg_fmt_body (kvmsg, "%s", value);
        kvmsg_set_prop (kvmsg, "ttl", ttl);
        kvmsg_send     (kvmsg, self-&gt;publisher);
        kvmsg_destroy (&amp;kvmsg);
        free (ttl);
        free (key);             //  Value is owned by hash table
    }
    else
    if (streq (command, "GET")) {
        char *key = zmsg_popstr (msg);
        char *value = zhash_lookup (self-&gt;kvmap, key);
        if (value)
            zstr_send (self-&gt;pipe, value);
        else
            zstr_send (self-&gt;pipe, "");
        free (key);
        free (value);
    }
    free (command);
    zmsg_destroy (&amp;msg);
    return 0;
}
</programlisting>

</example>
<para>The asynchronous agent manages a server pool and handles the request/reply dialog when the application asks for it: 
</para>

<example id="clone-c-10">
<title>Clone class (clone.c) - back-end agent</title>
<programlisting language="c">

static void
clone_agent (void *args, zctx_t *ctx, void *pipe)
{
    agent_t *self = agent_new (ctx, pipe);

    while (true) {
        zmq_pollitem_t poll_set [] = {
            { pipe, 0, ZMQ_POLLIN, 0 },
            { 0,    0, ZMQ_POLLIN, 0 }
        };
        int poll_timer = -1;
        int poll_size = 2;
        server_t *server = self-&gt;server [self-&gt;cur_server];
        switch (self-&gt;state) {
            case STATE_INITIAL:
                //  In this state we ask the server for a snapshot,
                //  if we have a server to talk to...
                if (self-&gt;nbr_servers &gt; 0) {
                    zclock_log ("I: waiting for server at %s:%d...",
                        server-&gt;address, server-&gt;port);
                    if (server-&gt;requests &lt; 2) {
                        zstr_sendm (server-&gt;snapshot, "ICANHAZ?");
                        zstr_send  (server-&gt;snapshot, self-&gt;subtree);
                        server-&gt;requests++;
                    }
                    server-&gt;expiry = zclock_time () + SERVER_TTL;
                    self-&gt;state = STATE_SYNCING;
                    poll_set [1].socket = server-&gt;snapshot;
                }
                else
                    poll_size = 1;
                break;
                
            case STATE_SYNCING:
                //  In this state we read from snapshot and we expect
                //  the server to respond, else we fail over.
                poll_set [1].socket = server-&gt;snapshot;
                break;
                
            case STATE_ACTIVE:
                //  In this state we read from subscriber and we expect
                //  the server to give hugz, else we fail over.
                poll_set [1].socket = server-&gt;subscriber;
                break;
        }
        if (server) {
            poll_timer = (server-&gt;expiry - zclock_time ())
                       * ZMQ_POLL_MSEC;
            if (poll_timer &lt; 0)
                poll_timer = 0;
        }
</programlisting>

</example>
<para>We're ready to process incoming messages; if nothing at all comes from our server within the timeout, that means the server is dead: 
</para>

<example id="clone-c-11">
<title>Clone class (clone.c) - client poll loop</title>
<programlisting language="c">
        int rc = zmq_poll (poll_set, poll_size, poll_timer);
        if (rc == -1)
            break;              //  Context has been shut down

        if (poll_set [0].revents &amp; ZMQ_POLLIN) {
            if (agent_control_message (self))
                break;          //  Interrupted
        }
        else
        if (poll_set [1].revents &amp; ZMQ_POLLIN) {
            kvmsg_t *kvmsg = kvmsg_recv (poll_set [1].socket);
            if (!kvmsg)
                break;          //  Interrupted

            //  Anything from server resets its expiry time
            server-&gt;expiry = zclock_time () + SERVER_TTL;
            if (self-&gt;state == STATE_SYNCING) {
                //  Store in snapshot until we're finished
                server-&gt;requests = 0;
                if (streq (kvmsg_key (kvmsg), "KTHXBAI")) {
                    self-&gt;sequence = kvmsg_sequence (kvmsg);
                    self-&gt;state = STATE_ACTIVE;
                    zclock_log ("I: received from %s:%d snapshot=%d",
                        server-&gt;address, server-&gt;port,
                        (int) self-&gt;sequence);
                    kvmsg_destroy (&amp;kvmsg);
                }
                else
                    kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
            }
            else
            if (self-&gt;state == STATE_ACTIVE) {
                //  Discard out-of-sequence updates, incl. hugz
                if (kvmsg_sequence (kvmsg) &gt; self-&gt;sequence) {
                    self-&gt;sequence = kvmsg_sequence (kvmsg);
                    kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
                    zclock_log ("I: received from %s:%d update=%d",
                        server-&gt;address, server-&gt;port,
                        (int) self-&gt;sequence);
                }
                else
                    kvmsg_destroy (&amp;kvmsg);
            }
        }
        else {
            //  Server has died, failover to next
            zclock_log ("I: server at %s:%d didn't give hugz",
                    server-&gt;address, server-&gt;port);
            self-&gt;cur_server = (self-&gt;cur_server + 1) % self-&gt;nbr_servers;
            self-&gt;state = STATE_INITIAL;
        }
    }
    agent_destroy (&amp;self);
}
</programlisting>

</example>
<para>Finally, here is the sixth and last model of the clone server:</para>

<example id="clonesrv6-c">
<title>Clone server, Model Six (clonesrv6.c)</title>
<programlisting language="c">
//
//  Clone server Model Six
//

//  Lets us build this source without creating a library
#include "bstar.c"
#include "kvmsg.c"
</programlisting>

</example>
<para>We define a set of reactor handlers and our server object structure: 
</para>

<example id="clonesrv6-c-1">
<title>Clone server, Model Six (clonesrv6.c) - definitions</title>
<programlisting language="c">

//  Bstar reactor handlers
static int s_snapshots  (zloop_t *loop, zmq_pollitem_t *poller, void *args);
static int s_collector  (zloop_t *loop, zmq_pollitem_t *poller, void *args);
static int s_flush_ttl  (zloop_t *loop, zmq_pollitem_t *poller, void *args);
static int s_send_hugz  (zloop_t *loop, zmq_pollitem_t *poller, void *args);
static int s_new_master (zloop_t *loop, zmq_pollitem_t *poller, void *args);
static int s_new_slave  (zloop_t *loop, zmq_pollitem_t *poller, void *args);
static int s_subscriber (zloop_t *loop, zmq_pollitem_t *poller, void *args);

//  Our server is defined by these properties
typedef struct {
    zctx_t *ctx;                //  Context wrapper
    zhash_t *kvmap;             //  Key-value store
    bstar_t *bstar;             //  Bstar reactor core
    int64_t sequence;           //  How many updates we're at
    int port;                   //  Main port we're working on
    int peer;                   //  Main port of our peer
    void *publisher;            //  Publish updates and hugz
    void *collector;            //  Collect updates from clients
    void *subscriber;           //  Get updates from peer
    zlist_t *pending;           //  Pending updates from clients
    Bool primary;               //  TRUE if we're primary
    Bool master;                //  TRUE if we're master
    Bool slave;                 //  TRUE if we're slave
} clonesrv_t;
</programlisting>

</example>
<para>The main task parses the command line to decide whether to start as primary or backup server. We're using the Binary Star pattern for reliability. This interconnects the two servers so they can agree on which is primary, and which is backup. To allow the two servers to run on the same box, we use different ports for primary and backup. Ports 5003/5004 are used to interconnect the servers. Ports 5556/5566 are used to receive voting events (snapshot requests in the clone pattern). Ports 5557/5567 are used by the publisher, and ports 5558/5568 by the collector: 
</para>

<example id="clonesrv6-c-2">
<title>Clone server, Model Six (clonesrv6.c) - main task setup</title>
<programlisting language="c">

int main (int argc, char *argv [])
{
    clonesrv_t *self = (clonesrv_t *) zmalloc (sizeof (clonesrv_t));
    if (argc == 2 &amp;&amp; streq (argv [1], "-p")) {
        zclock_log ("I: primary master, waiting for backup (slave)");
        self-&gt;bstar = bstar_new (BSTAR_PRIMARY, "tcp://*:5003",
                                 "tcp://localhost:5004");
        bstar_voter (self-&gt;bstar, "tcp://*:5556", ZMQ_ROUTER, s_snapshots, self);
        self-&gt;port = 5556;
        self-&gt;peer = 5566;
        self-&gt;primary = TRUE;
    }
    else
    if (argc == 2 &amp;&amp; streq (argv [1], "-b")) {
        zclock_log ("I: backup slave, waiting for primary (master)");
        self-&gt;bstar = bstar_new (BSTAR_BACKUP, "tcp://*:5004",
                                 "tcp://localhost:5003");
        bstar_voter (self-&gt;bstar, "tcp://*:5566", ZMQ_ROUTER, s_snapshots, self);
        self-&gt;port = 5566;
        self-&gt;peer = 5556;
        self-&gt;primary = FALSE;
    }
    else {
        printf ("Usage: clonesrv4 { -p | -b }\n");
        free (self);
        exit (0);
    }
    //  Primary server will become first master
    if (self-&gt;primary)
        self-&gt;kvmap = zhash_new ();

    self-&gt;ctx = zctx_new ();
    self-&gt;pending = zlist_new ();
    bstar_set_verbose (self-&gt;bstar, TRUE);

    //  Set up our clone server sockets
    self-&gt;publisher = zsocket_new (self-&gt;ctx, ZMQ_PUB);
    self-&gt;collector = zsocket_new (self-&gt;ctx, ZMQ_SUB);
    zsockopt_set_subscribe (self-&gt;collector, "");
    zsocket_bind (self-&gt;publisher, "tcp://*:%d", self-&gt;port + 1);
    zsocket_bind (self-&gt;collector, "tcp://*:%d", self-&gt;port + 2);

    //  Set up our own clone client interface to peer
    self-&gt;subscriber = zsocket_new (self-&gt;ctx, ZMQ_SUB);
    zsockopt_set_subscribe (self-&gt;subscriber, "");
    zsocket_connect (self-&gt;subscriber, "tcp://localhost:%d", self-&gt;peer + 1);
</programlisting>

</example>
<para>After we've set-up our sockets we register our binary star event handlers, and then start the bstar reactor. This finishes when the user presses Ctrl-C, or the process receives a SIGINT interrupt: 
</para>

<example id="clonesrv6-c-3">
<title>Clone server, Model Six (clonesrv6.c) - main task body</title>
<programlisting language="c">

    //  Register state change handlers
    bstar_new_master (self-&gt;bstar, s_new_master, self);
    bstar_new_slave (self-&gt;bstar, s_new_slave, self);

    //  Register our other handlers with the bstar reactor
    zmq_pollitem_t poller = { self-&gt;collector, 0, ZMQ_POLLIN };
    zloop_poller (bstar_zloop (self-&gt;bstar), &amp;poller, s_collector, self);
    zloop_timer  (bstar_zloop (self-&gt;bstar), 1000, 0, s_flush_ttl, self);
    zloop_timer  (bstar_zloop (self-&gt;bstar), 1000, 0, s_send_hugz, self);

    //  Start the Bstar reactor
    bstar_start (self-&gt;bstar);

    //  Interrupted, so shut down
    while (zlist_size (self-&gt;pending)) {
        kvmsg_t *kvmsg = (kvmsg_t *) zlist_pop (self-&gt;pending);
        kvmsg_destroy (&amp;kvmsg);
    }
    zlist_destroy (&amp;self-&gt;pending);
    bstar_destroy (&amp;self-&gt;bstar);
    zhash_destroy (&amp;self-&gt;kvmap);
    zctx_destroy (&amp;self-&gt;ctx);
    free (self);

    return 0;
}

//  We handle ICANHAZ? requests exactly as in the clonesrv5 example.
...
</programlisting>

</example>
<para>The collector is more complex than in the clonesrv5 example since how process updates depends on whether we're master or slave. The master applies them immediately to its kvmap, whereas the slave queues them as pending: 
</para>

<example id="clonesrv6-c-4">
<title>Clone server, Model Six (clonesrv6.c) - collect updates</title>
<programlisting language="c">

//  If message was already on pending list, remove it and return TRUE,
//  else return FALSE.
static int
s_was_pending (clonesrv_t *self, kvmsg_t *kvmsg)
{
    kvmsg_t *held = (kvmsg_t *) zlist_first (self-&gt;pending);
    while (held) {
        if (memcmp (kvmsg_uuid (kvmsg),
                    kvmsg_uuid (held), sizeof (uuid_t)) == 0) {
            zlist_remove (self-&gt;pending, held);
            return TRUE;
        }
        held = (kvmsg_t *) zlist_next (self-&gt;pending);
    }
    return FALSE;
}

static int
s_collector (zloop_t *loop, zmq_pollitem_t *poller, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;

    kvmsg_t *kvmsg = kvmsg_recv (poller-&gt;socket);
    if (kvmsg) {
        if (self-&gt;master) {
            kvmsg_set_sequence (kvmsg, ++self-&gt;sequence);
            kvmsg_send (kvmsg, self-&gt;publisher);
            int ttl = atoi (kvmsg_get_prop (kvmsg, "ttl"));
            if (ttl)
                kvmsg_set_prop (kvmsg, "ttl",
                    "%" PRId64, zclock_time () + ttl * 1000);
            kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
            zclock_log ("I: publishing update=%d", (int) self-&gt;sequence);
        }
        else {
            //  If we already got message from master, drop it, else
            //  hold on pending list
            if (s_was_pending (self, kvmsg))
                kvmsg_destroy (&amp;kvmsg);
            else
                zlist_append (self-&gt;pending, kvmsg);
        }
    }
    return 0;
}

//  We purge ephemeral values using exactly the same code as in
//  the previous clonesrv5 example.
...
</programlisting>

</example>
<para>We send a HUGZ message once a second to all subscribers so that they can detect if our server dies. They'll then switch over to the backup server, which will become master: 
</para>

<example id="clonesrv6-c-5">
<title>Clone server, Model Six (clonesrv6.c) - heartbeating</title>
<programlisting language="c">

static int
s_send_hugz (zloop_t *loop, zmq_pollitem_t *poller, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;

    kvmsg_t *kvmsg = kvmsg_new (self-&gt;sequence);
    kvmsg_set_key  (kvmsg, "HUGZ");
    kvmsg_set_body (kvmsg, (byte *) "", 0);
    kvmsg_send     (kvmsg, self-&gt;publisher);
    kvmsg_destroy (&amp;kvmsg);

    return 0;
}
</programlisting>

</example>
<para>When we switch from slave to master, we apply our pending list so that our kvmap is up-to-date. When we switch to slave, we wipe our kvmap and grab a new snapshot from the master: 
</para>

<example id="clonesrv6-c-6">
<title>Clone server, Model Six (clonesrv6.c) - handling state changes</title>
<programlisting language="c">

static int
s_new_master (zloop_t *loop, zmq_pollitem_t *unused, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;

    self-&gt;master = TRUE;
    self-&gt;slave = FALSE;

    //  Stop subscribing to updates
    zmq_pollitem_t poller = { self-&gt;subscriber, 0, ZMQ_POLLIN };
    zloop_poller_end (bstar_zloop (self-&gt;bstar), &amp;poller);

    //  Apply pending list to own hash table
    while (zlist_size (self-&gt;pending)) {
        kvmsg_t *kvmsg = (kvmsg_t *) zlist_pop (self-&gt;pending);
        kvmsg_set_sequence (kvmsg, ++self-&gt;sequence);
        kvmsg_send (kvmsg, self-&gt;publisher);
        kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
        zclock_log ("I: publishing pending=%d", (int) self-&gt;sequence);
    }
    return 0;
}

static int
s_new_slave (zloop_t *loop, zmq_pollitem_t *unused, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;

    zhash_destroy (&amp;self-&gt;kvmap);
    self-&gt;master = FALSE;
    self-&gt;slave = TRUE;

    //  Start subscribing to updates
    zmq_pollitem_t poller = { self-&gt;subscriber, 0, ZMQ_POLLIN };
    zloop_poller (bstar_zloop (self-&gt;bstar), &amp;poller, s_subscriber, self);

    return 0;
}
</programlisting>

</example>
<para>When we get an update, we create a new kvmap if necessary, and then add our update to our kvmap. We're always slave in this case: 
</para>

<example id="clonesrv6-c-7">
<title>Clone server, Model Six (clonesrv6.c) - subscriber handler</title>
<programlisting language="c">

static int
s_subscriber (zloop_t *loop, zmq_pollitem_t *poller, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;
    //  Get state snapshot if necessary
    if (self-&gt;kvmap == NULL) {
        self-&gt;kvmap = zhash_new ();
        void *snapshot = zsocket_new (self-&gt;ctx, ZMQ_DEALER);
        zsocket_connect (snapshot, "tcp://localhost:%d", self-&gt;peer);
        zclock_log ("I: asking for snapshot from: tcp://localhost:%d",
                    self-&gt;peer);
        zstr_sendm (snapshot, "ICANHAZ?");
        zstr_send (snapshot, ""); // blank subtree to get all
        while (true) {
            kvmsg_t *kvmsg = kvmsg_recv (snapshot);
            if (!kvmsg)
                break;          //  Interrupted
            if (streq (kvmsg_key (kvmsg), "KTHXBAI")) {
                self-&gt;sequence = kvmsg_sequence (kvmsg);
                kvmsg_destroy (&amp;kvmsg);
                break;          //  Done
            }
            kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
        }
        zclock_log ("I: received snapshot=%d", (int) self-&gt;sequence);
        zsocket_destroy (self-&gt;ctx, snapshot);
    }
    //  Find and remove update off pending list
    kvmsg_t *kvmsg = kvmsg_recv (poller-&gt;socket);
    if (!kvmsg)
        return 0;

    if (strneq (kvmsg_key (kvmsg), "HUGZ")) {
        if (!s_was_pending (self, kvmsg)) {
            //  If master update came before client update, flip it
            //  around, store master update (with sequence) on pending
            //  list and use to clear client update when it comes later
            zlist_append (self-&gt;pending, kvmsg_dup (kvmsg));
        }
        //  If update is more recent than our kvmap, apply it
        if (kvmsg_sequence (kvmsg) &gt; self-&gt;sequence) {
            self-&gt;sequence = kvmsg_sequence (kvmsg);
            kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
            zclock_log ("I: received update=%d", (int) self-&gt;sequence);
        }
        else
            kvmsg_destroy (&amp;kvmsg);
    }
    else
        kvmsg_destroy (&amp;kvmsg);

    return 0;
}
</programlisting>

</example>
<para>This main program is only a few hundred lines of code, but it took some time to get working. To be accurate, building Model Six took about a full week of "sweet god, this is just too complex for the Guide" hacking. We've assembled pretty much everything and the kitchen sink into this small application. We have fail-over, ephemeral values, subtrees, and so on. What surprised me was that the upfront design was pretty accurate. But the details of writing and debugging so many socket flows is something special. Here's how I made this work:</para>

<itemizedlist>
  <listitem><para>By using reactors (bstar, on top of zloop), which remove a lot of grunt-work from the code, and leave what remains simpler and more obvious. The whole server runs as one thread, so there's no inter-thread weirdness going on. Just pass a structure pointer ('self') around to all handlers, which can do their thing happily. One nice side-effect of using reactors is that code, being less tightly integrated into a poll loop, is much easier to reuse. Large chunks of Model Six are taken from Model Five.</para></listitem>
  <listitem><para>By building it piece by piece, and getting each piece working <emphasis role="bold">properly</emphasis> before going onto the next one. Since there are four or five main socket flows, that meant quite a lot of debugging and testing. I debug just by printing stuff to the console (e.g. dumping messages). There's no sense in actually opening a debugger for this kind of work.</para></listitem>
  <listitem><para>By always testing under Valgrind, so that I'm sure there are no memory leaks. In C this is a major concern, you can't delegate to some garbage collector. Using proper and consistent abstractions like kvmsg and CZMQ helps enormously.</para></listitem>
</itemizedlist>
<para>I'm sure the code still has flaws which kind readers will spend weekends debugging and fixing for me. I'm happy enough with this model to use it as the basis for real applications.</para>

<para>To test the sixth model, start the primary server and backup server, and a set of clients, in any order. Then kill and restart one of the servers, randomly, and keep doing this. If the design and code is accurate, clients will continue to get the same stream of updates from whatever server is currently master.</para>

</sect2>
<sect2>
<title>Clone Protocol Specification</title>
<para>After this much work to build reliable pub-sub, we want some guarantee that we can safely build applications to exploit the work. A good start is to write-up the protocol. This lets us make implementations in other languages and lets us improve the design on paper, rather than hands-deep in code.</para>

<para>Here, then, is the Clustered Hashmap Protocol, which "defines a cluster-wide key-value hashmap, and mechanisms for sharing this across a set of clients. CHP allows clients to work with subtrees of the hashmap, to update values, and to define ephemeral values."</para>

<itemizedlist>
  <listitem><para>http://rfc.zeromq.org/spec:12</para></listitem>
</itemizedlist>
</sect2>
</sect1>
<sect1>
<title>The Espresso Pattern</title>
<para>here is a fun little machine that exploits the <literal>zmq_proxy()</literal> method to show you what's happening on a pub-sub network. It's deceptively simple:</para>

<example id="espresso-c">
<title>Espresso Machine (espresso.c)</title>
<programlisting language="c">
//
//  Espresso Pattern
//  This shows how to capture data using a pub-sub proxy
//
#include "czmq.h"

//  The subscriber thread requests messages starting with
//  A and B, then reads and counts incoming messages.

static void
subscriber_thread (void *args, zctx_t *ctx, void *pipe)
{
    //  Subscribe to "A" and "B"
    void *subscriber = zsocket_new (ctx, ZMQ_SUB);
    zsocket_connect (subscriber, "tcp://localhost:6001");
    zsockopt_set_subscribe (subscriber, "A");
    zsockopt_set_subscribe (subscriber, "B");

    int count = 0;
    while (true) {
        char *string = zstr_recv (subscriber);
        if (!string)
            break;              //  Interrupted
        free (string);
        count++;
    }
    printf ("Subscriber received %d messages\n", count);
}
</programlisting>

</example>
<para>The publisher sends random messages starting with A-J: 
</para>

<example id="espresso-c-1">
<title>Espresso Machine (espresso.c) - publisher thread</title>
<programlisting language="c">

static void
publisher_thread (void *args, zctx_t *ctx, void *pipe)
{
    void *publisher = zsocket_new (ctx, ZMQ_PUB);
    zsocket_bind (publisher, "tcp://*:6000");

    while (true) {
        char string [10];
        sprintf (string, "%c-%05d", randof (10) + 'A', randof (100000));
        if (zstr_send (publisher, string) == -1)
            break;              //  Interrupted
        zclock_sleep (100);     //  Wait for 1/10th second
    }
}
</programlisting>

</example>
<para>The listener receives all messages flowing through the proxy, on its pipe. In CZMQ, the pipe is a pair of ZMQ_PAIR sockets that connects attached child threads. In other languages your mileage may vary: 
</para>

<example id="espresso-c-2">
<title>Espresso Machine (espresso.c) - listener thread</title>
<programlisting language="c">

static void
listener_thread (void *args, zctx_t *ctx, void *pipe)
{
    //  Print everything that arrives on pipe
    while (true) {
        char *string = zstr_recv (pipe);
        if (!string)
            break;              //  Interrupted
        puts (string);
        free (string);
    }
}
</programlisting>

</example>
<para>The main task starts the subscriber and publisher, and then sets itself up as a listening proxy. The listener runs as a child thread: 
</para>

<example id="espresso-c-3">
<title>Espresso Machine (espresso.c) - main thread</title>
<programlisting language="c">

int main (void)
{
    //  Start child threads
    zctx_t *ctx = zctx_new ();
    zthread_fork (ctx, publisher_thread, NULL);
    zthread_fork (ctx, subscriber_thread, NULL);

    void *subscriber = zsocket_new (ctx, ZMQ_XSUB);
    zsocket_connect (subscriber, "tcp://localhost:6000");
    void *publisher = zsocket_new (ctx, ZMQ_XPUB);
    zsocket_bind (publisher, "tcp://*:6001");
    void *listener = zthread_fork (ctx, listener_thread, NULL);
    zmq_proxy (subscriber, publisher, listener);

    puts (" interrupted");
    
    //  Tell attached threads to exit
    zctx_destroy (&amp;ctx);
    return 0;
}
</programlisting>

</example>
</sect1>
<sect1>
<title>Last Value Caching</title>
<para>If you've used commercial publish-subscribe systems you may be used to some features that are missing in the fast and cheerful &Oslash;MQ pub-sub model. One of these is "last value caching". The problem this solves is how a new subscriber catches up when it joins the network. The theory is that publishers get notified when a new subscriber joins and subscribes to some specific topics. The publisher can then re-broadcast the last message for those topics.</para>

<para>First I'll explain why &Oslash;MQ does not do this, and then I'll show how to do it anyhow.</para>

<para>We don't do it because in large pub-sub systems the volumes of data make it pretty much impossible. To make really large-scale pub-sub networks you need a protocol like PGM that exploits an upscale Ethernet switch's ability to multicast data to thousands of subscribers. Trying to do a TCP unicast from the publisher to each of thousands of subscribers just doesn't scale. You get weird spikes, unfair distribution (some subscribers getting the message before others), network congestion, and general unhappiness.</para>

<para>PGM is a one-way protocol: the publisher sends a message to a multicast address at the switch, which then rebroadcasts that to all interested subscribers. The publisher never sees when subscribers join or leave: this all happens in the switch, which we don't really want to start reprogramming.</para>

<para>OK, but in a lower-volume network, with a few dozen subscribers, and a limited number of topics, how do we make a LVC using &Oslash;MQ? The answer is to create a proxy that sits between the publisher and subscribers; an analog for the switch, but one we can program ourselves.</para>

<para>I'll start by making a publisher and subscriber that highlight the worst case scenario. This publisher is pathological. It starts by immediately sending messages to each of a thousand topics, and then it sends one update a second to a random topic. A subscriber connects, and subscribes to a topic. Without LVC, a subscriber would have to wait an average of 500 seconds to get any data. To add some drama, let's pretend there's an escaped convict called Roth threatening to rip the head off Roger the toy bunny if we can't fix that 8.3 minutes' delay.</para>

<para>Here's the publisher code. Note that it has the command line option to connect to some address, but otherwise binds to an endpoint. We'll use this later to connect to our last value cache:</para>

<example id="pathopub-c">
<title>Pathologic Publisher (pathopub.c)</title>
<programlisting language="c">
//
//  Pathological publisher
//  Sends out 1,000 topics and then one random update per second
//
#include "czmq.h"

int main (int argc, char *argv [])
{
    zctx_t *context = zctx_new ();
    void *publisher = zsocket_new (context, ZMQ_PUB);
    if (argc == 2)
        zsocket_connect (publisher, argv [1]);
    else
        zsocket_bind (publisher, "tcp://*:5556");

    //  Ensure subscriber connection has time to complete
    sleep (1);

    //  Send out all 1,000 topic messages
    int topic_nbr;
    for (topic_nbr = 0; topic_nbr &lt; 1000; topic_nbr++) {
        zstr_sendfm (publisher, "%03d", topic_nbr, ZMQ_SNDMORE);
        zstr_send (publisher, "Save Roger");
    }
    //  Send one random update per second
    srandom ((unsigned) time (NULL));
    while (!zctx_interrupted) {
        sleep (1);
        zstr_sendfm (publisher, "%03d", randof (1000), ZMQ_SNDMORE);
        zstr_send (publisher, "Off with his head!");
    }
    zctx_destroy (&amp;context);
    return 0;
}
</programlisting>

</example>
<para>And here's the subscriber:</para>

<example id="pathosub-c">
<title>Pathologic Subscriber (pathosub.c)</title>
<programlisting language="c">
//
//  Pathological subscriber
//  Subscribes to one random topic and prints received messages
//
#include "czmq.h"

int main (int argc, char *argv [])
{
    zctx_t *context = zctx_new ();
    void *subscriber = zsocket_new (context, ZMQ_SUB);
    if (argc == 2)
        zsocket_connect (subscriber, argv [1]);
    else
        zsocket_connect (subscriber, "tcp://localhost:5556");

    srandom ((unsigned) time (NULL));
    char subscription [5];
    sprintf (subscription, "%03d", randof (1000));
    zsocket_set_subscribe (subscriber, subscription);
    
    while (true) {
        char *topic = zstr_recv (subscriber);
        if (!topic)
            break;
        char *data = zstr_recv (subscriber);
        assert (streq (topic, subscription));
        puts (data);
        free (topic);
        free (data);
    }
    zctx_destroy (&amp;context);
    return 0;
}
</programlisting>

</example>
<para>Try building and running these: first the subscriber, then the publisher. You'll see the subscriber reports getting "Save Roger" as you'd expect:</para>

<screen>./pathosub &amp;
./pathopub
</screen>

<para>It's when you run a second subscriber that you understand Roger's predicament. You have to leave it an awful long time before it reports getting any data. So, here's our last value cache. As I promised, it's a proxy that binds to two sockets and then handles messages on both them:</para>

<example id="lvcache-c">
<title>Last Value Caching Proxy (lvcache.c)</title>
<programlisting language="c">
//
//  Last value cache
//  Uses XPUB subscription messages to re-send data
//
#include "czmq.h"

int main (void)
{
    zctx_t *context = zctx_new ();
    void *frontend = zsocket_new (context, ZMQ_SUB);
    zsocket_bind (frontend, "tcp://*:5557");
    void *backend = zsocket_new (context, ZMQ_XPUB);
    zsocket_bind (backend, "tcp://*:5558");

    //  Subscribe to every single topic from publisher
    zsocket_set_subscribe (frontend, "");

    //  Store last instance of each topic in a cache
    zhash_t *cache = zhash_new ();
</programlisting>

</example>
<para>We route topic updates from frontend to backend, and we handle subscriptions by sending whatever we cached, if anything: 
</para>

<example id="lvcache-c-1">
<title>Last Value Caching Proxy (lvcache.c) - main poll loop</title>
<programlisting language="c">

        zmq_pollitem_t items [] = {
            { frontend, 0, ZMQ_POLLIN, 0 },
            { backend,  0, ZMQ_POLLIN, 0 }
        };
        if (zmq_poll (items, 2, 1000 * ZMQ_POLL_MSEC) == -1)
            break;              //  Interrupted

        //  Any new topic data we cache and then forward
        if (items [0].revents &amp; ZMQ_POLLIN) {
            char *topic = zstr_recv (frontend);
            char *current = zstr_recv (frontend);
            if (!topic)
                break;
            char *previous = zhash_lookup (cache, topic);
            if (previous) {
                zhash_delete (cache, topic);
                free (previous);
            }
            zhash_insert (cache, topic, current);
            zstr_sendm (backend, topic);
            zstr_send (backend, current);
            free (topic);
        }
</programlisting>

</example>
<para>When we get a new subscription we pull data from the cache: 
</para>

<example id="lvcache-c-2">
<title>Last Value Caching Proxy (lvcache.c) - handle subscriptions</title>
<programlisting language="c">
            zframe_t *frame = zframe_recv (backend);
            if (!frame)
                break;
            //  Event is one byte 0=unsub or 1=sub, followed by topic
            byte *event = zframe_data (frame);
            if (event [0] == 1) {
                char *topic = zmalloc (zframe_size (frame));
                memcpy (topic, event + 1, zframe_size (frame) - 1);
                printf ("Sending cached topic %s\n", topic);
                char *previous = zhash_lookup (cache, topic);
                if (previous) {
                    zstr_sendm (backend, topic);
                    zstr_send (backend, previous);
                }
                free (topic);
            }
            zframe_destroy (&amp;frame);
        }
    }
    zctx_destroy (&amp;context);
    zhash_destroy (&amp;cache);
    return 0;
}
</programlisting>

</example>
<para>Now, run the proxy, then the publisher:</para>

<screen>./lvcache &amp;
./pathopub tcp://localhost:5557
</screen>

<para>And now run as many instances of the subscriber as you want to try, each time connecting to the proxy on port 5558:</para>

<screen>./pathosub tcp://localhost:5558
</screen>

<para>Each subscriber happily reports "Save Roger", and Roth the Escaped Convict slinks back to his cell for dinner and a nice cup of hot milk, which is all he really wanted anyhow and could someone call his mum and tell her his clean socks are almost all up.</para>

<para>One note: the XPUB socket by default does not report duplicate subscriptions, which is what you want when you're naively connecting an XPUB to an XSUB. Our example sneakily gets around this by using random topics so the chance of it not working is one in a million. In a real LVC proxy you'll want to use the <literal>ZMQ_XPUB_VERBOSE</literal> option that we implement later in The &Oslash;MQ Community<xref linkend="the-community"/> as an exercise.</para>

</sect1>
</chapter>
<chapter id="the-human-scale">
<title>The Human Scale</title>
<para>If you've survived the first five chapters, congratulations. It was hard for for me too. Happily the jokes and the code mostly write themselves, so we'll continue with our journey of exploring &Oslash;MQ. In this chapter I'm going to step back from the nuts and bolts of &Oslash;MQ's technical machinery, and look more at how to use &Oslash;MQ successfully in larger projects.</para>

<para>We'll cover:</para>

<itemizedlist>
  <listitem><para>What "software architecture" is really about.</para></listitem>
  <listitem><para>The Simplicity-Oriented Design process and its ugly cousins Cod and Tod.</para></listitem>
  <listitem><para>How to use &Oslash;MQ to go from idea to working prototype safely.</para></listitem>
  <listitem><para>Different ways to serialize your data as &Oslash;MQ messages.</para></listitem>
  <listitem><para>How to code-generate binary serialization codecs.</para></listitem>
  <listitem><para>How to build custom code generators.</para></listitem>
  <listitem><para>How to write and license an protocol specification.</para></listitem>
  <listitem><para>How to do fast restartable file transfer over &Oslash;MQ.</para></listitem>
  <listitem><para>How to do credit-based flow control.</para></listitem>
  <listitem><para>How to do heartbeating for different &Oslash;MQ patterns.</para></listitem>
  <listitem><para>How to build protocol servers and clients as state machines.</para></listitem>
  <listitem><para>How to make a secure protocol over &Oslash;MQ (yay!).</para></listitem>
  <listitem><para>A large-scale file publishing system (FileMQ).</para></listitem>
</itemizedlist>
<sect1>
<title>The Tale of Two Bridges</title>
<para>Two old engineers were talking of their lives and boasting of their greatest projects. One of the engineers explained how he had designed one of the greatest bridges ever made.</para>

<para>"We built it across a river gorge," he told his friend. "It was wide and deep. We spent two years studying the land, and choosing designs and materials. We hired the best engineers and designed the bridge, which took another five years. We contracted the largest engineering firms to build the structures, the towers, the tollbooths, and the roads that would connect the bridge to the main highways. Dozens died during the construction. Under the road level we had trains, and a special path for cyclists. That bridge represented years of my life."</para>

<para>The second man reflected for a while, then spoke. "One evening me and a friend got drunk on vodka, and we threw a rope across a gorge," he said. "Just a rope, tied to two trees. There were two villages, one at each side. At first, people pulled packages across that rope with a pulley and string. Then someone threw a second rope, and built a foot walk. It was dangerous, but the kids loved it. A group of men then rebuilt that, made it solid, and women started to cross, everyday, with their produce. A market grew up on one side of the bridge, and slowly that became a large town, since there was a lot of space for houses. The rope bridge got replaced with a wooden bridge, to allow horses and carts to cross. Then the town built a real stone bridge, with metal beams. Later, they replaced the stone part with steel, and today there's a suspension bridge standing in that same spot."</para>

<para>The first engineer was silent. "Funny thing," he said, "my bridge was demolished about ten years after we built it. Turns out it was built in the wrong place and no-one wanted to use it. Some guys had thrown a rope across the gorge, a few miles further downstream, and that's where everyone went."</para>

</sect1>
<sect1>
<title>Code on the Human Scale</title>
<para>To write a poem that captures the heart, first learn the language. To use &Oslash;MQ successfully at scale you have to learn two languages. The first is &Oslash;MQ itself. This takes even the best of us time. It's a truism that if you try to port an old architecture onto &Oslash;MQ, the results are going to be weird. &Oslash;MQ's language is subtle and profound and when you master it you will find yourself removing old complexity, not converting it.</para>

<para>However the real challenge of using &Oslash;MQ is that old barriers fall away, and the size of the projects you can do increases hugely. Non-distributed code is often a single-person project. You can work in your corner, perhaps for years, like an author on a book. It's all about concentration. But distributed code is different. To quote my favorite author, it "has to talk to code, has to be chatty, sociable, well-connected".</para>

<para>Writing distributed code is like playing live music: it's all about other people. Concentration is worthless if you can't listen. No-one enjoys listening to an amazingly proficient musician who's out of time with the rest of the group and can't read the mood of the audience. A live jam is entrancing not because of the technical quality but because of the real-time creative energy.</para>

<para>And so it goes with distributed code. Real-time creative energy is what wins, not pure technical quality, and certainly not technical quality combined with inability to work with others.</para>

<para>All this is fine in theory. Here comes the catch: working with other people is <emphasis>plain hard</emphasis>. We can expect a musician to be naturally social. But software developers? We're the very caricature of anti-social tunnel-visioned hermits. Other people are hard work. They're slow, they make mistakes, they ask too many questions, they don't respect our code, they make wrong assumptions, they argue.</para>

<para>My response isn't very sympathetic. To succeed in the software industry as it turns into something more like a never-ending live jam, we have to learn to put away our egos, work successfully with others, worry less about our own skills and look more at others, put away our natural insolence and attitude, and to learn to like and trust other people.</para>

<para>So this is what this chapter is really about: writing code at scale by understanding ourselves much better. Of course these lessons apply to all large-scale applications. Using &Oslash;MQ we just hit the problem sooner than we'd expect.</para>

</sect1>
<sect1>
<title>Psychology of Software Development</title>
<para>Dirkjan Ochtman pointed me to <ulink url="http://en.wikipedia.org/wiki/Software_architecture">Wikipedia's definition of Software Architecture</ulink> as "the set of structures needed to reason about the system, which comprise software elements, relations among them, and properties of both". For me this vapid and circular jargon is a good example of how miserably little we understand about what actually makes a successful large scale software architecture.</para>

<para>Architecture is the art and science of making large artificial structures for human use. If there is one thing I've learned and applied successfully in 30 years of making larger and larger software systems it is this: software is about people. Large structures in themselves are meaningless. It's how they function for <emphasis>human use</emphasis> that matters. And in software, human use starts with the programmers who make the software itself.</para>

<para>The core problems in software architecture are driven by human psychology, not technology. There are many ways our psychology affects our work. I could point to the way teams seem to get stupider as they get larger, or have to work across larger distances. Does that mean the smaller the team, the more effective? How then does a large global community like &Oslash;MQ manage to work successfully?</para>

<para>The &Oslash;MQ community wasn't accidental, it was a deliberate design, my contribution to the early days when the code came out of a cellar in Bratislava. The design was based on my pet science of "Social Architecture", which <ulink url="http://en.wikipedia.org/wiki/Social_architecture">Wikipedia defines</ulink> (what a coincidence!) as "the process, and the product, of planning, designing, and growing an on-line community."</para>

<para>One of the tenets of Social Architecture is that <emphasis>how we organize</emphasis> is more significant than <emphasis>who we are</emphasis>. The same group, organized differently, can produce entirely opposite results. We are like peers in a &Oslash;MQ network, and our communication patterns have dramatic impact on our performance. Ordinary people, well connected, can far outperform a team of experts working in the wrong patterns. If you're the architect of a larger &Oslash;MQ application, you're going to have to help others find the right patterns for working together. Do this right, and your project can succeed. Do it wrong, and your project will fail.</para>

<para>The two most important psychological elements are IMO that we're really bad at understanding complexity, and that we are so good at working together to divide and conquer large problems. We're highly social apes, and kind of smart, but only in the right kind of crowd.</para>

<para>So here is my short list of the Psychological Elements of Software Architecture:</para>

<itemizedlist>
  <listitem><para><emphasis role="bold">Stupidity</emphasis>: our mental bandwidth is limited, so we're all stupid at some point. The architecture has to be simple to understand. This is the number one rule: simplicity beats functionality, every single time. If you can't understand an architecture on a cold gray Monday morning before coffee, it is too complex.</para></listitem>
  <listitem><para><emphasis role="bold">Selfishness</emphasis>: we act only out of self-interest, so the architecture must create space and opportunity for selfish acts that benefit the whole. Selfishness is often indirect and subtle. For example I'll spend hours helping someone else understand something because that could be worth days to me later.</para></listitem>
  <listitem><para><emphasis role="bold">Laziness</emphasis>: we make lots of assumptions, many of which are wrong. We are happiest when we can spend the least effort to get a result, to test an assumption quickly, so the architecture has to make this possible. Specifically, that means it must be simple.</para></listitem>
  <listitem><para><emphasis role="bold">Jealousy</emphasis>: we're jealous of others, which means we'll overcome our stupidity and laziness to prove others wrong, and beat them in competition. The architecture thus has to create space for public competition based on fair rules that anyone can understand.</para></listitem>
  <listitem><para><emphasis role="bold">Reciprocity</emphasis>: we'll pay extra in terms of hard work, even money, to punish cheats and enforce fair rules. The architecture should be heavily rule-based, telling people how to work together, but not what to work on.</para></listitem>
  <listitem><para><emphasis role="bold">Pride</emphasis>: we're intensely aware of our social status, and we'll work hard to avoid looking stupid or incompetent in public. The architecture has to make sure every piece we make has our name on it, so we'll have sleepless nights stressing about what others will say about our work.</para></listitem>
  <listitem><para><emphasis role="bold">Greed</emphasis>: we're ultimately economic animals (see selfishness), so the architecture has to give us economic incentive to invest in making it happen. Maybe it's polishing our reputation as experts, maybe it's literally making money from some skill or component. It doesn't matter what it is, but there must be economic incentive. Think of architecture as a market place, not an engineering design.</para></listitem>
  <listitem><para><emphasis role="bold">Conformity</emphasis>: we're happiest to conform, out of fear and laziness, so the architecture should be strongly rule-based, and rules should be clear, accurate, well-documented, and enforced.</para></listitem>
  <listitem><para><emphasis role="bold">Fear</emphasis>: we're unwilling to take risks, especially if it makes us look stupid. Fear of failure is a major reason people conform and follow the group in mass stupidity. The architecture should make silent experimentation easy and cheap, giving people opportunity for success without punishing failure.</para></listitem>
</itemizedlist>
<para>These strategies work on large scale but also on small scale, within an organization or team.</para>

</sect1>
<sect1>
<title>The Bad, the Ugly, and the Delicious</title>
<para>Complexity is easy, it's simplicity that is hard. Whether our software is bad, ugly, or so delicious that it feels wrong to consume alone, doesn't depend so much on our individual skills as how we work together. That is, our processes.</para>

<para>There are many aspects to getting product-building teams and organizations to think wisely. You need diversity, freedom, challenge, resources, and so on. I discuss these in detail in <ulink url="http://swsi.info">Software and Silicon</ulink>. However, even if you have all the right ingredients, the default processes that skilled engineers and designers develop will result in complex, hard-to-use products.</para>

<para>The classic errors are: to focus on ideas, not problems; to focus on the wrong problems; to misjudge the value of solving problems; to not use ones' own work; and in many other ways to misjudge the real market.</para>

<para>I'll propose a process called "Simplicity Oriented Design", or SOD, which is as far as I can tell a reliable, repeatable way of developing simple and elegant products. This process organizes people into flexible supply chains that are able to navigate a problem landscape rapidly and cheaply. They do this by building, testing, and keeping or discarding minimal plausible solutions, called "patches". Living products consist of long series of patches, applied one atop the other. Yes, you may recognize the process by which we develop &Oslash;MQ.</para>

<para>Let's first look at the more common and less joyful processes, TOD and COD.</para>

<sect2>
<title>Trash-Oriented Design</title>
<para>The most popular design process in large businesses seems to be "Trash Oriented Design", or TOD. TOD feeds off the belief that all we need to make money are great ideas. It's tenacious nonsense but a powerful crutch for people who lack imagination. The theory goes that ideas are rare, so the trick is to capture them. It's like non-musicians being awed by a guitar player, not realizing that great talent is so cheap it literally plays on the streets for coins.</para>

<para>The main output of TODs are expensive "ideations": concepts, design documents, and products that go straight into the trash can. It works as follows:</para>

<itemizedlist>
  <listitem><para>The Creative People come up with long lists of "we could do X and Y". I've seen endlessly detailed lists of everything amazing a product could do. Once the creative work of idea generation has happened, it's just a matter of execution, of course.</para></listitem>
  <listitem><para>So the managers and their consultants pass their brilliant, world-shattering ideas to designers who create acres of detailed, preciously refined design documents. The designers take the tens of ideas the managers came up with, and turn them into hundreds of amazing, world-changing designs.</para></listitem>
  <listitem><para>These designs get given to engineers who scratch their heads and wonder who the heck came up with such stupid nonsense. They start to argue back but the designs come from up high, and really, it's not up to engineers to argue with creative people and expensive consultants.</para></listitem>
  <listitem><para>So the engineers creep back to their cubicles, humiliated and threatened into building the gigantic but oh-so-elegant pile of junk. It is bone-breakingly hard work since the designs take no account of practical costs. Minor whims might take weeks of work to build. As the project gets delayed, the managers bully the engineers into giving up their evenings and weekends.</para></listitem>
  <listitem><para>Eventually, something resembling a working product makes it out of the door. It's creaky and fragile, complex and ugly. The designers curse the engineers for their incompetence and pay more consultants to put lipstick onto the pig, and slowly the product starts to look a little nicer.</para></listitem>
  <listitem><para>By this time, the managers have started to try to sell the product and they find, shockingly, that no-one wants it. Undaunted and courageously they build million-dollar web sites and ad campaigns to explain to the public why they absolutely need this product. They do deals with other businesses to force the product on the lazy, stupid and ungrateful market.</para></listitem>
  <listitem><para>After twelve months of intense marketing, the product still isn't making profits. Worse, it suffers dramatic failures and gets branded in the press as a disaster. The company quietly shelves it, fires the consultants, buys a competing product from a small start-up and re-brands that as its own Version 2. Hundreds of millions of dollars end-up in the trash.</para></listitem>
  <listitem><para>Meanwhile, another visionary manager, somewhere in the Organization, drinks a little too much tequila with some marketing people and has a Brilliant Idea.</para></listitem>
</itemizedlist>
<para>Trash-Oriented Design would be a caricature if it wasn't so common. Something like 19 out of 20 market-ready products built by large firms are failures (yes, 87% of statistics are made up on the spot). The remaining one in 20 probably only succeeds because the competitors are so bad and the marketing is so aggressive.</para>

<para>The main lessons of TOD are quite straight-forward but hard to swallow. They are:</para>

<itemizedlist>
  <listitem><para>Ideas are cheap. No exceptions. There are no brilliant ideas. Anyone who tries to start a discussion with "oooh, we can do this too!" should be beaten down with all the passion one reserves for traveling evangelists. It is like sitting in a cafe at the foot of a mountain, drinking a hot chocolate and telling others, "hey, I have a great idea, we can climb that mountain! And build a chalet on top! With two saunas! And a garden! Hey, and we can make it solar powered! Dude, that's awesome! What color should we paint it? Green! No, blue! OK, go and make it, I'll stay here and make spreadsheets and graphics!"</para></listitem>
  <listitem><para>The starting point for a good design process is to collect real problems that confront real people. The second step is to evaluate these problems with the basic question, "how much is it worth to solve this problem?" Having done that, we can collect that set of problems that are worth solving.</para></listitem>
  <listitem><para>Good solutions to real problems will succeed as products. Their success will depend on how good and cheap the solution is, and how important the problem is (and sadly, how big the marketing budgets are). But their success will also depend on how much they demand in effort to use, in other words how simple they are.</para></listitem>
</itemizedlist>
<para>Hence after slaying the dragon of utter irrelevance, we attack the demon of complexity.</para>

</sect2>
<sect2>
<title>Complexity-Oriented Design</title>
<para>Really good engineering teams and small firms can usually build decent products. But the vast majority of products still end up being too complex and less successful than they might be. This is because specialist teams, even the best, often stubbornly apply a process I call "Complexity-Oriented Design", or COD, which works as follows:</para>

<itemizedlist>
  <listitem><para>Management correctly identifies some interesting and difficult problem with economic value. In doing so they already leapfrog over any TOD team.</para></listitem>
  <listitem><para>The team with enthusiasm start to build prototypes and core layers. These work as designed and thus encouraged, the team go off into intense design and architecture discussions, coming up with elegant schemas that look beautiful and solid.</para></listitem>
  <listitem><para>Management comes back and challenges team with yet more difficult problems. We tend to equate value with cost, so the harder the problem, and more expensive to solve, the more the solution should be worth, in their minds.</para></listitem>
  <listitem><para>The team, being engineers and thus loving to build stuff, build stuff. They build and build and build and end-up with massive, perfectly-designed complexity.</para></listitem>
  <listitem><para>The products go to market, and the market scratches its head and asks, "seriously, is this the best you can do?" People do use the products, especially if they aren't spending their own money in climbing the learning curve.</para></listitem>
  <listitem><para>Management gets positive feedback from its larger customers, who share the same idea that high cost (in training and use) means high value. and so continues to push the process.</para></listitem>
  <listitem><para>Meanwhile somewhere across the world, a small team is solving the same problem using a better process, and a year later smashes the market to little pieces.</para></listitem>
</itemizedlist>
<para>COD is characterized by a team obsessively solving the wrong problems to the point of collective insanity. COD products tend to be large, ambitious, complex, and unpopular. Much open source software is the output of COD processes. It is insanely hard for engineers to <emphasis role="bold">stop</emphasis> extending a design to cover more potential problems. They argue, "what if someone wants to do X?" but never ask themselves, "what is the real value of solving X?"</para>

<para>A good example of COD in practice is Bluetooth, a complex, over-designed set of protocols that users hate. It continues to exist only because in a massively-patented industry there are no real alternatives. Bluetooth is perfectly secure, which is close to pointless for a proximity protocol. At the same time it lacks a standard API for developers, meaning it's really costly to use Bluetooth in applications.</para>

<para>On the #zeromq IRC channel, Wintre once wrote of how enraged he was many years ago when he "found that XMMS 2 had a working plugin system but could not actually play music."</para>

<para>COD is a form of large-scale "rabbit holing", in which designers and engineers cannot distance themselves from the technical details of their work. They add more and more features, utterly misreading the economics of their work.</para>

<para>The main lessons of COD are also simple but hard for experts to swallow. They are:</para>

<itemizedlist>
  <listitem><para>Making stuff that you don't immediately have a need for is pointless. Doesn't matter how talented or brilliant you are, if you just sit down and make stuff people are not actually asking for, you are most likely wasting your time.</para></listitem>
  <listitem><para>Problems are not equal. Some are simple, and some are complex. Ironically, solving the simpler problems often has more value to more people than solving the really hard ones. So if you allow engineers to just work on random things, they'll most focus on the most interesting but least worthwhile things.</para></listitem>
  <listitem><para>Engineers and designers love to make stuff and decoration, and this inevitably leads to complexity. It is crucial to have a "stop mechanism", a way to set short, hard deadlines that force people to make smaller, simpler answers to just the most crucial problems.</para></listitem>
</itemizedlist>
</sect2>
<sect2>
<title>Simplicity-Oriented Design</title>
<para>Finally, we come to the rare but precious Simplicity-Oriented Design. This process starts with a realization: we do not know what we have to make until after we start making it. Coming up with ideas, or large-scale designs isn't just wasteful, it's a direct hindrance to designing the truly accurate solutions. The really juicy problems are hidden like far valleys, and any activity except active scouting creates a fog that hides those distant valleys. You need to keep mobile, pack light, and move fast.</para>

<para>SOD works as follows:</para>

<itemizedlist>
  <listitem><para>We collect a set of interesting problems (by looking at how people use technology or other products) and we line these up from simple to complex, looking for and identifying patterns of use.</para></listitem>
  <listitem><para>We take the simplest, most dramatic problem and we solve this with a minimal plausible solution, or "patch". Each patch solves exactly a genuine and agreed problem in a brutally minimal fashion.</para></listitem>
  <listitem><para>We apply one measure of quality to patches, namely "can this be done any simpler while still solving the stated problem?" We can measure complexity in terms of concepts and models that the user has to learn or guess in order to use the patch. The fewer, the better. A perfect patch solves a problem with zero learning required by the user.</para></listitem>
  <listitem><para>Our product development consists of a patch that solves the problem "we need a proof of concept" and then evolves in an unbroken line to a mature series of products, through hundreds or thousands of patches piled on top of each other.</para></listitem>
  <listitem><para>We do not do <emphasis>anything</emphasis> that is not a patch. We enforce this rule with formal processes that demand that every activity or task is tied to a genuine and agreed problem, explicitly enunciated and documented.</para></listitem>
  <listitem><para>We build our projects into a supply chain where each project can provide problems to its "suppliers" and receive patches in return. The supply chain creates the "stop mechanism" since when people are impatiently waiting for an answer, we necessarily cut our work short.</para></listitem>
  <listitem><para>Individuals are free to work on any projects, and provide patches at any place they feel it's worthwhile. No individuals "own" any project, except to enforce the formal processes. A single project can have many variations, each a collection of different, competing patches.</para></listitem>
  <listitem><para>Projects export formal and documented interfaces so that upstream (client) projects are unaware of change happening in supplier projects. Thus multiple supplier projects can compete for client projects, in effect creating a free and competitive market.</para></listitem>
  <listitem><para>We tie our supply chain to real users and external clients and we drive the whole process by rapid cycles so that a problem received from outside users can be analyzed, evaluated, and solved with a patch in a few hours.</para></listitem>
  <listitem><para>At every moment from the very first patch, our product is shippable. This is essential, because a large proportion of patches will be wrong (10-30%) and only by giving the product to users can we know which patches have become problems and themselves need solving.</para></listitem>
</itemizedlist>
<para>SOD is a form of "hill climbing algorithm", a reliable way of finding optimal solutions to the most significant problems in an unknown landscape. You don't need to be a genius to use SOD successfully, you just need to be able to see the difference between the fog of activity and the progress towards new real problems.</para>

<para>A really good designer with a good team can use SOD to build world-class products, rapidly and accurately. To get the most out of SOD, the designer has to use the product continuously, from day 1, and develop his or her ability to smell out problems such as inconsistency, surprising behavior, and other forms of friction. We naturally overlook many annoyances but a good designer picks these up, and thinks about how to patch them. Design is about removing friction in the use of a product.</para>

<para>In an open source setting, we do this work in public. There's no "let's open the code" moment. Projects that do this are in my view missing the point of open source, which is to engage your users in your exploration, and to build community around the seed of the architecture.</para>

</sect2>
</sect1>
<sect1>
<title>Message Oriented Pattern for Elastic Design</title>
<para>Now I'll introduce MOPED, which is a SOD pattern custom-designed for &Oslash;MQ architectures. It was either MOPED or BIKE, the Backronym-Induced Kinetic Effect. That's short for BICICLE, the Backronym-Inflated See if I Care Less Effect. In life, one learns to go with the least embarrassing choices.</para>

<para>Speaking of embarrassments, just as &Oslash;MQ lets us aim for really massive architectures, it also, like any technology that removes friction, opens the door to truly massive blunders. If &Oslash;MQ is the ACME rocket-propelled shoe of distributed software development, a lot of us are like Wile E. Coyote, slamming full speed into the proverbial desert cliff.</para>

<para>So MOPED is meant to save us from such mistakes. Partly it's about slowing down, partly it's about ensuring that when you move fast, you go - and this is essential, dear reader - in the <emphasis>right direction</emphasis>. It's my standard interview riddle: what's the rarest property of any software system, the absolute hardest thing to get right, the lack of which causes the slow or fast death of the vast majority of projects? The answer is not code quality, funding, performance, or even (though it's a close answer), popularity. The answer is "accuracy".</para>

<para>If you've read the Guide observantly you'll have seen MOPED in action already. The development of Majordomo in Reliable Request-Reply Patterns<xref linkend="reliable-request-reply"/> is a near-perfect case. But cute names are worth a thousand words.</para>

<para>The goal of MOPED is to define a process, a pattern by which we can take a rough use case for a new distributed application, and go from "hello world" to fully-working prototype in any language in under a week.</para>

<para>Using MOPED, you grow, more than build, a working &Oslash;MQ architecture from the ground-up, with minimal risk of failure. By focusing on the contracts, rather than the implementations, you avoid the risk of premature optimization. By driving the design process through ultra-short test-based cycles, you can be more certain what you have works, before you add more.</para>

<para>We can turn this into five real steps:</para>

<itemizedlist>
  <listitem><para>Step 1: internalize the &Oslash;MQ semantics.</para></listitem>
  <listitem><para>Step 2: draw a rough architecture.</para></listitem>
  <listitem><para>Step 3: decide on the contracts.</para></listitem>
  <listitem><para>Step 4: make a minimal end-to-end solution.</para></listitem>
  <listitem><para>Step 5: solve one problem and repeat.</para></listitem>
</itemizedlist>
<sect2>
<title>Step 1: Internalize the Semantics</title>
<para>To repeat myself: you must learn &Oslash;MQ's language. The only way to learn a language is to use it. There's no way to avoid this investment, no tapes you can play while you sleep, no chips you can plug in to magically become smarter. Read the Guide, work through the code examples, understand what's going on, and (most importantly) write some examples yourself, and then <emphasis>throw them away</emphasis>.</para>

<para>At a certain point you'll feel a clicking noise in your brain. Maybe you'll have a weird chili-induced dream where little &Oslash;MQ tasks run around trying to eat you alive. Maybe you'll just think "aaahh, so <emphasis>that's</emphasis> what it means!" If we did our work right, it should take 2-3 days. However long it takes, until you start thinking in terms of &Oslash;MQ sockets and patterns, you're not ready for step 2.</para>

</sect2>
<sect2>
<title>Step 2: Draw a Rough Architecture</title>
<para>Whiteboard time. Get a couple of colleagues and try to draw your architecture on a whiteboard. you want to draw boxes connected with arrows, showing the flow of work, data, results, etc. Since we live in a gravity well, it's best to draw the main arrows going down. Almost all architectures have a <emphasis>direction</emphasis>, and a certain symmetry, and what you want to do is capture that as simply and cleanly as you can.</para>

<para>Ignore anything that's not central to the core problem. Ignore logging, error handling, recovery from failures, etc. What you leave out is as important as what you capture: you can always add, but it's very hard to remove. When you have a simple, clean drawing, you're ready for step 3.</para>

</sect2>
<sect2>
<title>Step 3: Decide on the Contracts</title>
<para>Human scale depends on contracts, and the more explicit they are, the better things scale. You don't care <emphasis>how</emphasis> things happen, only the results. If I send an email, I don't care how it arrives at its destination, so long as the contract (it arrives within a few minutes, it's not modified, it doesn't get lost) is respected.</para>

<para>And to build a large system that works well, you must focus on the contracts, before the implementations. It may sound obvious but all too often, people forget and ignore this, or are just too shy to impose themselves. I wish I could say &Oslash;MQ had done this properly but for years our public contracts were second-rate afterthoughts instead of primary in-your-face pieces of work.</para>

<para>So what is a contract in a distributed system? There are, in my experience, two types of contract:</para>

<itemizedlist>
  <listitem><para>The APIs to client applications. Remember the Psychological Elements. The APIs need to be as absolutely <emphasis>simple</emphasis>, <emphasis>consistent</emphasis>, and <emphasis>familiar</emphasis> as possible. Yes, you can generate API documentation from code, but you must first design it, and designing an API is often hard.</para></listitem>
  <listitem><para>The protocols that connect the pieces. It sounds like rocket science, but it's really just a simple trick, and one that &Oslash;MQ makes particularly easy. In fact they're so simple to write, and need so little bureaucracy that I call them "unprotocols".</para></listitem>
</itemizedlist>
<para>You write minimal contracts that are mostly just place markers. Most messages and most API methods will be missing, or empty. You also want to write down any known technical requirements in terms of throughput, latency, reliability, etc. These are the criteria on which you will accept, or reject, any particular piece of work.</para>

</sect2>
<sect2>
<title>Step 4: Write a Minimal End-to-End Solution</title>
<para>The goal is to test out the overall architecture as rapidly as possible. Make skeleton applications that call the APIs, and skeleton stacks that implement both sides of every protocol. You want to get a working end-to-end "hello world" as soon as you can. You want to be able to test code, as you write it, to weed-out the broken assumptions and inevitable errors you make. Do not go off and spend six months writing a test suite! Instead, make a minimal bare-bones application that uses our still-hypothetical API.</para>

<para>If you design an API wearing the hat of the person who implements it, you'll start to think of performance, features, options, and so on. You'll make it more complex, more irregular, and more surprising than it should be. But, and here's the trick (it's a cheap one, was big in Japan), if you design an API while wearing the hat of the poor sucker who has to actually write apps that use it, you use all that laziness and fear to our advantage.</para>

<para>Write down the protocols, on a wiki or shared document, in such a way that you can explain every command clearly without too much detail. Strip off any real functionality, because it'll create inertia that just makes it harder to move stuff around. You can always add weight. Don't spend effort defining formal message structures: pass the minimum around, in the simplest possible fashion, using &Oslash;MQ's multi-part framing.</para>

<para>Our goal is to get the simplest test case working, without any avoidable functionality. Everything you can chop off the list of things to do, you chop. Ignore the groans from colleagues and bosses. I'll repeat this once again: you can <emphasis>always</emphasis> add functionality, that's relatively easy. But aim to keep the overall weight to a minimum.</para>

</sect2>
<sect2>
<title>Step 5: Solve One Problem and Repeat</title>
<para>You're now in the Happy Loop of issue-driven development where you can start to solve tangible problems instead of adding features. Write issues that state a clear problem, and propose a solution. Keep in mind, as you design the API, your standards for names, consistency, and behavior. Writing these down in prose often helps keep them sane.</para>

<para>From here, every single change you make to the architecture and code is now proven by running the test case, watching it not work, making the change, and then watching it work.</para>

<para>Now you go through the whole cycle (extending the test case, fixing the API, updating the protocol, extending the code, as needed), taking problems one at a time and testing the solutions individually. It should take about 10-30 minutes for each cycle, with the occasional spike due to random confusion.</para>

</sect2>
</sect1>
<sect1>
<title>Unprotocols</title>
<sect2>
<title>Why Unprotocols?</title>
<para>When this man thinks of protocols, this man thinks of massive documents written by committees, over years. This man thinks of the IETF, W3C, ISO, Oasis, regulatory capture, FRAND patent license disputes, and soon after, this man thinks of retirement to a nice little farm in northern Bolivia up in the mountains where the only other needlessly stubborn beings are the goats chewing up the coffee plants.</para>

<para>Now, I've nothing personal against committees. The useless folk need a place to sit out their lives with minimal risk of reproducing, after all, that only seems fair. But most committee protocols tend towards complexity (the ones that work), or trash (the ones we don't talk about). There's a few reasons for this. One is the amount of money at stake. More money means more people who want their particular prejudices and assumptions expressed in prose. But two is the lack of good abstractions on which to build. People have tried to build reusable protocol abstractions, like BEEP. Most did not stick, and those that did, like SOAP and XMPP, are on the complex side of things.</para>

<para>It used to be, decades ago, when the Internet was a young modest thing, that protocols were short and sweet. They weren't even "standards", but "requests for comments", which is as modest as you can get. It's been one of my goals since we started iMatix in 1995 to find a way for ordinary people like me to write small, accurate protocols without the overhead of the committees.</para>

<para>Now, &Oslash;MQ does appear to provide a living, successful protocol abstraction layer with its "we'll carry multi-part messages over random transports" way of working. Since &Oslash;MQ deals silently with framing, connections, and routing, it's surprisingly easy to write full protocol specs on top of &Oslash;MQ, and in Reliable Request-Reply Patterns<xref linkend="reliable-request-reply"/> and Advanced Publish-Subscribe Patterns<xref linkend="advanced-pub-sub"/> I showed how to do this.</para>

<para>Somewhere around mid-2007, I kicked-off the Digital Standards Organization to define new simpler ways of producing little standards, protocols, specifications. In my defense, it was a quiet summer. At the time <ulink url="http://www.digistan.org/spec:1">I wrote that</ulink> a new specification should take "minutes to explain, hours to design, days to write, weeks to prove, months to become mature, and years to replace."</para>

<para>In 2010 we started calling such little specifications "unprotocols", which some people might mistake for a dastardly plan for world domination by a shadowy international organization, but which really just means, "protocols without the goats".</para>

</sect2>
<sect2>
<title>How to Write Unprotocols</title>
<para>When you start to write an unprotocol specification document, stick to a consistent structure so that your readers know what to expect. Here is the structure I use:</para>

<itemizedlist>
  <listitem><para>Cover section: with a 1-line summary, URL to the spec, formal name, version, who to blame.</para></listitem>
  <listitem><para>License for the text: absolutely needed for public specifications.</para></listitem>
  <listitem><para>The change process: i.e. how I as a reader fix problems in the specification?</para></listitem>
  <listitem><para>Use of language: MUST, MAY, SHOULD, etc. with a reference to RFC 2119.</para></listitem>
  <listitem><para>Maturity indicator: is this a experimental, draft, stable, legacy, retired?</para></listitem>
  <listitem><para>Goals of the protocol: what problems is it trying to solve?</para></listitem>
  <listitem><para>Formal grammar: prevents arguments due to different interpretation of the text.</para></listitem>
  <listitem><para>Technical explanation: semantics of each message, error handling, etc.</para></listitem>
  <listitem><para>Security discussion: explicitly, how secure the protocol is.</para></listitem>
  <listitem><para>References: to other documents, protocols, etc.</para></listitem>
</itemizedlist>
<para>Writing clear, expressive text is hard. Do avoid trying to describe implementations of the protocol. Remember that you're writing a contract. You describe in clear language the obligations and expectations of each party, the level of obligation, and the penalties for breaking the rules. You do not try to define <emphasis>how</emphasis> each party honors its part of the deal.</para>

<para>If you need reference material to start with, read the http://rfc.zeromq.org site, which has a bunch of unprotocols that you can copy/paste from.</para>

<para>Here are some key points about unprotocols:</para>

<itemizedlist>
  <listitem><para>As long as your process is open then you don't need a committee: just make clean minimal designs and make sure anyone is free to improve them.</para></listitem>
  <listitem><para>If use an existing license then you don't have legal worries afterwards. I use GPLv3 for my public specifications and advise you to do the same. For in-house work, standard copyright is perfect.</para></listitem>
  <listitem><para>The formality is valuable. That is, learn to write a formal grammar such as ABNF (Augmented Backus-Naur Form) and use this to fully document your messages.</para></listitem>
  <listitem><para>Use a market-driven life-cycle process like <ulink url="http://www.digistan.org/spec:1">Digistan's COSS</ulink> so that people place the right weight on your specs as they mature (or don't).</para></listitem>
</itemizedlist>
</sect2>
<sect2>
<title>Why use the GPLv3 for Public Specifications?</title>
<para>The license you choose is particularly crucial for public specifications. Traditionally, protocols are published under custom licenses, where the authors own the text and derived works are forbidden. This sounds great (after all, who wants to see a protocol forked?) but it's in fact highly risky. A protocol committee is vulnerable to capture, and if the protocol is important and valuable, the incentive for capture grows.</para>

<para>Once captured, like some wild animals, an important protocol will often die. The real problem is there's no way to <emphasis>free</emphasis> a captive protocol published under a conventional license. The word "free" isn't just an adjective to describe speech or air, it's also a verb, and the right to fork a work, <emphasis>against the wishes of the owner</emphasis>, is essential to avoiding capture.</para>

<para>Let me explain this in shorter words. Imagine iMatix writes a protocol today, that's really amazing and popular. We publish the spec and many people implement it. Those implementations are fast and awesome, and free as in beer. And they start to threaten an existing business. Their expensive commercial product is slower and can't compete. So one day they come to our iMatix office in Maetang-Dong, South Korea, and offer to buy our firm. Since we're spending vast amounts on sushi and beer and GFEs, we accept gratefully. With evil laughter the new owners of the protocol stop improving the public version, and close the specification and add patented extensions. Their new products support this, and they take over the whole market.</para>

<para>When you contribute to an open source project, you really want to know your hard work won't used against you by a closed-source competitor. Which is why the GPL beats the "more permissive" BSD/MIT/X11 licenses. These license give permission to cheat. This applies just as much to protocols as to source code.</para>

<para>When you implement a GPLv3 specification, your applications are of course yours, and licensed any way you like. But you can be sure and certain of two things. One, that specification will <emphasis>ever</emphasis> be embraced and extended into proprietary forms. Any derived forms of the specification must also be GPLv3. Two, no-one who ever implements or uses the protocol will ever launch a patent attack on anything it covers.</para>

</sect2>
<sect2>
<title>Using ABNF</title>
<para>My advice when writing protocol specs is to learn, and use a formal grammar. It's just less hassle than allowing others to interpret what you mean, and then recover from the inevitable false assumptions. The target of your grammar is other people, engineers, not compilers.</para>

<para>My favorite grammar is ABNF, as defined by <ulink url="http://www.ietf.org/rfc/rfc2234.txt">RFC 2234</ulink>, because it is probably the simplest and most widely used formal language for defining bidirectional communications protocols. Most IETF (Internet Engineering Task Force) specifications use ABNF, which is good company to be in.</para>

<para>I'll give a 30-second crash course in writing ABNF. It may remind you of regular expressions. You write the grammar as rules. Each rule takes the form "name = elements". An element can be another rule (which you define below as another rule), or a pre-defined "terminal" like CRLF, OCTET, or a number. <ulink url="http://www.ietf.org/rfc/rfc2234.txt">The RFC</ulink> lists all the terminals. To define alternative elements, use "element / element". To define repetition, use "*" (read the RFC since it's not intuitive). To group elements, use parentheses.</para>

<para>I'm not sure if this extension is proper, but I then prefix elements with "C:" and "S:" to indicate whether they come from the client or server.</para>

<para>Here's a piece of ABNF for an unprotocol called NOM that we'll come back to later in this chapter:</para>

<screen>nom-protocol    = open-peering *use-peering

open-peering    = C:OHAI ( S:OHAI-OK / S:WTF )

use-peering     = C:ICANHAZ
                / S:CHEEZBURGER
                / C:HUGZ S:HUGZ-OK
                / S:HUGZ C:HUGZ-OK
</screen>

<para>I've actually used these keywords (OHAI, WTF) in commercial projects. They make developers giggly and happy. They confuse management. They're good in first drafts that you want to throw away later.</para>

</sect2>
</sect1>
<sect1>
<title>Serializing your Data</title>
<para>When we start to design a protocol, one of the first questions we face is how we encode data on the wire. There is, sadly, no universal answer. There are a half-dozen different ways to serialize data, each with pros and cons. We'll explore these.</para>

<para>However, there is a general lesson I've learned over a couple of decades of writing protocols small and large. I call this the "Cheap and Nasty" pattern: you can often split your work into two layers, and solve these separately, one using a "cheap" approach, the other using a "nasty" approach.</para>

<sect2>
<title>Cheap and Nasty</title>
<para>The key insight to making Cheap and Nasty work is to realize that many protocols mix a low-volume chatty part for control, and a high-volume asynchronous part for data. For instance, HTTP has a chatty dialog to authenticate and get pages, and an asynchronous dialog to stream data. FTP actually splits this over two ports; one port for control and one port for data.</para>

<para>Protocol designers who don't separate control from data tend to make awful protocols, because the trade-offs in the two cases are almost totally opposite. What is perfect for control is terrible for data, and what's ideal for data just doesn't work for control. It's especially true when we want high-performance at the same time as extensibility and good error checking.</para>

<para>Let's break this down using a classic client-server use-case. The client connects to the server, and authenticates. It then asks for some resource. The server chats back, then starts to send data back to the client. Eventually the client disconnects or the server finishes, and the conversation is over.</para>

<para>Now, before starting to design these messages, stop and think, and let's compare the control dialog, and the data flow:</para>

<itemizedlist>
  <listitem><para>The control dialog lasts a short time and involve very few messages. The data flow could last for hours or days, and involve billions of messages.</para></listitem>
  <listitem><para>The control dialog is where all the "normal" errors happen, e.g. not authenticated, not found, payment required, censored, etc. Any errors that happen during the data flow are exceptional (disk full, server crashed).</para></listitem>
  <listitem><para>The control dialog is where things will change over time, as we add more options, parameters, and so on. The data flow should barely change over time since the semantics of a resource are fairly constant over time.</para></listitem>
  <listitem><para>The control dialog is essentially a synchronous request/reply dialog. The data flow is essentially a 1-way asynchronous flow.</para></listitem>
</itemizedlist>
<para>These differences are critical. When we talk about performance, it applies <emphasis>only</emphasis> to data flows. It's pathological to design a one-time control dialog to be fast. When we talk about the cost of serialization, thus, this only applies to the data flow. The cost of encoding/decoding the control flow could be huge, and for many cases it would not change a thing. So, we encode control using "Cheap", and we encode data flows using "Nasty".</para>

<para>Cheap is essentially synchronous, verbose, descriptive, and flexible. A Cheap message is full of rich information that can change for each application. Your goal as designer is to make this information easy to encode and to parse, trivial to extend for experimentation or growth, and highly robust against change both forwards and backwards. The Cheap part of a protocol looks like this:</para>

<itemizedlist>
  <listitem><para>It uses a simple self-describing structured encoding for data, be it XML, JSON, HTTP-style headers, or some other. Any encoding is fine so long as there are standard simple parsers for it in your target languages.</para></listitem>
  <listitem><para>It uses a straight request-reply model where each request has a success/failure reply. This makes it trivial to write correct clients and servers for a Cheap dialog.</para></listitem>
  <listitem><para>It doesn't try, even marginally, to be fast. Performance doesn't matter when you do something once or a few times per session.</para></listitem>
</itemizedlist>
<para>A Cheap parser is something you take off the shelf, and throw data at. It shouldn't crash, shouldn't leak memory, should be highly tolerant, and should be relatively simple to work with. That's it.</para>

<para>Nasty however is essentially asynchronous, terse, silent, and inflexible. A Nasty message carries minimal information that practically never changes. Your goal as designer is to make this information ultrafast to parse, and possibly even impossible to extend and experiment with. The ideal Nasty pattern looks like this:</para>

<itemizedlist>
  <listitem><para>It uses a hand-optimized binary layout for data, where every bit is precisely crafted.</para></listitem>
  <listitem><para>It uses a pure asynchronous model where one or both peers send data without acknowledgments (or if they do, they use sneaky asynchronous techniques like credit-based flow control).</para></listitem>
  <listitem><para>It doesn't try, even marginally, to be friendly. Performance is all that matters when you are doing something several million times per second.</para></listitem>
</itemizedlist>
<para>A Nasty parser is something you write by hand, which writes or reads bits, bytes, words, and integers individually and precisely. It rejects anything it doesn't like, does no memory allocations at all, and never crashes.</para>

<para>Cheap and Nasty isn't a universal pattern; not all protocols have this dichotomy. Also, how you use Cheap and Nasty will depend. In some cases, it can be two parts of a single protocol. In other cases it can be two protocols, one layered on top of the other.</para>

</sect2>
<sect2>
<title>&Oslash;MQ Framing</title>
<para>The simplest and most widely used serialization format for &Oslash;MQ applications is &Oslash;MQ's own multi-part framing. For example, here is how the <ulink url="http://rfc.zeromq.org/spec:7">Majordomo Protocol</ulink> defines a request:</para>

<screen>Frame 0: Empty frame
Frame 1: "MDPW01" (six bytes, representing MDP/Worker v0.1)
Frame 2: 0x02 (one byte, representing REQUEST)
Frame 3: Client address (envelope stack)
Frame 4: Empty (zero bytes, envelope delimiter)
Frames 5+: Request body (opaque binary)
</screen>

<para>To read and write this in code is easy. But this is a classic example of a control flow (the whole of MDP is, really, since it's a chatty request-reply protocol). When we came to improve MDP for the second version, we had to change this framing. Excellent, we broke all existing implementations!</para>

<para>Backwards compatibility is hard, but using &Oslash;MQ framing for control flows <emphasis>does not help</emphasis>. Here's how I should have designed this protocol if I'd followed by own advice (and I'll fix this in the next version). It's split into a Cheap part and a Nasty part, and uses the &Oslash;MQ framing to separate these:</para>

<screen>Frame 0: "MDP/2.0" for protocol name and version
Frame 1: command header
Frame 2: command body
</screen>

<para>Where we'd expect the parse the command header in the various intermediaries (client API, broker, and worker API), and pass the command body untouched from application to application.</para>

</sect2>
<sect2>
<title>Serialization Languages</title>
<para>Serialization languages have their fashions. XML used to be big as in popular, then it got big as in over-engineered, and then it fell into the hands of "Enterprise Information Architects" and it's not been seen alive since. Today's XML is the epitome of "somewhere in that mess is small, elegant language trying to escape".</para>

<para>Still XML, was way, way better than its predecessors which included such monsters as the Standard Generalized Markup Language (SGML), which in turn were a cool breeze compared to mind-torturing beasts like EDIFACT. So the history of serialization languages seems to be of gradually emerging sanity, hidden by waves of revolting EIAs doing their best to hold onto their jobs.</para>

<para>JSON popped out of the JavaScript world as a quick-and-dirty "I'd rather resign than use XML here" way to throw data onto the wire and get it back again. JSON is just minimal XML expressed, sneakily, as JavaScript source code.</para>

<para>Here's a simple example of using JSON in a Cheap protocol:</para>

<screen>"protocol": {
    "name": "MTL",
    "version": 1
},
"virtual-host": "test-env"
</screen>

<para>The same in XML would be (XML forces us to invent a single top-level entity):</para>

<screen>&lt;command&gt;
    &lt;protocol name = "MTL" version = "1" /&gt;
    &lt;virtual-host&gt;test-env&lt;/virtual-host&gt;
&lt;/command&gt;
</screen>

<para>And using plain-old HTTP-style headers:</para>

<screen>Protocol: MTL/1.0
Virtual-host: test-env
</screen>

<para>These are all pretty equivalent so long as you don't go overboard with validating parsers, schemas and such "trust us, this is all for your own good" nonsense. A Cheap serialization language gives you space for experimentation for free ("ignore any elements/attributes/headers that you don't recognize"), and it's simple to write generic parsers that e.g. thunk a command into a hash table, or vice-versa.</para>

<para>However it's not all roses. While modern scripting languages support JSON and XML easily enough, older languages do not. If you use XML or JSON, you create non-trivial dependencies. It's also somewhat of a pain to work with tree-structured data in a language like C.</para>

<para>So you can drive your choice according to the languages you're aiming for. If your universe is a scripting language then go for JSON. If you are aiming to build protocols for wider system use, keep things simple for C developers and stick to HTTP-style headers.</para>

</sect2>
<sect2>
<title>Serialization Libraries</title>
<para>The msgpack.org site says, "It's like JSON. but fast and small. MessagePack is an efficient binary serialization format. It lets you exchange data among multiple languages like JSON but it's faster and smaller. For example, small integers (like flags or error code) are encoded into a single byte, and typical short strings only require an extra byte in addition to the strings themselves."</para>

<para>I'm going to make the perhaps unpopular claim that "fast and small" are features that solve non-problems. The only real problem that serialization libraries solve is, as far as I can tell, the need to document the message contracts and actually serialize data to and from the wire.</para>

<para>Let's start with "fast and small". It's based on a two-part argument. First, that making your messages smaller, and that reducing CPU cost for encoding and decoding will make a significant different to your application's performance. Second, that this equally valid across-the-board to all messages.</para>

<para>But most real applications tend to fall into one of two categories. Either the speed of serialization and size of encoding is marginal compared to other costs, such as database access or application code performance. Or, network performance really is critical, and then all significant costs occur in a few specific message types.</para>

<para>Thus, aiming for "fast and small" across the board is a false optimization. You neither get the easy flexibility of Cheap for your infrequent control flows, nor do you get the brutal efficiency of Nasty for your high-volume data flows. Worse, the assumption that all messages are equal in some way can corrupt your protocol design. Cheap and Nasty isn't only about serialization strategies, it's also about synchronous vs. asynchronous, error handling, and the cost of change.</para>

<para>My experience is that most performance problems in message-based applications can be solved by (a) improving the application itself and (b) hand-optimizing the high-volume data flows. And to hand-optimize your most critical data flows, you need to cheat, know and exploit facts about your data, which is something general-purpose serializers cannot do.</para>

<para>Now to documentation: the need to write our contracts explicitly and formally, not in code. This is a valid problem to solve, indeed one of the main ones if we're to build a long-lasting large-scale message-based architecture.</para>

<para>Here is how we describe a typical message using the MessagePack IDL:</para>

<screen>message Person {
  1: string surname
  2: string firstname
  3: optional string email
}
</screen>

<para>Now, the same message using the protobufs IDL:</para>

<screen>message Person {
  required string surname = 1;
  required string firstname = 2;
  optional string email = 3;
}
</screen>

<para>It works but in most practical cases, wins you little over a serialization language backed by decent specifications written by hand or produced mechanically (we'll come to this). The price you'll pay is an extra dependency, and quite probably, worse overall performance than if you used Cheap and Nasty.</para>

</sect2>
<sect2>
<title>Hand-written Binary Serialization</title>
<para>As you'll gather from this book, my preferred language for systems programming is C (upgraded to C99, with a constructor/destructor API model and generic containers). There are two reasons I like this modernized C language: firstly, I'm too weak-minded to learn a big language like C++. Life just seems filled with more interesting things to understand. Secondly, I find that this specific level of manual control lets me produce better results, and faster.</para>

<para>The point here isn't C vs. C++ but the value of manual control for high-end professional users. It's no accident that the best cars and cameras and espresso machines in the world have manual controls. That level of on-the-spot fine-tuning often makes the difference between world-class success, and second-best.</para>

<para>When you are really, truly, concerned about the speed of serialization and/or the size of the result (often these contradict each other), you need hand-written binary serialization, in other words, let's hear it for Mr. Nasty!</para>

<para>Your basic process for writing an efficient Nasty encoder/decoder (codec) is:</para>

<itemizedlist>
  <listitem><para>Build representative data sets and test applications that can stress-test your codec.</para></listitem>
  <listitem><para>Write a first dumb version of the codec.</para></listitem>
  <listitem><para>Test, measure, improve, and repeat until you run out of time and/or money.</para></listitem>
</itemizedlist>
<para>Here are some of the techniques we use to make our codecs better:</para>

<itemizedlist>
  <listitem><para><emphasis>Use a profiler.</emphasis> There's simply no way to know what your code is doing until you've profiled it, for function counts and for CPU cost per function. Once you find your hot-spots, fix them.</para></listitem>
  <listitem><para><emphasis>Eliminate memory allocations.</emphasis> On a modern Linux kernel the heap is very fast, but it's still the bottleneck in most naive codecs. On older kernels the heap can be tragically slow. Use local variables (the stack) instead of the heap where you can.</para></listitem>
  <listitem><para><emphasis>Test on different platforms and with different compilers and compiler options.</emphasis> Apart from the heap, there are many other differences. You need to learn the main ones, and allow for these.</para></listitem>
  <listitem><para><emphasis>Use state to compress better.</emphasis> If you are concerned about codec performance, you are almost definitely sending the same kinds of data many times. There will be redundancy between instances of data. You can detect these, and use that to compress (e.g. a short value that means "same as last time").</para></listitem>
  <listitem><para><emphasis>Know your data.</emphasis> The best compression techniques (in terms of CPU cost for compactness) require knowing about the data. For example the techniques to compress a word list, a video, and a stream of stock market data are all different.</para></listitem>
  <listitem><para><emphasis>Be ready to break the rules.</emphasis> Do you really need to encode integers in big-endian network byte order? x86 and ARM account for almost all modern CPUs, yet use little-endian (ARM is actually bi-endian but Android, like Windows and iOS, is little-endian).</para></listitem>
</itemizedlist>
</sect2>
<sect2>
<title>Code Generation</title>
<para>Reading the previous two sections, you might have wondered, "could I write my own IDL generator that was better than a general-purpose one?" If this thought wandered into your mind, it probably left pretty soon after, chased by dark calculations about how much work that actually involved.</para>

<para>What if I told you of a way to build custom IDL generators cheaply and quickly? A way to get perfectly documented contracts, code that is as evil and domain-specific as you need, and all you need to do is sign away your soul (<emphasis>who ever really used that, amirite?</emphasis>) right here...</para>

<para>At iMatix, until a few years ago, we used code generation to build ever larger and more ambitious systems until we decided the technology (GSL) was too dangerous for common use, and we sealed the archive and locked it, with heavy chains, in a deep dungeon. Well, we actually posted it on github. If you want to try the examples that are coming up, grab <ulink url="https://github.com/imatix/gsl">the repository</ulink> and build yourself a <literal>gsl</literal> command. Typing "make" in the src subdirectory should do it (and if you're that guy who loves Windows, I'm sure you'll send a patch with project files).</para>

<para>This section isn't really about GSL at all, but about a useful and little-known trick that's useful for ambitious architects who want to scale themselves, as well as their work. Once you learn the trick is, you can whip up your own code generators in a short time. The code generators most software engineers know about come with a single hard-coded model. For instance, Ragel "compiles executable finite state machines from regular languages", i.e. Ragel's model is a regular language. This certainly works for a good set of problems but it's far from universal. How do you describe an API in Ragel? Or a project makefile? Or even a finite-state machine like the one we used to design the Binary Star pattern in Reliable Request-Reply Patterns<xref linkend="reliable-request-reply"/>?</para>

<para>All these would benefit from code generation, but there's no universal model. So the trick is to design your own models as you need them, then make code generators as cheap compilers for that model. You need some experience in how to make good models, and you need a technology that makes it cheap to build custom code generators. Scripting languages like Perl and Python are a good option. However we actually built GSL specifically for this, and that's what I prefer.</para>

<para>Let's take a simple example that ties into what we already know. We'll see more extensive examples later, because I really do believe that code generation is crucial knowledge for large-scale work. In Reliable Request-Reply Patterns<xref linkend="reliable-request-reply"/>, we developed the <ulink url="http://rfc.zeromq.org/spec:7">Majordomo Protocol (MDP)</ulink>, and wrote clients, brokers, and workers for that. Now could we generate those pieces mechanically, by building our own interface description language and code generators?</para>

<para>When we write a GSL model, we can use <emphasis>any</emphasis> semantics we like, in other words we can invent domain-specific languages on the spot. I'll invent a couple - see if you can guess what they represent:</para>

<screen>slideshow
    name = Cookery level 3
    page
        title = French Cuisine
        item = Overview
        item = The historical cuisine
        item = The nouvelle cuisine
        item = Why the French live longer
    page
        title = Overview
        item = Soups and salads
        item = Le plat principal
        item = BÃ©chamel and other sauces
        item = Pastries, cakes, and quiches
        item = SoufflÃ© - cheese to strawberry
</screen>

<para>How about this one:</para>

<screen>table
    name = person
    column
        name = firstname
        type = string
    column
        name = lastname
        type = string
    column
        name = rating
        type = integer
</screen>

<para>The first we could compile into a presentation. The second, into SQL to create and work with a database table. So for this exercise our domain language, our model, consists of "classes" that contain "messages" that contain "fields" of various types. It's deliberately familiar. Here is the MDP client protocol:</para>

<screen>&lt;class name = "mdp_client"&gt;
    MDP/Client
    &lt;header&gt;
        &lt;field name = "empty" type = "string" value = ""
            &gt;Empty frame&lt;/field&gt;
        &lt;field name = "protocol" type = "string" value = "MDPC01"
            &gt;Protocol identifier&lt;/field&gt;
    &lt;/header&gt;
    &lt;message name = "request"&gt;
        Client request to broker
        &lt;field name = "service" type = "string"&gt;Service name&lt;/field&gt;
        &lt;field name = "body" type = "frame"&gt;Request body&lt;/field&gt;
    &lt;/message&gt;
    &lt;message name = "reply"&gt;
        Response back to client
        &lt;field name = "service" type = "string"&gt;Service name&lt;/field&gt;
        &lt;field name = "body" type = "frame"&gt;Response body&lt;/field&gt;
    &lt;/message&gt;
&lt;/class&gt;
</screen>

<para>And here is the MDP worker protocol:</para>

<screen>&lt;class name = "mdp_worker"&gt;
    MDP/Worker
    &lt;header&gt;
        &lt;field name = "empty" type = "string" value = ""
            &gt;Empty frame&lt;/field&gt;
        &lt;field name = "protocol" type = "string" value = "MDPW01"
            &gt;Protocol identifier&lt;/field&gt;
        &lt;field name = "id" type = "octet"&gt;Message identifier&lt;/field&gt;
    &lt;/header&gt;
    &lt;message name = "ready" id = "1"&gt;
        Worker tells broker it is ready
        &lt;field name = "service" type = "string"&gt;Service name&lt;/field&gt;
    &lt;/message&gt;
    &lt;message name = "request" id = "2"&gt;
        Client request to broker
        &lt;field name = "client" type = "frame"&gt;Client address&lt;/field&gt;
        &lt;field name = "body" type = "frame"&gt;Request body&lt;/field&gt;
    &lt;/message&gt;
    &lt;message name = "reply" id = "3"&gt;
        Worker returns reply to broker
        &lt;field name = "client" type = "frame"&gt;Client address&lt;/field&gt;
        &lt;field name = "body" type = "frame"&gt;Request body&lt;/field&gt;
    &lt;/message&gt;
    &lt;message name = "hearbeat" id = "4"&gt;
        Either peer tells the other it's still alive
    &lt;/message&gt;
    &lt;message name = "disconnect" id = "5"&gt;
        Either peer tells other the party is over
    &lt;/message&gt;
&lt;/class&gt;
</screen>

<para>GSL uses XML as its modeling language. XML has a poor reputation, having been dragged through too many enterprise sewers to smell sweet, but it has some strong positives, as long as you keep it simple. Any way to write a self-describing hierarchy of items and attributes would work.</para>

<para>Now here is a short IDL generator written in GSL that turns our protocol models into documentation:</para>

<screen>.#  Trivial IDL generator (specs.gsl)
.#
.output "$(class.name).md"
## The $(string.trim (class.?''):left) Protocol
.for message
.   frames = count (class-&gt;header.field) + count (field)

A $(message.NAME) command consists of a multi-part message of $(frames)
frames:

.   for class-&gt;header.field
.       if name = "id"
* Frame $(item ()): 0x$(message.id:%02x) (1 byte, $(message.NAME))
.       else
* Frame $(item ()): "$(value:)" ($(string.length ("$(value)")) \
bytes, $(field.:))
.       endif
.   endfor
.   index = count (class-&gt;header.field) + 1
.   for field
* Frame $(index): $(field.?'') \
.       if type = "string"
(printable string)
.       elsif type = "frame"
(opaque binary)
.           index += 1
.       else
.           echo "E: unknown field type: $(type)"
.       endif
.       index += 1
.   endfor
.endfor
</screen>

<para>The XML models and this script are in the subdirectory examples/models. To do the code generation I give this command:</para>

<screen>gsl -script:specs mdp_client.xml mdp_worker.xml
</screen>

<para>Here is the Markdown text we get for the worker protocol:</para>

<screen>## The MDP/Worker Protocol

A READY command consists of a multi-part message of 4
frames:

* Frame 1: "" (0 bytes, Empty frame)
* Frame 2: "MDPW01" (6 bytes, Protocol identifier)
* Frame 3: 0x01 (1 byte, READY)
* Frame 4: Service name (printable string)

A REQUEST command consists of a multi-part message of 5
frames:

* Frame 1: "" (0 bytes, Empty frame)
* Frame 2: "MDPW01" (6 bytes, Protocol identifier)
* Frame 3: 0x02 (1 byte, REQUEST)
* Frame 4: Client address (opaque binary)
* Frame 6: Request body (opaque binary)

A REPLY command consists of a multi-part message of 5
frames:

* Frame 1: "" (0 bytes, Empty frame)
* Frame 2: "MDPW01" (6 bytes, Protocol identifier)
* Frame 3: 0x03 (1 byte, REPLY)
* Frame 4: Client address (opaque binary)
* Frame 6: Request body (opaque binary)

A HEARBEAT command consists of a multi-part message of 3
frames:

* Frame 1: "" (0 bytes, Empty frame)
* Frame 2: "MDPW01" (6 bytes, Protocol identifier)
* Frame 3: 0x04 (1 byte, HEARBEAT)

A DISCONNECT command consists of a multi-part message of 3
frames:

* Frame 1: "" (0 bytes, Empty frame)
* Frame 2: "MDPW01" (6 bytes, Protocol identifier)
* Frame 3: 0x05 (1 byte, DISCONNECT)
</screen>

<para>Which as you can see is close to what I wrote by hand in the original spec. Now, if you have cloned the Guide repository and you are looking at the code in examples/models, you can generate the MDP client and worker codecs. We pass the same two models to a different code generator:</para>

<screen>gsl -script:codec_c mdp_client.xml mdp_worker.xml
</screen>

<para>Which gives us mdp_client and mdp_worker classes. Actually MDP is so simple that it's barely worth the effort of writing the code generator. The profit comes when we want to change the protocol (which we did for the standalone Majordomo project). You modify the protocol, run the command, and out pops more perfect code.</para>

<para>The <literal>codec_c.gsl</literal> code generator is not short, but the resulting codecs are much better than the hand-written code I originally put together for Majordomo. For instance the hand-written code had no error checking, and would die if you passed it bogus messages.</para>

<para>I'm now going to explain the pros and cons of GSL-powered model-oriented code generation. Power does not come for free and one of the greatest traps in our business is the ability to invent concepts out of thin air. GSL makes this particularly easy, so can be a particularly dangerous tool.</para>

<para><emphasis>Do not invent concepts</emphasis>. The job of a designer is to remove problems, not to add features.</para>

<para>So, first, the advantages of model-oriented code generation:</para>

<itemizedlist>
  <listitem><para>You can create 'perfect' abstractions that map to your real world. So, our protocol model maps 100% to the 'real world' of Majordomo. This would be impossible without the freedom to tune and change the model in any way.</para></listitem>
  <listitem><para>You can develop these perfect models quickly and cheaply.</para></listitem>
  <listitem><para>You can generate <emphasis>any</emphasis> text output. From a single model you can create documentation, code in any language, test tools, literally any output you can think of.</para></listitem>
  <listitem><para>You can generate (and I mean this literally) <emphasis>perfect</emphasis> output since it's cheap to improve your code generators to any level you want.</para></listitem>
  <listitem><para>You get a single source that combines specifications and semantics.</para></listitem>
  <listitem><para>You can leverage a small team to a massive size. At iMatix we produced the million-line OpenAMQ messaging product out of perhaps 85K lines of input models, including the code generation scripts themselves.</para></listitem>
</itemizedlist>
<para>Now the disadvantages:</para>

<itemizedlist>
  <listitem><para>You add tool dependencies to your project.</para></listitem>
  <listitem><para>You may get carried away and create models for the pure joy of creating them.</para></listitem>
  <listitem><para>You may alienate newcomers to your work, who will see "strange stuff".</para></listitem>
  <listitem><para>You may give people a strong excuse to not invest in your project.</para></listitem>
</itemizedlist>
<para>Cynically, model-oriented abuse works great in environments where you want to produce huge amounts of perfect code that you can maintain with little effort, and which <emphasis>no-one can ever take away from you.</emphasis> Personally, I like to cross my rivers and move on. But if long-term job security is your thing, this is almost perfect.</para>

<para>So if you do use GSL and want to create open communities around your work, here is my advice:</para>

<itemizedlist>
  <listitem><para>Use only where you would otherwise be writing tiresome code by hand.</para></listitem>
  <listitem><para>Design natural models that are what people would expect to see.</para></listitem>
  <listitem><para>Write the code by hand first so you know what to generate.</para></listitem>
  <listitem><para>Do not overuse. Keep it simple! <emphasis>Do not get too meta!!</emphasis></para></listitem>
  <listitem><para>Introduce gradually into a project.</para></listitem>
  <listitem><para>Put the generated code into your repositories.</para></listitem>
</itemizedlist>
<para>We're already using GSL in some projects around &Oslash;MQ, for example the high-level C binding, CZMQ, uses GSL to generate the socket options class (zsockopt). A 300-line code generator turns 78 lines of XML model into 1,500 lines of perfect but really boring code. That's a good win.</para>

</sect2>
</sect1>
<sect1>
<title>Transferring Files</title>
<para>Let's take a break from the lecturing and get back to our first love and the reason for doing all of this: code.</para>

<para>"How do I send a file?" is a common question on the &Oslash;MQ mailing lists. Not surprising, because file transfer is perhaps the oldest and most obvious type of messaging. Sending files around networks has lots of use-cases apart from annoying the copyright cartels. &Oslash;MQ is very good, out of the box, at sending events and tasks but less good at sending files.</para>

<para>I've promised, for a year or two, to write a proper explanation. Here's a gratuitous piece of information to brighten your morning: the word "proper" comes from the archaic French "propre" which means "clean". The dark age English common folk, not being familiar with hot water and soap, changed the word to mean "foreign" or "upper-class", as in "that's proper food!" but later the word meant just "real", as in "that's a proper mess you've gotten us into!"</para>

<para>So, file transfer. There are several reasons you can't just pick up a random file, blindfold it, and shove it whole into a message. The most obvious being that despite decades of determined growth in RAM sizes (and who among us old-timers doesn't fondly remember saving up for that 1,014-byte memory extension card?!), disk sizes obstinately remain much larger. Even if we could send a file with one instruction (say, using a system call like sendfile), we'd hit the reality that networks are not infinitely fast, nor perfectly reliable. After trying to upload a large file several times on a slow flaky network (WiFi, anyone?), you'll realize that a proper file transfer protocol needs a way to recover from failures. That is, a way to send only the part of a file that wasn't yet received.</para>

<para>Finally, after all this, if you build a proper file server, you'll notice that simply sending massive amounts of data to lots of clients creates that situation we like to call, in the technical parlance, "server went belly-up due to all available heap memory being eaten by a poorly-designed application". A proper file transfer protocol needs to pay attention to memory use.</para>

<para>We'll solve these problems properly, one by one, which should hopefully get us to a good and proper file transfer protocol running over &Oslash;MQ. First, let's generate a 1GB test file with random data (real power-of-two-giga-like-Von-Neumman-intended, not the fake silicon ones the memory industry likes to sell):</para>

<screen>dd if=/dev/urandom of=testdata bs=1M count=1024
</screen>

<para>This is large enough to be troublesome when we have lots of clients asking for the same file at once, and on many machines, 1GB is going to be too large to allocate in memory anyhow. As a base reference, let's measure how long it takes to copy this file from disk back to disk. This will tell us how much our file transfer protocol adds on top (including 'network' costs):</para>

<screen>$ time cp testdata testdata2

real    0m7.143s
user    0m0.012s
sys     0m1.188s
</screen>

<para>The 4-figure precision is misleading; expect variations of 25% either way. This is just an "order of magnitude" measurement.</para>

<para>Here's our first cut at the code, where the client asks for the test data and the server just sends it, without stopping for breath, as a series of messages, where each message holds one 'chunk':</para>

<example id="fileio1-c">
<title>File transfer test, model 1 (fileio1.c)</title>
<programlisting language="c">
//  File Transfer model #1
//  
//  In which the server sends the entire file to the client in
//  large chunks with no attempt at flow control.

#include &lt;czmq.h&gt;
#define CHUNK_SIZE  250000

static void
client_thread (void *args, zctx_t *ctx, void *pipe)
{
    void *dealer = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_connect (dealer, "tcp://127.0.0.1:6000");
    
    zstr_send (dealer, "fetch");
    size_t total = 0;       //  Total bytes received
    size_t chunks = 0;      //  Total chunks received
    
    while (true) {
        zframe_t *frame = zframe_recv (dealer);
        if (!frame)
            break;              //  Shutting down, quit
        chunks++;
        size_t size = zframe_size (frame);
        zframe_destroy (&amp;frame);
        total += size;
        if (size == 0)
            break;              //  Whole file received
    }
    printf ("%zd chunks received, %zd bytes\n", chunks, total);
    zstr_send (pipe, "OK");
}

static void
free_chunk (void *data, void *arg)
{
    free (data);
}
</programlisting>

</example>
<para>The server thread reads the file from disk in chunks, and sends each chunk to the client as a separate message. We only have one test file, so open that once and then serve it out as needed: 
</para>

<example id="fileio1-c-1">
<title>File transfer test, model 1 (fileio1.c) - File server thread</title>
<programlisting language="c">

static void
server_thread (void *args, zctx_t *ctx, void *pipe)
{
    FILE *file = fopen ("testdata", "r");
    assert (file);

    void *router = zsocket_new (ctx, ZMQ_ROUTER);
    //  Default HWM is 1000, which will drop messages here
    //  since we send more than 1,000 chunks of test data,
    //  so set an infinite HWM as a simple, stupid solution:
    zsocket_set_hwm (router, 0);
    zsocket_bind (router, "tcp://*:6000");
    while (true) {
        //  First frame in each message is the sender identity
        zframe_t *identity = zframe_recv (router);
        if (!identity)
            break;              //  Shutting down, quit
            
        //  Second frame is "fetch" command
        char *command = zstr_recv (router);
        assert (streq (command, "fetch"));
        free (command);

        while (true) {
            byte *data = malloc (CHUNK_SIZE);
            assert (data);
            size_t size = fread (data, 1, CHUNK_SIZE, file);
            zframe_t *chunk = zframe_new_zero_copy (data, size, free_chunk, NULL);
            zframe_send (&amp;identity, router, ZFRAME_REUSE + ZFRAME_MORE);
            zframe_send (&amp;chunk, router, 0);
            if (size == 0)
                break;          //  Always end with a zero-size frame
        }
        zframe_destroy (&amp;identity);
    }
    fclose (file);
}
</programlisting>

</example>
<para>The main task starts the client and server threads; it's easier to test this as a single process with threads, than as multiple processes: 
</para>

<example id="fileio1-c-2">
<title>File transfer test, model 1 (fileio1.c) - File main thread</title>
<programlisting language="c">

int main (void)
{
    //  Start child threads
    zctx_t *ctx = zctx_new ();
    zthread_fork (ctx, server_thread, NULL);
    void *client =
    zthread_fork (ctx, client_thread, NULL);
    //  Loop until client tells us it's done
    char *string = zstr_recv (client);
    free (string);
    //  Kill server thread
    zctx_destroy (&amp;ctx);
    return 0;
}
</programlisting>

</example>
<para>It's pretty simple but we already run into a problem: if we send too much data to the ROUTER socket, we can easily overflow it. The simple but stupid solution is to put an infinite high-water mark on the socket. It's stupid because we now have no protection against exhausting the server's memory. Yet without an infinite HWM we risk losing chunks of large files.</para>

<para>Try this: set the HWM to 1,000 (in &Oslash;MQ/3.x this is the default) and then reduce the chunk size to 100K so we send 10K chunks in one go. Run the test, and you'll see it never finishes. As the <literal>zmq_socket()</literal> man page says with cheerful brutality, for the ROUTER socket: "ZMQ_HWM option action: Drop".</para>

<para>We have to control the amount of data the server sends up-front. There's no point in it sending more than the network can handle. Let's try sending one chunk at a time. In this version of the protocol, the client will explicitly say,"give me chunk N", and the server will fetch that specific chunk from disk and send it.</para>

<para>Here's the improved second model, where the client asks for one chunk at a time, and the server only sends one chunk for each request it gets from the client:</para>

<example id="fileio2-c">
<title>File transfer test, model 2 (fileio2.c)</title>
<programlisting language="c">
//  File Transfer model #2
//  
//  In which the client requests each chunk individually, thus
//  eliminating server queue overflows, but at a cost in speed.

#include &lt;czmq.h&gt;
#define CHUNK_SIZE  250000

static void
client_thread (void *args, zctx_t *ctx, void *pipe)
{
    void *dealer = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_set_hwm (dealer, 1);
    zsocket_connect (dealer, "tcp://127.0.0.1:6000");

    size_t total = 0;       //  Total bytes received
    size_t chunks = 0;      //  Total chunks received

    while (true) {
        //  Ask for next chunk
        zstr_sendfm (dealer, "fetch");
        zstr_sendfm (dealer, "%ld", total);
        zstr_sendf  (dealer, "%ld", CHUNK_SIZE);
        
        zframe_t *chunk = zframe_recv (dealer);
        if (!chunk)
            break;              //  Shutting down, quit
        chunks++;
        size_t size = zframe_size (chunk);
        zframe_destroy (&amp;chunk);
        total += size;
        if (size &lt; CHUNK_SIZE)
            break;              //  Last chunk received; exit
    }
    printf ("%zd chunks received, %zd bytes\n", chunks, total);
    zstr_send (pipe, "OK");
}

static void
free_chunk (void *data, void *arg)
{
    free (data);
}
</programlisting>

</example>
<para>The server thread waits for a chunk request from a client, reads that chunk and sends it back to the client: 
</para>

<example id="fileio2-c-1">
<title>File transfer test, model 2 (fileio2.c) - File server thread</title>
<programlisting language="c">

static void
server_thread (void *args, zctx_t *ctx, void *pipe)
{
    FILE *file = fopen ("testdata", "r");
    assert (file);

    void *router = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_set_hwm (router, 1);
    zsocket_bind (router, "tcp://*:6000");
    while (true) {
        //  First frame in each message is the sender identity
        zframe_t *identity = zframe_recv (router);
        if (!identity)
            break;              //  Shutting down, quit
            
        //  Second frame is "fetch" command
        char *command = zstr_recv (router);
        assert (streq (command, "fetch"));
        free (command);

        //  Third frame is chunk offset in file
        char *offset_str = zstr_recv (router);
        size_t offset = atoi (offset_str);
        free (offset_str);

        //  Fourth frame is maximum chunk size
        char *chunksz_str = zstr_recv (router);
        size_t chunksz = atoi (chunksz_str);
        free (chunksz_str);

        //  Read chunk of data from file
        fseek (file, offset, SEEK_SET);
        byte *data = malloc (chunksz);
        assert (data);

        //  Send resulting chunk to client
        size_t size = fread (data, 1, chunksz, file);
        zframe_t *chunk = zframe_new_zero_copy (data, size, free_chunk, NULL);
        zframe_send (&amp;identity, router, ZFRAME_MORE);
        zframe_send (&amp;chunk, router, 0);
    }
    fclose (file);
}

//  The main task is just the same as in the first model.
...
</programlisting>

</example>
<para>It is much slower now, because of the to-and-fro chatting between client and server. We pay about 300 microseconds for each request-reply round-trips, on a local loop connection (client and server on the same box). It doesn't sound like much but it adds up quickly:</para>

<screen>$ time ./fileio1
4296 chunks received, 1073741824 bytes

real    0m0.669s
user    0m0.056s
sys     0m1.048s

$ time ./fileio2
4295 chunks received, 1073741824 bytes

real    0m2.389s
user    0m0.312s
sys     0m2.136s
</screen>

<para>There are two valuable lessons here. First, while request-reply is easy, it's also too slow for high-volume data flows. Paying that 300 microseconds once would be fine. Paying it for every single chunk isn't acceptable, particularly on real networks with latencies of perhaps 1,000 times higher.</para>

<para>The second point is something I've said before but will repeat: it's incredibly easy to experiment, measure, and improve our protocols over &Oslash;MQ. And when the cost of something comes way down, you can afford a lot more of it. Do learn to develop and prove your protocols in isolation: I've seen teams waste time trying to improve poorly-designed protocols that are too deeply embedded in applications to be easily testable or fixable.</para>

<para>Our model 2 file transfer protocol isn't so bad, apart from performance:</para>

<itemizedlist>
  <listitem><para>It completely eliminates any risk of memory exhaustion. To prove that we set the high-water mark to 1 in both sender and receiver.</para></listitem>
  <listitem><para>It lets the client choose the chunk size, which is useful because if there's any tuning of the chunk size to be done, for network conditions, for file types, or to reduce memory consumption further, it's the client that should be doing this.</para></listitem>
  <listitem><para>It gives us fully restartable file transfers.</para></listitem>
  <listitem><para>It allows the client to cancel the file transfer at any point in time.</para></listitem>
</itemizedlist>
<para>If we just didn't have to do a request for each chunk, it'd be a usable protocol. What we need is a way for the server to send multiple chunks, without waiting for the client to request or acknowledge each one. What are the options?</para>

<itemizedlist>
  <listitem><para>The server could send 10 chunks at once, then wait for a single acknowledgment. That's exactly like multiplying the chunk size by 10, so pointless. And yes, it's just as pointless for all values of 10.</para></listitem>
  <listitem><para>The server could send chunks without any chatter from the client but with a slight delay between each send, so that it would send chunks only as fast as the network could handle them. This would require the server to know what's happening at the network layer, which sounds like hard work. It also breaks layering horribly. And what happens if the network is really fast but the client itself is slow? Where are chunks queued then?</para></listitem>
  <listitem><para>The server could try to spy on the sending queue, i.e. see how full it is, and send only when the queue isn't full. Well, &Oslash;MQ doesn't allow that because it doesn't work, for the same reason as throttling doesn't work. The server and network may be more than fast enough, but the client may be a slow little device.</para></listitem>
  <listitem><para>We could modify libzmq to take some other action on reaching HWM. Perhaps it could block? That would mean that a single slow client would block the whole server, so no thank you. Maybe it could return an error to the caller? Then the server could do something smart like... well, there isn't really anything it could do that's any better than dropping the message.</para></listitem>
</itemizedlist>
<para>Apart from being complex and variously unpleasant, none of these options would even work. What we need is a way for the client to tell the server, asynchronously and in the background, that it's ready for more. Some kind of asynchronous flow control. If we do this right, data should flow without interruption from the server to the client, but only as long as the client is reading it. Let's review our three protocols. This was the first one:</para>

<screen>C: fetch
S: chunk 1
S: chunk 2
S: chunk 3
....
</screen>

<para>And the second introduced a request for each chunk:</para>

<screen>C: fetch chunk 1
S: send chunk 1
C: fetch chunk 2
S: send chunk 2
C: fetch chunk 3
S: send chunk 3
C: fetch chunk 4
....
</screen>

<para>Now - waves hands mysteriously - here's a changed protocol that fixes the performance problem:</para>

<screen>C: fetch chunk 1
C: fetch chunk 2
C: fetch chunk 3
S: send chunk 1
C: fetch chunk 4
S: send chunk 2
S: send chunk 3
....
</screen>

<para>It looks suspiciously similar. In fact it's identical except that we send multiple requests without waiting for a reply for each one. This is a technique called "pipelining" and it works because our DEALER and ROUTER sockets are fully asynchronous.</para>

<para>Here's the third model of our file transfer test-bench, with pipelining. The client sends a number of requests ahead (the "credit") and then each time it processes an incoming chunk, it sends one more credit. The server will never send more chunks than the client has asked for:</para>

<example id="fileio3-c">
<title>File transfer test, model 3 (fileio3.c)</title>
<programlisting language="c">
//  File Transfer model #3
//  
//  In which the client requests each chunk individually, using
//  command pipelining to give us a credit-based flow control.

#include &lt;czmq.h&gt;
#define CHUNK_SIZE  250000
#define PIPELINE    10

static void
client_thread (void *args, zctx_t *ctx, void *pipe)
{
    void *dealer = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_set_hwm (dealer, PIPELINE);
    zsocket_connect (dealer, "tcp://127.0.0.1:6000");

    //  We'll allow up to five chunks in transit at once
    size_t credit = PIPELINE;
    
    size_t total = 0;       //  Total bytes received
    size_t chunks = 0;      //  Total chunks received
    size_t offset = 0;      //  Offset of next chunk request
    
    while (true) {
        while (credit) {
            //  Ask for next chunk
            zstr_sendfm (dealer, "fetch");
            zstr_sendfm (dealer, "%ld", offset);
            zstr_sendf  (dealer, "%ld", CHUNK_SIZE);
            offset += CHUNK_SIZE;
            credit--;
        }
        zframe_t *chunk = zframe_recv (dealer);
        if (!chunk)
            break;              //  Shutting down, quit
        chunks++;
        credit++;
        size_t size = zframe_size (chunk);
        zframe_destroy (&amp;chunk);
        total += size;
        if (size &lt; CHUNK_SIZE)
            break;              //  Last chunk received; exit
    }
    printf ("%zd chunks received, %zd bytes\n", chunks, total);
    zstr_send (pipe, "OK");
}

//  The rest of the code is exactly the same as in model 2, except
//  that we set the HWM on the server's ROUTER socket to PIPELINE
//  to act as a sanity check.
...
</programlisting>

</example>
<para>What we've achieved here, with a little magic, is to take control of the end-to-end pipeline including all network buffers and &Oslash;MQ queues at sender and receiver, and then ensure that pipeline is always filled with data while never growing beyond a predefined limit. More than that, the client decides exactly when to send "credit" to the sender. It could be when it receives a chunk, or when it has fully processed a chunk. And this happens asynchronously, with no significant performance cost.</para>

<para>In the third model I chose a pipeline size of 10 messages (each message is a chunk). This will cost a maximum of 2.5MB memory per client. So with 1GB of memory we can handle at least 400 clients. We can try to calculate the ideal pipeline size. It takes about 0.7 seconds to send the 1GB file, which is about 160 microseconds for a chunk. A round trip is 300 microseconds, so the pipeline needs to be at least 3-5 to keep the server busy. In practice, I still got performance spikes with a pipeline of 5, probably because the credit messages sometimes get delayed by outgoing data. So at 10, it works consistently.</para>

<screen>$ time ./fileio3
4291 chunks received, 1072741824 bytes

real    0m0.777s
user    0m0.096s
sys     0m1.120s
</screen>

<para>Do measure rigorously. Your calculations may be good but the real world tends to have its own opinions.</para>

<para>What we've made is clearly not yet a real file transfer protocol, but it proves the pattern and I think it is the simplest plausible design. For a real working protocol we'd want to add some or all of:</para>

<itemizedlist>
  <listitem><para>Authentication and access controls, even without encryption: the point isn't to protect sensitive data but to catch errors like sending test data to production servers.</para></listitem>
  <listitem><para>A Cheap-style request including file path, optional compression, and other stuff we've learned is useful from HTTP (such as If-Modified-Since).</para></listitem>
  <listitem><para>A Cheap-style response, at least for the first chunk, that provides meta data such as file size (so the client can pre-allocate and avoid unpleasant disk-full situations).</para></listitem>
  <listitem><para>The ability to fetch a set of files in one go, otherwise the protocol becomes inefficient for large sets of small files.</para></listitem>
  <listitem><para>Confirmation from the client when it's fully received a file, to recover from chunks that might be lost of the client disconnects unexpectedly.</para></listitem>
</itemizedlist>
<para>So far, our semantic has been "fetch"; that is, the recipient knows (somehow), that they need a specific file, so they ask for it. The knowledge of which files exist, and where they are is then passed out-of-band (e.g. in HTTP, by links in the HTML page).</para>

<para>How about a "push" semantic? There are two plausible use-cases for this. First, if we adopt a centralized architecture with files on a main "server" (not something I'm advocating, but people do sometimes like this), then it's very useful to allow clients to upload files to the server. Second, it lets do a kind of pub-sub for files, where the client asks for all new files of some type; as the server gets these, it forwards them to the client.</para>

<para>A fetch semantic is synchronous, while a push semantic is asynchronous. Asynchronous is less chatty, so faster. Also, you can do cute things like "subscribe to this path" so creating a publish-subscribe file transfer architecture. That is so obviously awesome that I shouldn't need to explain what problem it solves.</para>

<para>Still, here is the problem with the fetch semantic: that out-of-band route to tell clients what files exist. No matter how you do this, it ends up complex. Either clients have to poll, or you need a separate pub-sub channel to keep clients up to date, or you need user interaction.</para>

<para>Thinking this through a little more, though, we can see that fetch is just a special case of publish-subscribe. So we can get the best of both worlds. Here is the general design:</para>

<itemizedlist>
  <listitem><para>Fetch this path</para></listitem>
  <listitem><para>Here is credit (repeat)</para></listitem>
</itemizedlist>
<para>To make this work (and we will, my dear readers), we need to be a little more explicit about how we send credit to the server. The cute trick of treating a pipelined "fetch chunk" request as credit won't fly since the client doesn't know any longer what files actually exist, how large they are, anything. If the client says, "I'm good for 250,000 bytes of data", this should work equally for one file of 250K bytes, or 100 files of 2,500 bytes.</para>

<para>And this gives us "credit-based flow control", which effectively removes the need for HWMs, and any risk of memory overflow.</para>

</sect1>
<sect1>
<title>Heartbeating</title>
<para>Just as a real protocol needs to solve the problem of flow control, it also needs to solve the problem of knowing whether a peer is alive or dead. This is not an issue specific to &Oslash;MQ. TCP has a long timeout (30 minutes or so), that means that it can be impossible to know whether a peer has died, been disconnected, or gone on a weekend to Prague with a case of vodka, a redhead, and a large expense account.</para>

<para>Heartbeating is not easy to get right, and as with flow control it can make the difference between a working, and failing architecture. So using our standard approach, let's start with the simplest possible heartbeat design, and develop better and better designs until we have one with no visible faults.</para>

<sect2>
<title>Shrugging It Off</title>
<para>A decent first iteration is to do no heartbeating at all and see what actually happens. Many if not most &Oslash;MQ applications do this. &Oslash;MQ encourages this by hiding peers in many cases. What problems does this approach cause?</para>

<itemizedlist>
  <listitem><para>When we use a ROUTER socket in an application that tracks peers, as peers disconnect and reconnect, the application will leak memory and get slower and slower.</para></listitem>
  <listitem><para>When we use SUB or DEALER-based data recipients, we can't tell the difference between good silence (there's no data) and bad silence (the other end died). When a recipient knows the other side died, it can for example switch over to a backup route.</para></listitem>
  <listitem><para>If we use a TCP connection that stays silent for a long while, it will, in some networks, just die. Sending something (technically, a "keep-alive" more than a heartbeat), will keep the network alive.</para></listitem>
</itemizedlist>
</sect2>
<sect2>
<title>One-Way Heartbeats</title>
<para>So, our first solution is to sending a "heartbeat" message from each node to its peers, every second or so. When one node hears nothing from another, within some timeout (several seconds, typically), it will treat that peer as dead. Sounds good, right? Sadly no. This works in some cases but has nasty edge cases in other cases.</para>

<para>For PUB-SUB, this does work, and it's the only model you can use. SUB sockets cannot talk back to PUB sockets, but PUB sockets can happily send "I'm alive" messages to their subscribers.</para>

<para>As an optimization, you can send heartbeats only when there is no real data to send. Furthermore, you can send heartbeats progressively slower and slower, if network activity is an issue (e.g. on mobile networks where activity drains the battery). As long as the recipient can detect a failure (sharp stop in activity), that's fine.</para>

<para>Now the typical problems with this design:</para>

<itemizedlist>
  <listitem><para>It can be inaccurate when we send large amounts of data, since heartbeats will be delayed behind that data. If heartbeats are delayed, you can get false timeouts and disconnections due to network congestion. Thus, always treat <emphasis>any</emphasis> incoming data as a heartbeat, whether or not the sender optimizes out heartbeats.</para></listitem>
  <listitem><para>While the PUB-SUB pattern will drop messages for disappeared recipients, PUSH and DEALER sockets will queue them. So, if you send heartbeats to a dead peer, and it comes back, it'll get all the heartbeats you sent. Which can be thousands. Whoa, whoa!</para></listitem>
  <listitem><para>This design assumes that heartbeat timeouts are the same across the whole network. But that won't be accurate. Some peers will want very aggressive heart-beating, to detect faults rapidly. And some will want very relaxed heart-beating, to let sleeping networks lie, and save power.</para></listitem>
</itemizedlist>
</sect2>
<sect2>
<title>Ping-Pong Heartbeats</title>
<para>Our third design uses a ping-pong dialog. One peer sends a ping command to the other, which replies with a pong command. Neither command has any payload. Pings and pongs are not correlated. Since the roles of "client" and "server" are often arbitrary, we specify that either peer can in fact send a ping and expect a pong in response. However, since the timeouts depend on network topologies known best to dynamic clients, it is usually the client which pings the server.</para>

<para>This works for all ROUTER-based brokers. The same optimizations we used in the second model make this work even better: treat any incoming data as a pong, and only send a ping when not otherwise sending data.</para>

</sect2>
</sect1>
<sect1>
<title>State Machines</title>
<para>Software engineers tend to treat (finite) state machines as a kind of intermediary interpreter. That is, you take a regular language and compile that into a state machine, then execute the state machine. The state machine itself is rarely visible to the developer: it's an internal representation, optimized, compressed, and bizarre.</para>

<para>However it turns out that state machines are also valuable as a first-class modeling languages for protocol handlers, i.e. &Oslash;MQ clients and servers. &Oslash;MQ makes it rather easy to design protocols, but we've never defined a good pattern for writing those clients and servers properly.</para>

<para>A protocol has at least two levels:</para>

<itemizedlist>
  <listitem><para>How we represent individual messages on the wire.</para></listitem>
  <listitem><para>How messages flow between peers, and the significance of each message.</para></listitem>
</itemizedlist>
<para>We've seen in this chapter how to produce codecs that handle serialization. That's a good start. But if we leave the second job to developers, that gives them a lot of room to interpret. As we make more ambitious protocols (file transfer + heart-beating + credit + authentication), it becomes less and less sane to try to implement clients and servers by hand.</para>

<para>Yes, people do this almost systematically. But the costs are high, and they're avoidable. I'll explain how to model protocols using state machines, and how to generate neat and solid code from those models.</para>

<para>My experience with using state machines as a software construction tool dates to 1985 and my first real job making tools for application developers. In 1991 I turned that knowledge into a free software tool called Libero, which spat out executable state machines from a simple text model.</para>

<para>The thing about Libero's model was that it was readable. That is, you described your program logic as named states, each accepting a set of events, each doing some real work. The resulting state machine hooked into your application code, driving it like a boss.</para>

<para>Libero was charmingly good at its job, fluent in many languages, and modestly popular given the enigmatic nature of state machines. We used Libero in anger in dozens of large distributed applications, one of which was finally switched off in 2011. State-machine driven code construction worked so well that it's somewhat impressive this approach never hit the mainstream of software engineering.</para>

<para>So in this section I'm going to explain Libero's model, and show how to use it to generate &Oslash;MQ clients and servers. We'll use GSL again but like I said, the principles are general and you can put together code generators using any scripting language.</para>

<para>As a worked example let's see how to carry-on a stateful dialog with a peer on a ROUTER socket. We'll develop the server using a state machine (and the client by hand). We have a simple protocol that I'll call "NOM". I'm using the oh-so-very-serious <ulink url="http://unprotocols.org/blog:2">keywords for unprotocols</ulink> proposal:</para>

<screen>nom-protocol    = open-peering *use-peering

open-peering    = C:OHAI ( S:OHAI-OK / S:WTF )

use-peering     = C:ICANHAZ
                / S:CHEEZBURGER
                / C:HUGZ S:HUGZ-OK
                / S:HUGZ C:HUGZ-OK
</screen>

<para>I've not found a quick way to explain the true nature of state machine programming. In my experience, it invariably takes a few days of practice. After three or four days' exposure to the idea there is a near-audible 'click!' as something in the brain connects all the pieces together. We'll make it concrete by looking at the state machine for our NOM server.</para>

<para>A useful thing about state machines is that you can read them state by state. Each state has a unique descriptive name, and one or more <emphasis>events</emphasis>, which we list in any order. For each event we perform zero or more <emphasis>actions</emphasis>, and we then move to a <emphasis>next state</emphasis> (or stay in the same state).</para>

<para>In a &Oslash;MQ protocol server, we have a state machine instance <emphasis>per client</emphasis>. That sounds complex but it isn't, as we'll see. We describe our first state (Start) as having one valid event, "OHAI". We check the user's credentials and then arrive in the Authenticated state(<xref linkend="figure-69"/>).</para>

<figure id="figure-69">
    <title>The 'Start' State</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig69.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>The Check Credentials action produces either an 'ok' or an 'error' event. It's in the Authenticated state that we handle these two possible events, by sending an appropriate reply back to the client(<xref linkend="figure-70"/>). If authentication failed, we return to the Start state where the client can try again.</para>

<figure id="figure-70">
    <title>The 'Authenticated' State</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig70.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>When authentication has succeeded, we arrive in the Ready state. Here we have three possible events: an ICANHAZ or HUGZ message from the client, or a heartbeat timer event(<xref linkend="figure-71"/>).</para>

<figure id="figure-71">
    <title>The 'Ready' State</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig71.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>There are a few more things about this state machine model that are worth knowing:</para>

<itemizedlist>
  <listitem><para>Events in upper case (like "HUGZ") are 'external events' that come from the client as messages.</para></listitem>
  <listitem><para>Events in lower case (like "heartbeat") are 'internal events', produced by code in the server.</para></listitem>
  <listitem><para>The "Send SOMETHING" actions are shorthand for sending a specific reply back to the client.</para></listitem>
  <listitem><para>Events that aren't defined in a particular state are silently ignored.</para></listitem>
</itemizedlist>
<para>Now, the original source for these pretty pictures is an XML model:</para>

<screen>&lt;class name = "nom_server" script = "server_c"&gt;

&lt;state name = "start"&gt;
    &lt;event name = "OHAI" next = "authenticated"&gt;
        &lt;action name = "check credentials" /&gt;
    &lt;/event&gt;
&lt;/state&gt;

&lt;state name = "authenticated"&gt;
    &lt;event name = "ok" next = "ready"&gt;
        &lt;action name = "send" message ="OHAI-OK" /&gt;
    &lt;/event&gt;
    &lt;event name = "error" next = "start"&gt;
        &lt;action name = "send" message = "WTF" /&gt;
    &lt;/event&gt;
&lt;/state&gt;

&lt;state name = "ready"&gt;
    &lt;event name = "ICANHAZ"&gt;
        &lt;action name = "send" message = "CHEEZBURGER" /&gt;
    &lt;/event&gt;
    &lt;event name = "HUGZ"&gt;
        &lt;action name = "send" message = "HUGZ-OK" /&gt;
    &lt;/event&gt;
    &lt;event name = "heartbeat"&gt;
        &lt;action name = "send" message = "HUGZ" /&gt;
    &lt;/event&gt;
&lt;/state&gt;
&lt;/class&gt;
</screen>

<para>The code generator is in examples/models/server_c.gsl. It is a fairly complete tool that I'll use and expand for more serious work later. It generates:</para>

<itemizedlist>
  <listitem><para>A server class in C (nom_server.c, nom_server.h) that implements the whole protocol flow.</para></listitem>
  <listitem><para>A selftest method that runs the selftest steps listed in the XML file.</para></listitem>
  <listitem><para>Documentation in the form of graphics (the pretty pictures).</para></listitem>
</itemizedlist>
<para>Here's a simple main program that starts the generated NOM server:</para>

<programlisting language="c">
#include "czmq.h"
#include "nom_server.h"

int main (int argc, char *argv [])
{
    printf ("Starting NOM protocol server on port 6000...\n");
    nom_server_t *server = nom_server_new ();
    nom_server_bind (server, "tcp://*:6000");
    nom_server_wait (server);
    nom_server_destroy (&amp;server);
    return 0;
}
</programlisting>

<para>The generated nom_server class is a fairly classic model. It accepts client messages on a ROUTER socket. The first frame on every request is the client's identity. The server manages a set of clients, each with state. As messages arrive, it feeds these as 'events' to the state machine. Here's the core of the state machine, as a mix of GSL commands and the C code we intend to generate:</para>

<programlisting language="c">
client_execute (client_t *self, int event)
{
    self-&gt;next_event = event;
    while (self-&gt;next_event) {
        self-&gt;event = self-&gt;next_event;
        self-&gt;next_event = 0;
        switch (self-&gt;state) {
.for class.state
            case $(name:c)_state:
.   for event
.       if index () &gt; 1
                else
.       endif
                if (self-&gt;event == $(name:c)_event) {
.       for action
.           if name = "send"
                    zmsg_addstr (self-&gt;reply, "$(message:)");
.           else
                $(name:c)_action (self);
.           endif
.       endfor
.       if defined (event.next)
                    self-&gt;state = $(next:c)_state;
.       endif
                }
.   endfor
                break;
.endfor
        }
        if (zmsg_size (self-&gt;reply) &gt; 1) {
            zmsg_send (&amp;self-&gt;reply, self-&gt;router);
            self-&gt;reply = zmsg_new ();
            zmsg_add (self-&gt;reply, zframe_dup (self-&gt;address));
        }
    }
}
</programlisting>

<para>Each client is held as an object with various properties, including the variables we need to represent a state machine instance:</para>

<programlisting language="c">
event_t next_event;         //  Next event
state_t state;              //  Current state
event_t event;              //  Current event
</programlisting>

<para>You will see by now that we are generating technically-perfect code that has the precise design and shape we want. The only clue that the nom_server class isn't hand-written is that the code is <emphasis>too good</emphasis>. People who complain that code generators produce poor code are obviously used to poor code generators. It is trivial to extend our model as we need it. For example, here's how we generate the selftest code.</para>

<para>First, we add a "selftest" item to the state machine and write our tests. We're not using any XML grammar or validators so it really is just a matter of opening the editor and adding half-a-dozen lines of text:</para>

<screen>&lt;selftest&gt;
    &lt;step send = "OHAI" body = "Sleepy" recv = "WTF" /&gt;
    &lt;step send = "OHAI" body = "Joe" recv = "OHAI-OK" /&gt;
    &lt;step send = "ICANHAZ" recv = "CHEEZBURGER" /&gt;
    &lt;step send = "HUGZ" recv = "HUGZ-OK" /&gt;
    &lt;step recv = "HUGZ" /&gt;
&lt;/selftest&gt;
</screen>

<para>Designing on the fly, I decided that "send" and "recv" were a nice way to express "send this request, then expect this reply". Here's the GSL code that turns this model into real code:</para>

<screen>.for class-&gt;selftest.step
.   if defined (send)
    msg = zmsg_new ();
    zmsg_addstr (msg, "$(send:)");
.       if defined (body)
    zmsg_addstr (msg, "$(body:)");
.       endif
    zmsg_send (&amp;msg, dealer);

.   endif
.   if defined (recv)
    msg = zmsg_recv (dealer);
    assert (msg);
    command = zmsg_popstr (msg);
    assert (streq (command, "$(recv:)"));
    free (command);
    zmsg_destroy (&amp;msg);

.   endif
.endfor
</screen>

<para>Finally, one of the more tricky but absolutely essential parts of any state machine generator is <emphasis>how do I plug this into my own code?</emphasis> As a minimal example for this exercise I wanted to implement the "check credentials" action by accepting all OHAIs from my friend Joe (Hi Joe!) and reject everyone else's OHAIs. After some thought I decided to grab code directly from the state machine model. So in nom_server.xml, you'll see this:</para>

<screen>&lt;action name = "check credentials"&gt;
    char *body = zmsg_popstr (self-&gt;request);
    if (body &amp;&amp; streq (body, "Joe"))
        self-&gt;next_event = ok_event;
    else
        self-&gt;next_event = error_event;
    free (body);
&lt;/action&gt;
</screen>

<para>And the code generator grabs that custom code and inserts it into the generated nom_server.c file:</para>

<screen>.for class.action
static void
$(name:c)_action (client_t *self) {
$(string.trim (.):)
}
.endfor
</screen>

<para>And now we have something quite elegant: a single source file that describes my server state machine, and which also contains the native implementations for my actions. A nice mix of high-level and low-level that is about 90% smaller than the C code.</para>

<para>Beware, as your head spins with notions of all the amazing things you could produce with such leverage. While this approach gives you real power, it also moves you away from your peers, and if you go too far, you'll find yourself working alone.</para>

<para>By the way, this simple little state machine design exposes just three variables to our custom code:</para>

<itemizedlist>
  <listitem><para><literal>self->next_event</literal></para></listitem>
  <listitem><para><literal>self->request</literal></para></listitem>
  <listitem><para><literal>self->reply</literal></para></listitem>
</itemizedlist>
<para>In the Libero state machine model there are a few more concepts that we've not used here, but which we will need when we write larger state machines:</para>

<itemizedlist>
  <listitem><para>Exceptions, which lets us write terser state machines. When an action raises an exception, further processing on the event stops. The state machine can then define how to handle exception events.</para></listitem>
  <listitem><para>Defaults state, where we can define default handling for events (especially useful for exception events).</para></listitem>
</itemizedlist>
</sect1>
<sect1>
<title>Authentication using SASL</title>
<para>When we designed AMQP in 2007, we chose <ulink url="http://en.wikipedia.org/wiki/Simple_Authentication_and_Security_Layer">SASL</ulink> for the authentication layer, one of the ideas we took from the BEEP protocol framework. SASL looks complex at first, but it's simple and fits very nicely into a &Oslash;MQ-based protocol. What I especially like about SASL is that it's scalable. You can start with anonymous access, or plain text authentication and no security, and grow to more secure mechanisms over time, without changing your protocol one bit.</para>

<para>I'm not going to give a deep explanation now, since we'll see SASL in action somewhat later. But I'll explain the principle so you're already somewhat prepared.</para>

<para>In the NOM protocol the client started with an OHAI command, which the server either accepted ("Hi Joe!") or rejected. This is simple but not scalable since server and client have to agree upfront what kind of authentication they're going to do.</para>

<para>What SASL introduced, and which is genius, is a fully abstracted and negotiable security layer that's still easy to implement at the protocol level. It works as follows:</para>

<itemizedlist>
  <listitem><para>The client connects.</para></listitem>
  <listitem><para>The server challenges the client, passing a list of security "mechanisms" that it knows about.</para></listitem>
  <listitem><para>The client chooses a security mechanism that it knows about, and answers the server's challenge with a blob of opaque data that (and here's the neat trick) some generic security library calculates and gives to the client.</para></listitem>
  <listitem><para>The server takes the security mechanism the client choose, and that blob of data, and passes it to its own security library.</para></listitem>
  <listitem><para>The library either accepts the client's answer, or the server challenges again.</para></listitem>
</itemizedlist>
<para>There are a number of free SASL libraries. When we come to real code, we'll implement just two mechanisms, ANONYMOUS and PLAIN, which don't need any special libraries.</para>

<para>To support SASL we have to add an optional challenge/response step to our "open-peering" flow. Here is what the resulting protocol grammar looks like (I'm modifying NOM to do this):</para>

<screen>secure-nom      = open-peering *use-peering

open-peering    = C:OHAI *( S:ORLY C:YARLY ) ( S:OHAI-OK / S:WTF )

ORLY            = 1*mechanism challenge
mechanism       = string
challenge       = *OCTET

YARLY           = mechanism response
response        = *OCTET
</screen>

<para>Where ORLY and YARLY contain a string (a list of mechanisms in ORLY, one mechanism in YARLY) and a blob of opaque data. Depending on the mechanism, the initial challenge from the server may be empty. We don't care a jot: we just pass this to the security library to deal with.</para>

<para>The SASL <ulink url="http://tools.ietf.org/html/rfc4422">RFC</ulink> goes into detail about other features (that we don't need), the kinds of ways SASL could be attacked, and so on.</para>

<para>Unless you're a security geek, all you should care about is the impact on the protocol, which is as simple as I've explained here.</para>

</sect1>
<sect1>
<title>Large-scale File Publishing</title>
<para>Let's put all these techniques together into a file distribution system that I'll call FileMQ. This is going to be a real product, living on <ulink url="https://github.com/hintjens/filemq">github.com</ulink>. What we'll make here is a first version of FileMQ, as a training tool. If the concept works, the real thing may eventually get its own Guide.</para>

<sect2>
<title>Why make FileMQ?</title>
<para>Why make a file distribution system? I already explained how to send large files over &Oslash;MQ, and it's really quite simple. But if you want to make messaging accessible to a million times more people than can use &Oslash;MQ, you need another kind of API. An API that my five-year old son can understand. An API that is universal, requires no programming, and works with just about every single application.</para>

<para>Yes, I'm talking about the file system. It's the DropBox pattern: chuck your files somewhere, and they get magically copied somewhere else, when the network connects again.</para>

<para>However what I'm aiming for is a fully decentralized architecture that looks more like git, that doesn't need any cloud services (though we could put FileMQ in the cloud), and which does multicast, i.e. can send files to many places at once.</para>

<para>FileMQ has to be secure(able), has to be easily hooked into random scripting languages, and has to be as fast as possible across our domestic and office networks.</para>

<para>I want to use it to back-up photos from my mobile phone to my laptop, over WiFi. To share presentation slides in real-time across fifty laptops in a conference. To share documents with colleagues in a meeting. To send earthquake data from sensors to central clusters. To back-up video from my phone as I take it, during protests or riots. To synchronize configuration files across a cloud of Linux servers.</para>

<para>A visionary idea, isn't it? Well, ideas are cheap. The hard part is making this, and making it simple.</para>

</sect2>
<sect2>
<title>Initial Design Cut - the API</title>
<para>Here's the way I see the first design. FileMQ has to be distributed, so every node can be a server and a client at the same time. But I don't want the protocol to be symmetric, because that seems forced. We have a natural flow of files from point A to point B, where A is the "server" and B is the "client". If files flow back the other way, we have two flows. So, FileMQ is <emphasis>not</emphasis> a synchronization protocol, though synchronizing two directories is going to be a common use case.</para>

<para>Thus, I'm going to build FileMQ as two pieces: a client, and a server. Then, I'll put these together in a main application (the "filemq" tool) that can act both as client and server. The two pieces will look quite similar to the nom_server, with the same kind of API:</para>

<programlisting language="c">
fmq_server_t *server = fmq_server_new ();
fmq_server_bind (server, "tcp://*:6000");
fmq_server_publish (server, "/home/ph/filemq/share", "/public");
fmq_server_publish (server, "/home/ph/photos/stream", "/photostream");

fmq_client_t *client = fmq_client_new ();
fmq_client_connect (client, "tcp://pieter.filemq.org:6000");
fmq_client_subscribe (server, "/public/", "/home/ph/filemq/share");
fmq_client_subscribe (server, "/photostream/", "/home/ph/photos/stream");

while (!zctx_interrupted)
    sleep (1);

fmq_server_destroy (&amp;server);
fmq_client_destroy (&amp;client);
</programlisting>

<para>If we wrap this C API in other languages, we can easily script FileMQ, embed it applications, port it to smartphones, and so on.</para>

</sect2>
<sect2>
<title>Initial Design Cut - the Protocol</title>
<para>To start with we write down the protocol as an ABNF grammar. Our grammar starts with the flow of commands between the client and server. You should recognize these as a combination of the various techniques we've seen already:</para>

<screen>filemq-protocol = open-peering *use-peering [ close-peering ]

open-peering    = C:OHAI *( S:ORLY C:YARLY ) ( S:OHAI-OK / error )

use-peering     = C:ICANHAZ ( S:ICANHAZ-OK / error )
                / C:NOM
                / S:CHEEZBURGER
                / C:HUGZ S:HUGZ-OK
                / S:HUGZ C:HUGZ-OK

close-peering   = C:KTHXBAI / S:KTHXBAI

error           = S:SRSLY / S:RTFM
</screen>

<para>Here are the messages to and from the server:</para>

<screen>;   The client opens peering to the server
OHAI            = %x01 protocol version identity
protocol        = string        ; Must be "FILEMQ"
string          = size *VCHAR
size            = OCTET
version         = %x01
identity        = 16OCTET

;   The server challenges the client using the SASL model
ORLY            = %x02 mechanisms challenge
mechanisms      = size 1*mechanism
mechanism       = string
challenge       = *OCTET        ; 0MQ frame

;   The client responds with SASL authentication information
YARLY           = %x03 mechanism response
response        = *OCTET        ; 0MQ frame

;   The server grants the client access
OHAI-OK         = %x04

;   The client subscribes to a path
ICANHAZ         = %x05 path options
path            = string        ; Full or partial path
options         = dictionary
dictionary      = size *key-value
key-value       = string        ; Formatted as name=value

;   The server confirms the subscription
ICANHAZ-OK      = %x06

;   The client sends credit to the server
NOM             = %x07 credit
credit          = number
number          = 8OCTET        ; 64-bit integer, network order
sequence        = number

;   The server sends a chunk of file data
CHEEZBURGER     = %x08 sequence operation filename
                  offset headers chunk
sequence        = number
operation       = OCTET
filename        = string
offset          = number
headers         = dictionary
chunk           = FRAME

;   Client or server sends a heartbeat, the other peer responds
HUGZ            = %x09
HUGZ-OK         = %x0A

;   Client closes the peering
KTHXBAI         = %x0B
</screen>

<para>And here are the different ways the server can tell the client things went wrong:</para>

<screen>;   Server error replies
S:SRSLY         = %x80 reason    ; Refused due to access rights
S:RTFM          = %x81 reason    ; Client sent an invalid command
</screen>

<para>The FILEMQ/1.0 protocol is specified on the <ulink url="http://rfc.zeromq.org/spec:19">&Oslash;MQ unprotocols website</ulink>.</para>

</sect2>
<sect2>
<title>Building and Trying FileMQ</title>
<para>The FileMQ stack is <ulink url="https://github.com/hintjens/filemq">on github</ulink>. It works like a classic C/C++ project:</para>

<screen>git clone git://github.com/hintjens/filemq.git
cd filemq
./autogen.sh
./configure
make check
</screen>

<para>You want to be using the latest CZMQ master for this. Now try running the <literal>track</literal> command, which is a simple tool that uses FileMQ to track changes in one directory in another:</para>

<screen>cd src
./track ./fmqroot/send ./fmqroot/recv
</screen>

<para>And open two file navigator windows, one into <literal>src/fmqroot/send</literal> and one into <literal>src/fmqroot/recv</literal>. Drop files into the send folder and you'll see them arrive in the recv folder. The server checks once per second for new files. Delete files in the send folder, and they're deleted in the recv folder similarly.</para>

<para>I use track for things like updating my MP3 player mounted as a USB drive. As I add or remove files in my laptop's Music folder, the same changes happen on the MP3 player. FILEMQ isn't a full replication protocol it might become one.</para>

</sect2>
<sect2>
<title>Internal Architecture</title>
<para>To build FileMQ I used a lot of code generation, possibly too much. However the code generators are all reusable in other stacks. They are an evolution of the set we saw earlier:</para>

<itemizedlist>
  <listitem><para>codec_c.gsl - generates a message codec for a given protocol.</para></listitem>
  <listitem><para>server_c.gsl - generates a server class for a protocol and state machine.</para></listitem>
  <listitem><para>client_c.gsl - generates a client class for a protocol and state machine.</para></listitem>
</itemizedlist>
<para>The best way to learn to use GSL code generation is to translate these into a language of your choice and make your own demo protocols and stacks. You'll find it fairly easy. FileMQ itself doesn't try to support multiple languages. It could but it'd make things needlessly complex.</para>

<para>The FileMQ architecture actually slices into two layers. There's a generic set of classes to handle chunks, directories, files, patches, SASL security, and configuration files. Then, there's the generated stack: messages, client, and server. If I was creating a new project I'd fork the whole FileMQ project, and go and modify the three models:</para>

<itemizedlist>
  <listitem><para>fmq_msg.xml - which defines the message formats</para></listitem>
  <listitem><para>fmq_client.xml - which defines the client state machine, API, and implementation.</para></listitem>
  <listitem><para>fmq_server.xml - which does the same for the server.</para></listitem>
</itemizedlist>
<para>You'd want to rename things, to avoid confusion. Why didn't I make the reusable classes into a separate library? The answer is two-fold. First, no-one actually needs this (yet). Second, it'd make things more complex for you as you build and play with FileMQ. It's never worth adding complexity to solve a theoretical problem.</para>

<para>Although I wrote FileMQ in C, it's easy to map to other languages. It is quite amazing how nice C becomes when you add CZMQ's generic zlist and zhash containers, and class style. Let me go through the classes quickly:</para>

<itemizedlist>
  <listitem><para>fmq_sasl: encodes and decodes a SASL challenge. I only implemented the PLAIN mechanism, which is enough to prove the concept.</para></listitem>
  <listitem><para>fmq_chunk: works with variable sized blobs. Not as efficient as &Oslash;MQ's messages but they do less weirdness and so are easier to understand. The chunk class has methods to read and write chunks from disk.</para></listitem>
  <listitem><para>fmq_file: works with files, which may or may not exist on disk. Gives you information about a file (like size), lets you read and write to files, remove files, check if a file exists, and check if a file is "stable" (more on that later).</para></listitem>
  <listitem><para>fmq_dir: works with directories, reading them from disk and comparing two directories to see what changed. When there are changes, returns a list of "patches".</para></listitem>
  <listitem><para>fmq_patch: works with one patch, which really just says "create this file" or "delete this file" (referring to a fmq_file item each time).</para></listitem>
  <listitem><para>fmq_config: works with configuration data. I'll come back to client and server configuration later.</para></listitem>
</itemizedlist>
<para>Every class has a test method, and the main development cycle is "edit, test". These are mostly simple self tests but they make the difference between code I can trust. and code I know will still break. It's a safe bet that any code that isn't covered by a test case will have undiscovered errors. I'm not a fan of external test harnesses. But internal test code that you write as you write your functionality... that's like the handle on a knife.</para>

<para>You should, really, be able to read the source code and rapidly understand what these classes are doing. If you can't read the code happily, tell me. If you want to port the FileMQ implementation into other languages, start by forking the whole repository and later we'll see if it's possible to do this in one overall repo.</para>

</sect2>
<sect2>
<title>Public API</title>
<para>The public API consists of two classes (as we sketched earlier):</para>

<itemizedlist>
  <listitem><para>fmq_client: provides the client API, with methods to connect to a server, configure the client, and subscribe to paths.</para></listitem>
  <listitem><para>fmq_server: provides the server API, with methods to bind to a port, configure the server, and publish a path.</para></listitem>
</itemizedlist>
<para>If I was a keen young developer eager to use FileMQ in another language, I'd probably spend a happy weekend writing a binding for this public API, then stick it in a subdirectory of the filemq project called, say, "bindings/", and make a pull request.</para>

<para>The actual API methods come from the state machine description, like this (for the server):</para>

<screen>&lt;method name = "bind"&gt;
&lt;argument name = "endpoint" type = "string" /&gt;
zmq_bind (self-&gt;router, endpoint);
&lt;/method&gt;

&lt;method name = "publish"&gt;
&lt;argument name = "location" type = "string" /&gt;
&lt;argument name = "alias" type = "string" /&gt;
mount_t *mount = mount_new (location, alias);
zlist_append (self-&gt;mounts, mount);
&lt;/method&gt;

&lt;method name = "set anonymous"&gt;
&lt;argument name = "access" type = "number" /&gt;
//  Enable anonymous access without a config file
fmq_config_path_set (self-&gt;config, "security/anonymous", access? "1" :"0");
&lt;/method&gt;
</screen>

</sect2>
<sect2>
<title>Design Notes</title>
<para>The hardest part of making FileMQ wasn't the protocol part, but maintaining accurate state internally. An FTP or HTTP server is essentially stateless. But a publish/subscribe server <emphasis>has</emphasis> to maintain subscriptions, at least.</para>

<para>So I'll go through some of the design aspects:</para>

<itemizedlist>
  <listitem><para>The client detects if the server has died by the lack of heartbeats (HUGZ) coming from the server. It then restarts its dialog by sending an OHAI. There's no timeout on the OHAI since the &Oslash;MQ DEALER socket will queue an outgoing message indefinitely.</para></listitem>
  <listitem><para>The server detects if a client has died by its lack of response (HUGZ-OK) to a heartbeat. In that case it deletes all state for the client including its subscriptions.</para></listitem>
  <listitem><para>The client API holds subscriptions in memory and replays them when it has connected successfully. This means the called can subscribe at any time (and doesn't care when connections and authentication actually happen).</para></listitem>
  <listitem><para>The server and client use virtual paths, much like an HTTP or FTP server. You publish one or more "mount points" each corresponding to a directory on the server. Each of these maps to some virtual path, for instance "/" if you have only one mount point. Clients then subscribe to virtual paths, and files arrive in an inbox directory. We don't send physical file names across the network.</para></listitem>
  <listitem><para>There are some timing issues: if the server is creating its mount points, while clients are connected and subscribing, the subscriptions won't attach to the right mount points. So, we bind the server port as last thing.</para></listitem>
  <listitem><para>Clients can reconnect at any point; if the client sends OHAI, that signals the end of any previous conversation and the start of a new one. I might one day make subscriptions durable so that they survive a disconnection. The client stack, after reconnecting, replays any subscriptions the caller application already made.</para></listitem>
</itemizedlist>
</sect2>
<sect2>
<title>Reliabilty</title>
<para>As it stands, FileMQ implements the classic &Oslash;MQ publish-subscribe pattern. That is, clients receive a stream of updates but with no guarantees about overall consistency. To make FileMQ reliable we'd have to add some functionality:</para>

<itemizedlist>
  <listitem><para>A way for clients to request all patches since a certain time (possibly, all patches).</para></listitem>
  <listitem><para>A way for the server to store patches and subscriptions persistently.</para></listitem>
</itemizedlist>
</sect2>
<sect2>
<title>Configuration</title>
<para>I've written many servers, like the Xitami web server that was popular in the late 90's, and the OpenAMQ messaging server. Getting configuration easy and obvious was a large part of making these servers fun to use.</para>

<para>We typically aim to solve a number of problems:</para>

<itemizedlist>
  <listitem><para>Ship default configuration files with the product.</para></listitem>
  <listitem><para>Allow users to add custom configuration files that are never overwritten.</para></listitem>
  <listitem><para>Allow users to configure from the command-line.</para></listitem>
</itemizedlist>
<para>And then layer these one on the other, so command-line settings override custom settings, which override default settings. It can be a lot of work to do this right. For FileMQ I've taken a somewhat simpler tack: all configuration is done from the API.</para>

<para>So this is how we start and configure the server, for example:</para>

<programlisting language="c">
server = fmq_server_new ();
fmq_server_configure (server, "server_test.cfg");
fmq_server_publish (server, "./fmqroot/send", "/");
fmq_server_publish (server, "./fmqroot/logs", "/logs");
fmq_server_bind (server, "tcp://*:6000");
</programlisting>

<para>We do use a specific format for the config files, which is <ulink url="http://rfc.zeromq.org/spec:4">ZPL</ulink>, a minimalist syntax that we started using for &Oslash;MQ "devices" a few years ago, but which works well for any server:</para>

<screen>#   Configure server for plain access
#
server
    monitor = 1             #   Check mount points
    heartbeat = 1           #   Heartbeat to clients

publish
    location = ./fmqroot/logs
    virtual = /logs

security
    echo = I: use guest/guest to login to server
    #   These are SASL mechanisms we accept
    anonymous = 0
    plain = 1
        account
            login = guest
            password = guest
            group = guest
        account
            login = super
            password = secret
            group = admin
</screen>

<para>One cute thing (which seems useful) the generated server code does is to parse this config file (when you use the fmq_server_configure() method) and execute any section that matches an API method. Thus the 'publish' section works as a fmq_server_publish() method.</para>

</sect2>
</sect1>
<sect1>
<title>File Stability</title>
<para>It is quite common to poll a directory for changes and then do something 'interesting' with new files. But as one process is writing to a file, other processes have no idea when the file has been fully written. One solution is to add a second "indicator" file which we create after creating the first file. This is intrusive, however.</para>

<para>There is a neater way, which is to detect when a file is "stable", i.e. no-one is writing to it any longer. FileMQ does this by checking the modification time of the file. If it's more than a second old, then the file is considered stable, at least stable enough to be shipped off to clients. If a process comes along after five minutes and appends to the file, it'll be shipped off again.</para>

<para>For this to work, and this is a requirement for any application hoping to use FileMQ successfully, do not buffer more than a second's worth of data in memory before writing. If you use very large block sizes, the file may look stable when it's not.</para>

</sect1>
<sect1>
<title>Test Use Case</title>
<para>To properly test something like FileMQ we need a test case that plays with live data. One of my ongoing chores is to manage the MP3 tracks on my music player, which is a Sansa Clip reflashed with Rock Box (highly recommended). As I download tracks into my Music folder I want to copy these to my player, and as I find tracks that annoy me, I delete them in the Music folder and want those gone from my player too.</para>

<para>This is kind of over-kill for a powerful file distribution protocol. I could write this using a bash or Perl script but to be honest the hardest work in FileMQ was the directory comparison code, and I want to benefit from that. So I put together a simple tool called "track" which calls the FileMQ API. From the command line this runs with two arguments; the sending and the receiving directories:</para>

<screen>./track /home/ph/Music /media/3230-6364/MUSIC
</screen>

<para>The code is a neat example of how to use the FileMQ API to do local file distribution. Here is the full program, minus the license text (it's MIT/X11 licensed):</para>

<programlisting language="c">
#include "czmq.h"
#include "../include/fmq.h"

int main (int argc, char *argv [])
{
    if (argc &lt; 3) {
        puts ("usage: track original-directory tracking-directory");
        return 0;
    }
    fmq_server_t *server = fmq_server_new ();
    fmq_server_configure (server, "anonymous.cfg");
    fmq_server_publish (server, argv [1], "/");
    fmq_server_set_anonymous (server, true);
    fmq_server_bind (server, "tcp://*:6000");

    fmq_client_t *client = fmq_client_new ();
    fmq_client_connect   (client, "tcp://localhost:6000");
    fmq_client_set_inbox (client, argv [2]);
    fmq_client_subscribe (client, "/");

    while (!zctx_interrupted)
        sleep (1);
    puts ("interrupted");

    fmq_server_destroy (&amp;server);
    fmq_client_destroy (&amp;client);
    return 0;
}
</programlisting>

<para>Note how we work with physical paths in this tool. The server publishes the physical path "/home/ph/Music" and maps this to the virtual path "/". The client subscribes to "/" and receives all files in "/media/3230-6364/MUSIC". I could use any structure within the server directory, and it would be copied faithfully to the client's inbox.</para>

</sect1>
</chapter>
<chapter id="the-community">
<title>The &Oslash;MQ Community</title>
<para>People sometimes ask what's special about &Oslash;MQ. My standard answer is, it's true that &Oslash;MQ is arguably the best answer we have to the vexing question of "how do we make the distributed software that the 21st century demands?" but more than that, &Oslash;MQ is special because of its community. This is ultimately what separates the wolves from the sheep.</para>

<para>There are three main open source patterns. One, the large firm dumping code to break the market for others. This is the Apache Foundation model. Two, tiny teams or small firms building their dream. This is the most common open source model, and it can be very successful commercially. Three, aggressive and diverse communities that swarm over a problem landscape. This is the Linux model, and the one we aspire to with &Oslash;MQ.</para>

<para>It's hard to over-emphasize the power and persistence of a working open source community. There really does not seem to be a better way of making software for the long term. Not only does the community choose the best problems to solve, it solves them minimally, carefully, and it then looks after these answers for years, decades, until they're no longer relevant, and then it quietly puts them away.</para>

<para>To really benefit from &Oslash;MQ, you need to understand the community. At some stage you'll want to submit a patch, an issue, an add-on. You might want to ask someone for help. You will probably want to bet a part of your business on &Oslash;MQ, and when I tell you that the community is much, much more important than the company which backs the product, even though I'm CEO of that company, this should be significant.</para>

<para>In this chapter I'm going to look at our community from several angles, and conclude by explaining in detail our contract for collaboration, which <ulink url="http://rfc.zeromq.org/spec:16">we call "C4"</ulink>. You should find the discussion useful for your own work. We've also adapted the &Oslash;MQ C4 process for closed source projects, with good success.</para>

<para>We'll cover:</para>

<itemizedlist>
  <listitem><para>The rough structure of &Oslash;MQ as a set of projects.</para></listitem>
  <listitem><para>Why we use the LGPL and not the BSD license.</para></listitem>
  <listitem><para>How we designed and grew the &Oslash;MQ community.</para></listitem>
  <listitem><para>The business that backs &Oslash;MQ.</para></listitem>
  <listitem><para>Who owns the &Oslash;MQ source code.</para></listitem>
  <listitem><para>How to make and submit a patch to &Oslash;MQ.</para></listitem>
  <listitem><para>Who has special rights to make commits to &Oslash;MQ.</para></listitem>
  <listitem><para>How we guarantee compatibility with old code.</para></listitem>
  <listitem><para>Why we don't use public git branches.</para></listitem>
  <listitem><para>Who decides on the &Oslash;MQ road-map?</para></listitem>
  <listitem><para>A worked example of a change to libzmq.</para></listitem>
</itemizedlist>
<sect1>
<title>Architecture of the &Oslash;MQ Community</title>
<para>You know that &Oslash;MQ is an LGPL-licensed project. In fact it's a collection of projects, built around the core library, <literal>libzmq</literal>. I'll visualize these projects as an expanding galaxy:</para>

<itemizedlist>
  <listitem><para>At the core, libzmq is the &Oslash;MQ core library. It's written in C++, with a low-level C API. The code is nasty, mainly because it's highly optimized but also because it's written in C++, a language that lends itself to subtle and deep nastiness. Martin Sustrik wrote the bulk of this code originally, today it has dozens of people who maintain different parts of it. Sustrik, incidentally, has said he'd use C if he did this again, and has started a rewrite in C called "nano".</para></listitem>
  <listitem><para>Around libzmq there are about 50 "bindings". These are individual projects that create higher-level APIs for &Oslash;MQ, or at least map the low-level API into other languages. The bindings vary in quality from experimental to utterly awesome. By far the most awesome binding is <ulink url="https://github.com/zeromq/pyzmq">PyZMQ</ulink>, which was one of the first community projects on top of &Oslash;MQ. If you are a binding author, you should really study PyZMQ and aspire to making your code and community as awesome.</para></listitem>
  <listitem><para>A lot of languages have multiple bindings (Erlang, Ruby, C#, at least) written by different people over time, or taking different approaches. We don't regulate these in any way. There are no "official" bindings. You vote by using one or the other, contributing to it, or ignoring it.</para></listitem>
  <listitem><para>On top of the bindings are a lot of projects that use &Oslash;MQ or build on it. See the "Labs" page on the wiki for a long list of projects and proto-projects that use &Oslash;MQ in some way. There are frameworks, web servers like Mongrel2, brokers like Majordomo, and enterprise open source tools like Storm.</para></listitem>
</itemizedlist>
<para>Libzmq, most of the bindings, and some of the outer projects sit in the <ulink url="https://github.com/organizations/zeromq">&Oslash;MQ community "organization"</ulink> on GitHub. This organization is "run" by a group consisting of the most senior binding authors. There's very little to run since it's almost all self-managing and there's zero conflict these days.</para>

<para>iMatix, my firm, plays a specific role in the community. We own the trademarks and enforce them discretely, to make sure that if you download a package calling itself "ZeroMQ", you can trust what you are getting. People have on rare occasion tried to hijack the name, maybe believing that "free software" means there is no property at stake, or no-one willing to defend it. One thing you'll understand from this chapter is how seriously we take the process behind our software (and I mean "us" as a community, not a company). iMatix backs the community by enforcing that process on anything calling itself "ZeroMQ" or "&Oslash;MQ". We also put money and time into the software and packaging for reasons I'll explain later.</para>

<para>It is not a charity exercise. &Oslash;MQ is a for-profit project, and a very profitable one. The profits are just widely distributed among all those who invest in it. It's really that simple: take the time to become an expert in &Oslash;MQ, or build something useful on top of &Oslash;MQ, and you'll find your value as an individual, or team, or company increasing. iMatix enjoys the same benefits as everyone else in the community. It's win-win to everyone except our competitors, who find themselves facing a threat they can't beat and can't really escape. &Oslash;MQ dominates the future world of massively distributed software.</para>

<para>My firm doesn't just have the community's back, we also built the community. This was deliberate work; in the original &Oslash;MQ white paper from 2007 there were two projects. One was technical, how to make a better messaging system. The second was how to build a community that could take the software to through to dominant success. Software dies, but community survives.</para>

</sect1>
<sect1>
<title>How to Make Really Large Architectures</title>
<para>There are, it has been said (at least by people reading this sentence out loud), two ways to make really large-scale software. Option One is to throw massive amounts of money and problems at empires of smart people, and hope that what emerges is not yet another career killer. If you're very lucky, and are building on lots of experience, and have kept your teams solid, and are not aiming for technical brilliance, and are furthermore incredibly lucky, it works.</para>

<para>But gambling with hundreds of millions of others' money isn't for everyone. For the rest of us who want to build large-scale software, there's Option Two, which is open source, and more specifically, <emphasis>free software</emphasis>. If you're asking how the choice of software license is relevant to the scale of the software you build, that's the right question.</para>

<para>The brilliant and visionary Eben Moglen once said, roughly, that a free software license is the contract on which a community builds. When I heard this, about ten years ago, the idea came to me, <emphasis>can we deliberately grow free software communities</emphasis>?</para>

<para>Ten years later, the answer is "yes", and there is almost a science to it. I say "almost" because we don't yet have enough evidence of people doing this deliberately with a documented, reproducible process. It is what I'm trying to do with <ulink url="http://softwareandsilicon.com/chapter:2#toc5">Social Architecture</ulink>. &Oslash;MQ came after Wikidot, after Digistan and after the Foundation for a Free Information Infrastructure (aka the FFII, an NGO that fights against software patents). Which came after a lot of less successful community projects like Xitami and Libero. My main takeaway from a long career of projects of every conceivable format is: if you want to build truly large-scale and long-lasting software, aim to build a free software community.</para>

<sect2>
<title>The Game</title>
<para>Software is my business: I code to eat, and to feed my kids and to make sure my wife doesn't leave me for someone nicer and better looking. You see the challenge. Of course I <emphasis>love</emphasis> coding and that sensation of sculpting perfect functionality out of the raw mass of possibility. But the world doesn't care how passionately we feel. We wrest our living from a market that is largely uninterested, and often hostile when it does notice. This is the Game, and the detailed strategy of how to win it is for another book, though if you make it to the end of this chapter I'll toss in a few cheap gimmicks.</para>

<para>But roughly: you identify and destroy your competitors, you develop active strategies, you learn rapidly, move quickly, and in general appreciate the Game as a constant competition in which every participant is an ally, an enemy, or the ground over which you are fighting. Friend, foe, or food.</para>

</sect2>
<sect2>
<title>The Contract</title>
<para>Here is a true story, it happened to the eldest brother-in-law of the cousin of a friend of mine's colleague at work. His name was, and still is, Patrick.</para>

<para>Patrick was a computer scientist, with a PhD in advanced network topologies. He spent two years and his savings building a new product, and choose the BSD license because he believed that would get him more adoption. He worked in his attic, at great personal cost, and proudly published his work. People applauded, for it was truly fantastic, and his mailing lists were soon abuzz with activity and patches and happy chatter. Many companies told him how they were saving millions using his work. Some of them even paid him for consultancy and training. He was invited to speak at conferences and started collecting badges with his name on them. He started a small business, hired a friend to work with him, and dreamed of making it big.</para>

<para>Then one day, someone pointed him to a new project, GPL licensed, which had forked his work and was improving on it. He was irritated and upset, and asked how people -- fellow open sourcers, no less! -- would so shamelessly steal his code. There were long arguments on the list about whether it was even legal to relicense their BSD code as GPL code. Turned out, it was. He tried to ignore the new project but then he soon realized that new patches coming from that project <emphasis>couldn't even be merged back</emphasis> into his work!</para>

<para>Worse, the GPL project got popular and some of his core contributors made first small, and then larger patches to it. Again, he couldn't use those changes, and he felt abandoned. Patrick went into a depression, his girlfriend left him for an international currency dealer called, weirdly, Patrice, and he stopped all work on the project. He felt betrayed, and utterly miserable. He fired his friend, who took it rather badly and told everyone that Patrick was a closet banjo player. Finally Patrick took a job as a project manager for a cloud company, and by the age of forty, he had stopped programming even for fun.</para>

<para>Poor Patrick, I almost felt sorry for him. Then I asked him, "why didn't you choose the GPL?" "Because it's a restrictive viral license", he replied. I told him, you may have a PhD, and you may be the eldest brother-in-law of the cousin of a friend of my colleague, but you are an idiot and Monique was smart to leave you. You published your work saying, "please steal my code as long as you keep this 'please steal my code' statement in the resulting work", and when people did exactly that, you got upset. Worse, you were a hypocrite because when they did it in secret, you were happy, but when they did it openly, you felt betrayed.</para>

<para>Seeing your hard work captured by a smarter team and then used against you is enormously painful, so why even make that possible? Every proprietary project that uses BSD code is capturing it. A public GPL fork is perhaps more humiliating, but it's fully self-inflicted.</para>

<para>BSD is like food. It literally (and I mean that metaphorically) whispers "eat me" in the little voice one imagines a cube of cheese might use when it's sitting next to an empty bottle of Orval. The BSD license, like its near clone MIT/X11, was designed specifically by a university (Berkeley) with no profit motive, to leak work and effort. It is a way to push subsidized technology at below its cost price, a dumping of under-priced code in the hope that it will break the market for others. BSD is an <emphasis>excellent</emphasis> tool in the Game, but only if you're a large well-funded institution that can afford to use Option One. The Apache license is BSD in a suit.</para>

<para>For us small businesses who aim our investments like precious bullets, leaking work and effort is unacceptable. Breaking the market is great, but we cannot afford to subsidize our competitors. The BSD networking stack ended up putting Windows on the Internet. We cannot afford battles with those we should naturally be allies with. We cannot afford to make fundamental business errors because in the end, that means we have to fire people.</para>

<para>It comes down to behavioral economics and game theory. <emphasis>The license we choose modifies the economics of those who use our work</emphasis>. In the Game there are friends, foes, and food. BSD makes most people see us as lunch. Closed source makes most people see us as enemies (do you <emphasis>like</emphasis> paying people for software?) GPL, however, makes most people, with the exception of the Patricks of the world, our allies. Any fork of &Oslash;MQ is license compatible with &Oslash;MQ, to the point where we <emphasis>encourage</emphasis> forks as a valuable tool for experimentation. Yes, it can be weird to see someone try run off with the ball but, and here's the secret, <emphasis>I can get it back any time I want.</emphasis></para>

</sect2>
<sect2>
<title>The Process</title>
<para>If you've accepted my thesis up to now, great! Now, I'll explain the rough process by which we actually build an open source community. This was how we built or grew or gently steered the &Oslash;MQ community into existence.</para>

<para>You recall the simplicity-oriented design process from The Human Scale<xref linkend="the-human-scale"/>, where I claimed that we build successfully accurate software by successfully exploring the problem landscape, rather than by sheer intellectual effort. Keep this in mind. Now, see your community as a group exploring that landscape and sharing the results of their work.</para>

<para>Your goal as leader of a community is to motivate people to get out there and explore; to ensure they can do so safely and without disturbing others; to reward them when they make successful discoveries; and to ensure they share their knowledge with everyone else (and not because we ask them, not because they feel generous, but because it's The Law).</para>

<para>It is an iterative process. You make a small product, at your own cost, but in public view. You then build a small community around that product. If you have a small but real hit, the community then helps design and build the next version, and grows larger. And then that community builds the next version, and so on. It's evident that you remain part of the community, maybe even a majority contributor, but the more control you try to assert over the material results, the less people will want to participate. Plan your own retirement well before someone decides you are their next problem.</para>

</sect2>
<sect2>
<title>Crazy, Beautiful, and Easy</title>
<para>You need a goal that's crazy and simple enough to get people out of bed in the morning. Your community has to attract the very best people and that demands something special. With &Oslash;MQ, we said we were going to make "the Fastest. Messaging. Ever.", which qualifies as a good motivator. If we'd said, we're going to make "a smart transport layer that'll connect your moving pieces cheaply and flexibly across your enterprise", we'd have failed.</para>

<para>Then your work must be beautiful, immediately useful and attractive. Your contributors are users who want to explore just a little beyond where they are now. Make it simple, elegant, brutally clean. The experience when people run or use your work should be an emotional one. They should <emphasis>feel</emphasis> something, and if you accurately solved even just one big problem that until then they didn't quite realize they faced, you'll have a small part of their soul.</para>

<para>And then, easy to understand, use, and join. Too many projects have barriers to access: put yourself in the other person's mind and see all the reasons they come to your site, thinking "Uhm, interesting project, but..." and then leave. You want them to stay, try it, just once. Use GitHub and put the issue tracker right there.</para>

<para>If you do these things well, your community will be smart but more importantly, will be intellectually and geographically diverse. This is really important. A group of like-minded experts cannot explore the problem landscape well. They tend to make big mistakes. Diversity beats education any time.</para>

</sect2>
<sect2>
<title>Stranger, meet Stranger</title>
<para>How much up-front agreement do two people need to work together on something? In most organizations, a lot. But you can bring this cost down to near-zero, and then people can collaborate without having ever met, done a phone conference, meeting, or business trip to discuss Roles and Responsibilities over way too many bottles of soju.</para>

<para>You need well-written rules that are designed by cynical people like me to force strangers into mutually beneficial collaboration instead of conflict. The GPL is a good start. GitHub and its fork/merge strategy is a good follow-up. And then you want something like our <ulink url="http://rfc.zeromq.org/spec:16">C4 rulebook</ulink> to control how work actually happens.</para>

<para>C4 (which I now use for every new open source project) has detailed and tested answers to a lot of common mistakes people make. For example, the sin of working off-line in a corner with others "because it's faster". Transparency is essential to get trust, which is essential to get scale. By forcing every single change through a single transparent process, you build real trust in the results.</para>

<para>Another cardinal sin that many open source developers make is to place themselves above others. "I founded this project thus my intellect is superior to that of others". It's not just immodest and rude, and usually inaccurate, it's also poor business. The rules must apply equally to everyone, without distinction. You are part of the community. Your job, as founder of a project, is not to impose your vision of the product over others, but to make sure the rules are good, honest, and <emphasis>enforced</emphasis>.</para>

</sect2>
<sect2>
<title>Infinite Property</title>
<para>One of the saddest myths of the knowledge business is that ideas are a sensible form of property. It's medieval nonsense that should have been junked along with slavery, but sadly it's still making too many powerful people too much money.</para>

<para>Ideas are cheap. What does work sensibly as property is the hard work we do in building a market. "You eat what you kill" is the right model for encouraging people to work hard. Whether it's moral authority over a project, money from consulting, or the sale of a trademark to some large, rich firm: if you make it, you own it. But what you really own is "footfall", participants in your project, which ultimately defines your power in the Game.</para>

<para>To do this requires infinite free space. Thankfully, GitHub solved this problem for us, for which I will die a grateful person (there are many reasons to be grateful in life, which I won't list here because we only have a hundred or so pages left, but this is one of them).</para>

<para>You cannot scale a single project with many owners like you can scale a collection of many small projects, each with fewer owners. When we embrace forks, a person can become an "owner" with a single click. Now they just have to convince others to join, by demonstrating their unique value.</para>

<para>So in &Oslash;MQ we aimed to make it easy to write bindings on top of the core library, and we stopped trying to make those bindings ourselves. This created space for others to make those, become their owners, get that credit.</para>

</sect2>
<sect2>
<title>Care and Feeding</title>
<para>I wish a community could be 100% self-steering, and perhaps one day this will work, but today it's not the case. We're very close with &Oslash;MQ, but from my experience a community needs four types of care and feeding:</para>

<itemizedlist>
  <listitem><para>First, simply because most people are too nice, we need some kind of symbolic leadership or owners who provide ultimate authority in case of conflict. Usually it's the founders of the community. I've seen it work with self-elected groups of "elders", but old men like to talk a lot. I've seen communities split over the question "who is in charge?", and setting up legal entities, with boards, and such, seems to make such arguments worse, not better. Maybe because there seems to be more to fight over. One of the real benefits of free software is that it's always remixable, so instead of fighting over a pie, one simply forks the pie.</para></listitem>
  <listitem><para>Second, communities need living rules, and thus they need a lawyer able to formulate and write these down. Rules are critical; when done right, they remove friction. When done wrong, or neglected, we see real friction and argument that can drive away the nice majority, leaving the argumentative core in charge of the burning house. One thing I've tried to do with the &Oslash;MQ and previous communities is create reusable rules, which perhaps means we don't need lawyers as much.</para></listitem>
  <listitem><para>Thirdly, communities need some kind of financial backing. This is the jagged rock that breaks most ships. If you starve a community, it becomes more creative but the core contributors burn out. If you pour too much money into it, you attract the professionals, who never say "no", and the community loses its diversity and creativity. If you create a fund for people to share, they will fight (bitterly) over it. With &Oslash;MQ we (iMatix) spend our time and money on marketing and packaging (like this book), and basic care - bug fixes, releases, website.</para></listitem>
  <listitem><para>Lastly, sales and commercial mediation. There is a natural market between expert contributors and customers, but both are somewhat incompetent at talking to each other. Customers assume that support is free or very cheap, since the software is free. Contributors are shy at asking a fair rate for their work. It makes for a difficult market. A growing part of my work and my firm's profits is simply connecting &Oslash;MQ users who want help, with experts from the community able to provide it, and ensuring both sides are happy with the results.</para></listitem>
</itemizedlist>
<para>I've seen communities of brilliant people with noble goals dying because the founders got some or all of these four things wrong. The core problem is that you can't expect consistently great leadership from any one company, person, or group. What works today often won't work tomorrow, yet structures become more solid, not more flexible, over time.</para>

<para>The best answer I can find is a mix of two things. One, the GPL and its guarantee of remixability. No matter how bad the authority, no matter how much they try to privatize and capture the community's work, if it's GPL licensed, that work can walk away and find a better authority. Before you say, "all open source offers this," think it through. I can kill a BSD-licensed project by hiring the core contributors, and not releasing any new patches. But even with a billion of dollars I <emphasis>cannot</emphasis> kill a GPL-licensed project. Two, the philosophical anarchist model of authority: we choose it, it does not own us.</para>

</sect2>
</sect1>
<sect1>
<title>The &Oslash;MQ Process - C4</title>
<para>When we say &Oslash;MQ we sometimes mean libzmq, the core library. In early 2012 we synthesized the libzmq process into a formal protocol for collaboration that we called the <ulink url="http://rfc.zeromq.org/spec:16">Collective Code Construction Contract</ulink>, or C4. You can see this as a layer above the GPL. In fact libzmq doesn't quite stick to C4, since for historic reasons we use Jira instead of the GitHub issue tracker. But apart from that, these are our rules, and I'll explain the reasoning behind each one.</para>

<para>C4 is an evolution of the GitHub <ulink url="http://help.github.com/send-pull-requests/">Fork + Pull Model</ulink>. You may get the feeling I'm a fan of git and GitHub. This would be accurate: these two tools have made such a positive impact on our work over the last years, and especially when it comes to building community.</para>

<sect2>
<title>Language</title>
<blockquote>
  <para>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.</para>
</blockquote>
<para>By starting with the RFC 2119 language, the C4 text makes very clear its intention to act as a protocol rather than a randomly written set of recommendations. A protocol is a contract between parties, that defines the rights and obligations of each party. These can be peers in a network. They can be strangers working in the same project.</para>

<para>I think C4 is the first time anyone has attempted to codify a community's rulebook as a formal and reusable protocol spec. Before, our rules were spread out over several wiki pages, and quite specific to libzmq in many ways. But experience teaches us that the more formal and accurate and reusable the rules, the easier it is for strangers to collaborate up-front. And less friction means a more scalable community. At the time of C4, we also had some disagreement in the libzmq over precisely what process we were using. Not everyone felt bound by the same rules. Let's just say some people felt they had a special status, which created friction with the rest of the community. So codification made things clear.</para>

<para>It's easy to use C4: just host your project on GitHub, get one other person to join, and open the floor to pull requests. In your README, put a link to C4 and that's it. We've done this in quite a few projects and it does seem to work. I've been pleasantly surprised a few times just applying these rules to my own work, like CZMQ. We are none of us, as I'll explain later in this chapter, so amazing that we can work without others.</para>

</sect2>
<sect2>
<title>Goals</title>
<blockquote>
  <para>C4 is meant to provide a reusable optimal collaboration model for open source software projects.</para>
</blockquote>
<para>The short term reason for writing C4 was to end argument over the libzmq contribution process. The dissenters went off elsewhere. <ulink url="https://github.com/zeromq/libzmq/graphs/contributors">The &Oslash;MQ community blossomed</ulink>, smoothly and easily, as I'd predicted. Most people were surprised, but gratified. There's been no real criticisms of C4 except its branching policy, which I'll come to later since it deserves its own discussion.</para>

<para>There's a reason I'm bringing up history here: as founder of a community, you are asking people to invest in your property, trademark, branding. In return, and this is what we do with &Oslash;MQ, you can use that branding to set a bar for quality. When you download a product labeled as "&Oslash;MQ", you know that it's been produced to certain standards. It's a basic rule of quality: write down your process, otherwise you cannot improve it. Our processes aren't perfect, they can't ever be. But any flaw in them can be fixed, and tested.</para>

<para>Making C4 reusable is therefore really important. To learn more about the best possible process we need to get results from the widest range of projects.</para>

<blockquote>
  <para>It has these specific goals:</para>
  <para>To maximize the scale of the community around a project, by reducing the friction for new Contributors and creating a scaled participation model with strong positive feedbacks;</para>
</blockquote>
<para>The number one goal is size and health of the community. Not technical quality, not profits, not performance, not market share. Simply, number of people who contribute to the project. The science here is simple: the larger the community, the more accurate the results.</para>

<blockquote>
  <para>To relieve dependencies on key individuals by separating different skill sets so that there is a larger pool of competence in any required domain;</para>
</blockquote>
<para>Perhaps the worst problem we faced in libzmq was dependence on people who could at the same time understand the code, manage GitHub branches, and make clean releases. It's like looking for athletes who can run both marathons and sprint, swim, and also lift weights. We humans are really good at specialization. Asking us to be really good at two contradictory things just reduces the number of candidates sharply, which is a Bad Thing for any project. We had this problem severely in libzmq in 2009 or so, and fixed it by splitting the role of maintainer into two: one person makes patches, another person makes releases.</para>

<blockquote>
  <para>To allow the project to develop faster and more accurately, by increasing the diversity of the decision making process;</para>
</blockquote>
<para>This is theory, not fully proven but not falsified. The diversity of the community and number of people who can weigh into discussions, without fear of being criticized or dismissed, the faster and more accurately the software should develop, Speed is quite subjective here. Going very fast in the wrong direction is not just useless, it's actively damaging (and we suffered a lot of that in libzmq before we switched to C4).</para>

<blockquote>
  <para>To support the natural life-cycle of project versions from experimental through to stable, by allowing safe experimentation, rapid failure, and isolation of stable code;</para>
</blockquote>
<para>To be honest, this goal seems to be fading into irrelevance. It's quite an interesting effect of the process: <emphasis>the git master is almost always perfectly stable</emphasis>. This has to do with the size of changes, and their "latency", i.e. the time between someone writing the code, and someone actually using it fully. However, people still expect "stable" releases, so we'll keep this goal there for a while.</para>

<blockquote>
  <para>To reduce the internal complexity of project repositories, thus making it easier for Contributors to participate and reducing the scope for error;</para>
</blockquote>
<para>Curious observation: people who thrive in complex situations like to create complexity because it keeps their value high. It's the Cobra Effect (Google it). Git made branches easy and left us with the all too common syndrome of "git is easy once you understand that a git branch is just a folded five-dimensional lepton space that has a detached history with no intervening cache". Developers should not be made to feel stupid by their tools. I've too many top-class developers confused by repository structures, to accept conventional wisdom on git branches. We'll come back to dispose of git branches shortly, dear reader.</para>

<blockquote>
  <para>To enforce collective ownership of the project, which increases economic incentive to Contributors and reduces the risk of hijack by hostile entities.</para>
</blockquote>
<para>Ultimately, we're economic creatures, and the sense that "we own this, and our work can never be used against us" makes it much easier for people to invest in an open source project like &Oslash;MQ. And it can't be just a feeling, it has to be real. There are a number of aspects to making collective ownership work, we'll see these one by one as we go through C4.</para>

</sect2>
<sect2>
<title>Preliminaries</title>
<blockquote>
  <para>The project SHALL use the git distributed revision control system.</para>
</blockquote>
<para>Git has its faults. Its command-line API is horribly inconsistent, and it has a complex, messy internal model that it shoves in your face at the slightest provocation. But despite doing its best to make its users feel stupid, git does its job really, really well. More pragmatically, I've found that if you stay away certain areas (branches!), people learn git rapidly and don't make many mistakes. That data works for me.</para>

<blockquote>
  <para>The project SHALL be hosted on github.com or equivalent, herein called the "Platform".</para>
</blockquote>
<para>I'm sure one day some large firm will buy github and break it, and another platform will rise in its place. Github serves up a near-perfect set of minimal, fast, simple tools. I've thrown hundreds of people at it, and they all stick, like flies stuck in a dish of honey.</para>

<blockquote>
  <para>The project SHALL use the Platform issue tracker.</para>
</blockquote>
<para>We made the mistake in libzmq of switching to Jira (mainly because a now departed person didn't like GitHub). Jira is a great example of how to turn something useful into a complex mess because the business depends on selling more "features". But even without criticizing Jira, keeping the issue tracker on the same platform means one less UI to learn, one less login, and integration between issues and patches.</para>

<blockquote>
  <para>The project SHOULD have clearly documented guidelines for code style.</para>
</blockquote>
<para>This is a protocol plug-in: insert code style guidelines here. If you don't document the code style you use, you have no basis except prejudice to reject patches.</para>

<blockquote>
  <para>A "Contributor" is a person who wishes to provide a patch, being a set of commits that solve some clearly identified problem.</para>
  <para>A "Maintainer" is a person who merge patches to the project. Maintainers are not developers; their job is to enforce process.</para>
</blockquote>
<para>Now to definitions of the parties, and the splitting of roles that saved us from the sin of structural dependency on rare individuals. This worked well in libzmq, but as you will see it depends on the rest of the process. C4 isn't a buffet; you will need the whole process (or something very like it), or it won't hold together.</para>

<blockquote>
  <para>Contributors SHALL NOT have commit access to the repository unless they are also Maintainers.</para>
  <para>Maintainers SHALL have commit access to the repository.</para>
</blockquote>
<para>What we wanted to avoid was people pushing their changes directly to master. This was the biggest source of trouble in libzmq historically: large masses of raw code that took months or years to fully stabilize. We eventually followed other &Oslash;MQ projects like PyZMQ in using pull requests. We went further, and stipulated that <emphasis>all</emphasis> changes had to follow the same path. No exceptions for "special people".</para>

<blockquote>
  <para>Everyone, without distinction or discrimination, SHALL have an equal right to become a Contributor under the terms of this contract.</para>
</blockquote>
<para>We had to state this explicitly. It used to be that the libzmq "maintainers" would reject patches simply because they didn't like them. Now, that may sound reasonable to the author of a library (though libzmq was not written by any one person) but let's remember our goal of creating a work that is owned by as many people as possible. Saying "I don't like your patch so I'm going to reject it" is equivalent to saying, "I claim to own this and I think I'm better than you, and I don't trust you". Those are toxic messages to give to others who are thinking of becoming your co-investors.</para>

<para>I think this fight between individual expertise and collective intelligence plays out in other areas. It defined Wikipedia, and still does, a decade after that work surpassed anything built by small groups of experts. For me, we make software by synthesizing knowledge, much as we make Wikipedia articles.</para>

</sect2>
<sect2>
<title>Licensing and Ownership</title>
<blockquote>
  <para>The project SHALL use the GPLv3 or a variant thereof (LGPL, AGPL).</para>
</blockquote>
<para>I've already explained how full remixability creates better scale and why the GPL and its variants seems the optimal contract for remixable software. If you're a large business aiming to dump code on the market, you won't want C4, but then you won't really care about community either.</para>

<blockquote>
  <para>All contributions to the project source code ("patches") SHALL use the same license as the project.</para>
</blockquote>
<para>This removes the need for any specific license or contribution agreement for patches. You fork the GPL code, you publish your remixed version on github, you or anyone else can then submit that as a patch to the original code. BSD doesn't allow this. Any work that contains BSD code may also contain unlicensed proprietary code so you need explicit action from the author of the code before you can remix it.</para>

<blockquote>
  <para>All patches are owned by their authors. There SHALL NOT be any copyright assignment process.</para>
</blockquote>
<para>Here we come to the key reason people trust their investments in &Oslash;MQ: it's logistically impossible to buy the copyrights to create a closed-source competitor to &Oslash;MQ. iMatix can't do this either. And the more people send patches, the harder it becomes. &Oslash;MQ isn't just free and open today, this specific rule means it will remain so forever. Note that it's not the case in all GPL projects, many of which still ask for copyright transfer back to the maintainers.</para>

<blockquote>
  <para>The project SHALL be owned collectively by all its Contributors.</para>
</blockquote>
<para>This is perhaps redundant but worth saying: if everyone owns their patches, then the resulting whole is also owned by every contributor. There's no legal concept of owning lines of code: the "work" is at least a source file.</para>

<blockquote>
  <para>Each Contributor SHALL be responsible for identifying themselves in the project Contributor list.</para>
</blockquote>
<para>I.e. the maintainers are not karma accountants. Anyone who wants credit has to claim it themselves.</para>

</sect2>
<sect2>
<title>Patch Requirements</title>
<para>In this section we define the obligations of the contributor: specifically, what constitutes a "valid" patch, so maintainers have rules they can use to accept or reject patches.</para>

<blockquote>
  <para>Maintainers and Contributors MUST have a Platform account and SHOULD use their real names or a well-known alias.</para>
</blockquote>
<para>In the worst case scenario, where someone has submitted toxic code (patented, or owned by someone else), we need to be able to trace who and when, so we can remove the code. Asking for real names or a well-known alias is a theoretical strategy to reducing the risk of bogus patches. We don't know if this actually works because we haven't had the problem yet.</para>

<blockquote>
  <para>A patch SHOULD be a minimal and accurate answer to exactly one identified and agreed problem.</para>
</blockquote>
<para>Recall the Simplicity Oriented Design pattern from The Human Scale<xref linkend="the-human-scale"/>. This implements that. One clear problem, one minimal solution, apply, test, repeat.</para>

<blockquote>
  <para>A patch MUST adhere to the code style guidelines of the project if these are defined.</para>
</blockquote>
<para>This is just sanity: I've spent time cleaning up other peoples' patches because they insisted on putting the 'else' beside the 'if' instead of just below as Nature intended. Consistent code is healthier.</para>

<blockquote>
  <para>A patch MUST adhere to the "Evolution of Public Contracts" guidelines defined below.</para>
</blockquote>
<para>Ah, the pain, the pain. I'm not speaking of the time at age eight when I stepped on a plank with a 4-inch nail protruding from it. That was relatively OK. I'm speaking of 2010-2011 when we had multiple parallel releases of &Oslash;MQ, each with different <emphasis>incompatible</emphasis> APIs or wire protocols. It was an exercise in bad rules pointlessly enforced. The rule was "if you change the API or protocol, you SHALL create a new major version". Give me the nail through the foot, that hurt less.</para>

<para>One of the big changes we made with C4 was simply to ban, outright, this kind of sanctioned sabotage. Amazingly, it's not even hard. We just don't allow the breaking of existing public contracts, period, unless everyone agrees, in which case no period.</para>

<blockquote>
  <para>A patch SHALL NOT include non-trivial code from other projects unless the Contributor is the original author of that code.</para>
</blockquote>
<para>This rule has two effects. The first is that it forces people to make minimal solutions, since they cannot simply import swathes of existing code. In the cases where I've seen this happen to projects, it's always bad unless the imported code is very cleanly separated. The second is that it avoids license arguments. You write the patch, you are allowed to publish it as LGPL, and we can merge it back in. But you find a 200-line code fragment on the web, and try to paste that, we'll refuse.</para>

<blockquote>
  <para>A patch MUST compile cleanly on at least the most important target platforms.</para>
</blockquote>
<para>This is probably asking a lot since most contributors have only one platform to work on.</para>

<blockquote>
  <para>A "Correct Patch" is one that satisfies the above requirements.</para>
</blockquote>
<para>Just in case it wasn't clear, we're back to legalese and definitions.</para>

</sect2>
<sect2>
<title>Development Process</title>
<para>In this section we aim to describe the actual development process, step by step.</para>

<blockquote>
  <para>Change on the project SHALL be governed by the pattern of accurately identifying problems and applying minimal, accurate solutions to these problems.</para>
</blockquote>
<para>This is a blatant attempt to ram through thirty years' software design experience. It's a profoundly simple approach to design: make minimal, accurate solutions to real problems. Nothing more or less. Note the stress on "accuracy", a rare but essential ingredient. In &Oslash;MQ we don't have feature requests. Treating new features the same as bugs confuses newbies. But this process works, and not just in open source. Enunciating the problem we're trying to solve, with every single change, is key to deciding whether the change is worth making or not.</para>

<blockquote>
  <para>To initiate changes, a user SHALL log an issue on the project Platform issue tracker.</para>
</blockquote>
<para>This is meant to stop us going off-line and working in a ghetto, either by ourselves or with others. Although we tend to accept pull requests that have clear argumentation, this rule lets us say "stop" to confused or too-large patches.</para>

<blockquote>
  <para>The user SHOULD write the issue by describing the problem they face or observe.</para>
</blockquote>
<para>"Problem: we need feature X. Solution: make it" is not a good issue. "Problem: user cannot do common tasks A or B except by using a complex workaround. Solution: make feature X" is a decent explanation. Since everyone I've ever worked with has needed to learn this, it seems worth re-stating: document the real problem first, solution second.</para>

<blockquote>
  <para>The user SHOULD seek consensus on the accuracy of their observation, and the value of solving the problem.</para>
</blockquote>
<para>And since many apparent problems are illusionary, by stating the problem explicitly we give others a chance to correct our logic. "You're only using A and B a lot because function C is unreliable. Solution: make function C work properly."</para>

<blockquote>
  <para>Users SHALL NOT log feature requests, ideas, suggestions, or any solutions to problems that are not explicitly documented and provable.</para>
</blockquote>
<para>There are several reasons for not logging ideas, suggestions, or feature requests. In our experience these just accumulate in the issue tracker until someone deletes them. But more profoundly, when we treat all change as problem solutions, we can prioritize trivially. Either the problem is real and someone wants to solve it, now, or it's not on the table. Thus, wish-lists are off the table.</para>

<blockquote>
  <para>Thus, the release history of the project SHALL be a list of meaningful issues logged and solved.</para>
</blockquote>
<para>I'd love the GitHub issue tracker to simply list all the issues we solved in each release. Today we still have to write that by hand. If one puts the issue number in each commit, and if one uses the GitHub issue tracker, which we sadly don't yet do for &Oslash;MQ, this release history is easier to produce mechanically.</para>

<blockquote>
  <para>To work on an issue, a Contributor SHALL fork the project repository and then work on their forked repository.</para>
</blockquote>
<para>Here we explain the GitHub fork + pull request model so that newcomers only have to learn one process (C4) in order to contribute.</para>

<blockquote>
  <para>To submit a patch, a Contributor SHALL create a Platform pull request back to the project.</para>
</blockquote>
<para>GitHub has made this so simple that we don't need to learn git commands to do it, for which I'm deeply grateful. Sometimes, I'll tell people who I don't particularly like that command-line git is awesome and all they need to do is learn git's internal model in detail before trying to use it on real work. When I see them several months later they look... different.</para>

<blockquote>
  <para>A Contributor SHALL NOT commit changes directly to the project.</para>
</blockquote>
<para>Anyone who submits a patch is a contributor, and all contributors follow the same rules. No special privileges to the original authors, because otherwise we're not building a community, but boosting our egos.</para>

<blockquote>
  <para>To discuss a patch, people MAY comment on the Platform pull request, on the commit, or elsewhere.</para>
</blockquote>
<para>Randomly distributed discussions may be confusing if you're walking up for the first time, but GitHub solves this for all current participants by sending emails to those who need to follow what's going on. We had the same experience and the same solution in Wikidot, and it works. There's no evidence that discussing in different places has any negative effect.</para>

<blockquote>
  <para>To accept or reject a patch, a Maintainer SHALL use the Platform interface.</para>
</blockquote>
<para>Working via the GitHub web user interface means pull requests are logged as issues, with workflow and discussion. I'm sure there are more complex ways to work. Complexity is easy, it's simplicity that's incredibly hard.</para>

<blockquote>
  <para>Maintainers SHALL NOT accept their own patches.</para>
</blockquote>
<para>There was a rule we defined in the FFII years ago to stop people burning out: no less than two people on any project. One-person projects tend to end in tears, or at least bitter silence. We have quite a lot of data on burnout, why it happens, and how to prevent it (even cure it). I'll explore this later in the chapter, since if you work with or on open source you need to be aware of the risks. The "no merging your own patch" rule has two goals. First, if you want your project to be C4-certified, you have to get at least one other person to help. If no-one wants to help you, perhaps you need to rethink your project. Second, having a control for every patch makes it much more satisfying, keeps us more focused, and stops us breaking the rules because we're in a hurry, or just feeling lazy.</para>

<blockquote>
  <para>Maintainers SHALL NOT make value judgments on correct patches.</para>
</blockquote>
<para>We already said this but it's worth repeating: the role of Maintainer is not to judge a patch's substance, only its technical quality. The substantive worth of a patch only emerges over time: people use it, and like it, or they do not. And if no-one is using a patch, eventually it'll annoy someone else who will remove it, and no-one will complain.</para>

<blockquote>
  <para>Maintainers SHALL merge correct patches rapidly.</para>
</blockquote>
<para>There is a criteria I call "change latency" which is the round-trip time from identifying a problem to testing a solution. The faster the better. If maintainers cannot respond to pull requests as rapidly as people expect, they're not doing their job (or they need more hands).</para>

<blockquote>
  <para>The Contributor MAY tag an issue as "Ready" after making a pull request for the issue.</para>
</blockquote>
<para>GitHub by default offers the usual variety of issues but with C4 we don't use them. Instead we need just two labels, "Urgent" and "Ready". A contributor who wants another user to test an issue can then label it as "Ready".</para>

<blockquote>
  <para>The user who created an issue SHOULD close the issue after checking the patch is successful.</para>
</blockquote>
<para>When one person opens an issue, and another works on it, it's best to allow the original person close the issue. That acts as a double-check that the issue was properly resolved.</para>

<blockquote>
  <para>Maintainers SHOULD ask for improvements to incorrect patches and SHOULD reject incorrect patches if the Contributor does not respond constructively.</para>
</blockquote>
<para>Initially I felt it was worth merging all patches no matter how poor. There's an element of trolling involved. Merging broken code to master might, I felt, pull in more contributors. But people were uncomfortable with this so we defined the "correct patch" rules, and the Maintainer's role in checking for quality. On the negative side I think we didn't take some interesting risks which could have paid off with more participants. On the positive side this has led to &Oslash;MQ master (and in all projects that use C4) being practically production quality, practically all the time.</para>

<blockquote>
  <para>Any Contributor who has value judgments on a correct patch SHOULD express these via their own patches.</para>
</blockquote>
<para>In essence, the goal here is to allow users to try patches rather than to spend time arguing pros and cons. As easy as it is to make a patch, it's as easy to revert it with another patch. You might think this would lead to "patch wars" but that hasn't happened. We've had a handful of cases in libzmq where patches by one contributor were killed by another person who felt the experimentation wasn't going in the right direction. It is easier than seeking up-front consensus.</para>

<blockquote>
  <para>Maintainers MAY commit changes to non-source documentation directly to the project.</para>
</blockquote>
<para>This exit allows maintainers who are making release notes to push those without having to create an issue which would then affect the release notes, leading to stress on the space time fabric and possibly involuntary rerouting backwards in the fourth dimension to before the invention of cold beer. Shudder. Simpler to agree that release notes aren't changes to the software.</para>

</sect2>
<sect2>
<title>Creating Stable Releases</title>
<para>For a production system we want some guarantee of stability. In the past this meant taking unstable code and then over months hammering out the bugs and faults until it was safe to trust. iMatix's job, for years, has been to do this to libzmq, turning raw code into packages by allowing only bug fixes, and no new code, into a "stabilization branch". It's surprisingly not as thankless as it sounds.</para>

<para>Now, since we went full speed with C4, we've found that git master of libzmq is mostly perfect, most of the time. This frees our time to do more interesting things, such as building new open source layers on top of libzmq. However, people still want that guarantee: many users will simply not install except from an "official" release. So a stable release today means two things. First, a snapshot of the master taken at a time when there were no new changes for a while, and no dramatic open bugs. Second, a way to fine-tune that snapshot to fix the critical issues remaining in it.</para>

<para>This is the process we explain in this section.</para>

<blockquote>
  <para>The project SHALL have one branch ("master") that always holds the latest in-progress version and SHOULD always build.</para>
</blockquote>
<para>This is redundant since every patch always builds but it's worth restating. If the master doesn't build (and pass its tests), someone needs waking up.</para>

<blockquote>
  <para>The project SHALL NOT use topic branches for any reason. Personal forks MAY use topic branches.</para>
</blockquote>
<para>I'll come to branches soon. In short (or "tl;dr", as they say on the webs) branches make the repository too complex and fragile, and require upfront agreement, all of which are expensive and avoidable.</para>

<blockquote>
  <para>To make a stable release someone SHALL fork the repository by copying it and thus become maintainer of this repository.</para>
  <para>Forking a project for stabilization MAY be done unilaterally and without agreement of project maintainers.</para>
</blockquote>
<para>It's free software. No-one has a monopoly on it. If you think the maintainers aren't producing stable releases right, fork the repository and do it yourself. Forking isn't a failure, it's an essential tool for competition. You can't BTW do this with branches, which means a branch-based release policy gives the project maintainers a monopoly. And that's bad because they'll become lazier and more arrogant than if real competition is chasing their heels.</para>

<blockquote>
  <para>Maintainers of the stabilization project SHALL maintain it through pull requests which MAY cherry-pick patches from the forked project.</para>
</blockquote>
<para>Perhaps the C4 process should just say that stabilization projects have maintainers and contributors like any project. That's all this rule means.</para>

<blockquote>
  <para>A patch to a repository declared "stable" SHALL be accompanied by a reproducible test case.</para>
</blockquote>
<para>Beware of a one-size fits all process. New code does not need the same paranoia as code which people are trusting for production use. In the normal development process we did not mention test cases. There's a reason for this. While I love testable patches, many changes aren't easily or at all testable. However to stabilize a code base you want to fix only serious bugs, and you want to be 100% sure every change is accurate. This means before/after tests for every change.</para>

<blockquote>
  <para>A stabilization repository SHOULD progress through these phases: "unstable", "candidate", "stable", and then "legacy". That is, the default behavior of stabilization repositories is to die.</para>
</blockquote>
<para>This may be over-detailed. The key point here is that these forked stabilization repositories all die in the end, as master continues to evolve and continues to be forked off for production releases.</para>

</sect2>
<sect2>
<title>Evolution of Public Contracts</title>
<para>By "public contracts" I mean APIs and protocols. Up until the end of 2011, libzmq's naturally happy state was marred by broken promises and broken contracts. We stopped making promises (aka "roadmaps") for libzmq completely, and our dominant theory of change is now that it emerges carefully and accurately over time. At a 2012 Chicago meetup, Garrett Smith and Chuck Remes called this the "drunken stumble to greatness", which is how I think of it now.</para>

<para>We stopped breaking public contracts simply by banning the practice. Before then it had been "OK" (as in we did it, and everyone complained bitterly, and we ignored them) to break the API or protocol so long as we changed the major version number. Sounds fine, until you get &Oslash;MQ version 2.0, 3.0, and 4.0, all in development at the same time, and not speaking to each other.</para>

<blockquote>
  <para>All Public Contracts (APIs or protocols) SHOULD be documented.</para>
</blockquote>
<para>You'd think this was a given for professional software engineers but no, it's not. So, it's a rule. You want C4 certification for your project, you make sure your public contracts are documented. No "it's specified in the code" excuses. Code is not a contract. (Yes, I intend at some point to create a C4 certification process to act as a quality indicator for open source projects.)</para>

<blockquote>
  <para>All Public Contracts SHALL use Semantic Versioning.</para>
</blockquote>
<para>This rule is mainly here because people asked for it. I've no real love for it, since Semantic Versioning is what led to the so-called "why does &Oslash;MQ not speak to itself?!" debacle. I've never seen the problem that this solved. Something about runtime validation of library versions, or some-such.</para>

<blockquote>
  <para>All Public Contracts SHOULD have space for extensibility and experimentation.</para>
</blockquote>
<para>Now, the real thing is that public contracts <emphasis>do change</emphasis>. It's not about not changing them. It's about changing them safely. This means educating (especially protocol) designers to create that space up front.</para>

<blockquote>
  <para>A patch that modifies a Public Contract SHOULD not break existing applications unless there is prior consensus on the value of doing this.</para>
</blockquote>
<para>Sometimes the patch is fixing a bad API that no-one is using. It's a freedom we need but it should be based on consensus, not one person's dogma. However, making random changes just 'because' is not good. In &Oslash;MQ/3.x, did we benefit from renaming <literal>ZMQ_NOBLOCK</literal> to <literal>ZMQ_DONTWAIT</literal>? Sure, it's closer to the POSIX socket <literal>recv()</literal> call, but is that worth breaking thousands of applications? No-one ever reported it as an issue. To misquote Stallman: <emphasis>your freedom to create an ideal world stops one inch from my application.</emphasis></para>

<blockquote>
  <para>A patch that introduces new features to a Public Contract SHOULD do so using new names.</para>
</blockquote>
<para>We had the experience in &Oslash;MQ once or twice of new features using old names (or worse, using names that were <emphasis>still in use</emphasis> elsewhere). &Oslash;MQ/3.0 had a newly introduced "ROUTER" socket that was totally different from the existing ROUTER socket in 2.x. Dear lord, you should be face-palming, why? The reason: apparently, even smart people sometimes need regulation to stop them doing silly things.</para>

<blockquote>
  <para>Old names SHOULD be deprecated in a systematic fashion by marking new names as "experimental" until they are stable, then marking the old names as "deprecated".</para>
</blockquote>
<para>This life-cycle notation has the great benefit of actually telling users what is going on, with a consistent direction. "Experimental" means "we have introduced this and intend to make it stable if it works". Not, "we have introduced this and will remove it at any time if we feel like it". One assumes that code which survives more than one patch cycle is meant to be there. "Deprecated" means "we have replaced this and intend to remove it".</para>

<blockquote>
  <para>When sufficient time has passed, old deprecated names SHOULD be marked "legacy" and eventually removed.</para>
</blockquote>
<para>Which in theory gives applications time to move onto stable new contracts but without risk. You can upgrade first, make sure things work, and then, over time, fix things up to remove dependencies on deprecated and legacy APIs and protocols.</para>

<blockquote>
  <para>Old names SHALL NOT be reused by new features.</para>
</blockquote>
<para>Ah, yes, the joy when &Oslash;MQ/3.x renamed the top-used API functions (<literal>zmq_send()</literal> and <literal>zmq_recv()</literal>) and then recycled the old names for new methods that were utterly incompatible (and which I suspect few people actually use). You should be slapping yourself in confusion again, but really, this is what happened and I was as guilty as anyone. After all, we did change the version number! Semantic Version FTW!! The only benefit of that experience was to get this rule.</para>

<blockquote>
  <para>When old names are removed, their implementations MUST provoke an exception (assertion) if used by applications.</para>
</blockquote>
<para>I've not tested this rule to be certain it makes sense. Perhaps what it means is "if you can't provoke a compile error because the API is dynamic, provoke an assertion".</para>

<para>C4 is not perfect, few things are. The process for changing it (Digistan's COSS) is a little outdated now: it relies on a single-editor workflow with the ability to fork, but not merge. This seems to work but it could be better to use C4 for protocols like C4.</para>

</sect2>
</sect1>
<sect1>
<title>Worked Example</title>
<para>In <ulink url="http://lists.zeromq.org/pipermail/zeromq-dev/2012-October/018838.html">this email thread</ulink>, Dan Goes asks how to make a publisher that knows when a new client subscribes, and sends out previous matching messages. It's a standard pub-sub technique called "last value caching". Now over a 1-way transport like pgm (where subscribers literally send no packets back to publishers) this can't be done. But over TCP, it can, if we use an XPUB socket and if that socket didn't cleverly filter out duplicate subscriptions to reduce upstream traffic.</para>

<para>Though I'm not an expert contributor to libzmq, this seems a fun problem to solve. How hard could it be? I start by forking the libzmq repository to my own GitHub account, and then clone it to my laptop, where I build it:</para>

<screen>git clone git@github.com:hintjens/libzmq.git
cd libzmq
./autogen.sh
./configure
make
</screen>

<para>Since the libzmq code is neat and well-organized it was quite easy to find the main files to change (xpub.cpp and xpub.hpp). Each socket type has its own source file and class. They inherit from socket_base.cpp, which has this hook for socket-specific options:</para>

<screen>//  First, check whether specific socket type overloads the option.
int rc = xsetsockopt (option_, optval_, optvallen_);
if (rc == 0 || errno != EINVAL)
    return rc;

//  If the socket type doesn't support the option, pass it to
//  the generic option parser.
return options.setsockopt (option_, optval_, optvallen_);
</screen>

<para>Then I check where the XPUB socket filters out duplicate subscriptions, in its xread_activated method:</para>

<screen>bool unique;
if (*data == 0)
    unique = subscriptions.rm (data + 1, size - 1, pipe_);
else
    unique = subscriptions.add (data + 1, size - 1, pipe_);

//  If the subscription is not a duplicate store it so that it can be
//  passed to used on next recv call.
if (unique &amp;&amp; options.type != ZMQ_PUB)
    pending.push_back (blob_t (data, size));
</screen>

<para>At this stage I'm not too concerned with the details of how subscriptions.rm and .add work. The code seems obvious except that "subscription" also includes unsubscription, which confused me for a few seconds. If there's anything else weird in the rm and add methods, that's a separate issue to fix later. Time to make an issue for this change. I head over to the zeromq.jira.com site, log in, and create a new entry.</para>

<para>Jira kindly offers me the traditional choice between "bug" and "new feature" and I spend thirty seconds wondering where this counter-productive historical distinction came from. Presumably, the "we'll fix bugs for free but you pay for new features" commercial proposal, which stems from the "you tell us what you want and we'll make it for $X" model of software development, and which generally leads to "we spent three times $X and we got what?!" email Fists of Fury.</para>

<para>Putting such thoughts aside, I create <ulink url="https://zeromq.jira.com/browse/LIBZMQ-443">an issue #443</ulink> and described the problem and plausible solution:</para>

<blockquote>
  <para>Problem: XPUB socket filters out duplicate subscriptions (deliberate design). However this makes it impossible to do subscription-based intelligence. See http://lists.zeromq.org/pipermail/zeromq-dev/2012-October/018838.html for a use-case.</para>
  <para>Solution: make this behaviour configurable with a socket option.</para>
</blockquote>
<para>Naming time. The API sits in include/zmq.h, so this is where I added the option name. When you invent a concept, in an API or anywhere, <emphasis>please</emphasis> take a moment to choose a name that is explicit and short and obvious. Don't fall back on generic names which need additional context to understand. You have one chance to tell the reader what your concept is, and does. A name like <literal>ZMQ_SUBSCRIPTION_FORWARDING_FLAG</literal> is terrible. It technically kind of aims in the right direction but is miserably long and obscure. I chose <literal>ZMQ_XPUB_VERBOSE</literal>: short and explicit and clearly an on/off switch with "off" being the default setting.</para>

<para>So, time to add a private property to the xpub class definition in xpub.hpp:</para>

<screen>// If true, send all subscription messages upstream, not just
// unique ones
bool verbose;
</screen>

<para>And then lift some code from router.cpp to implement the xsetsockopt method. Finally, change the xread_activated method to use this new option, and while at it, make that test on socket type more explicit too:</para>

<screen>//  If the subscription is not a duplicate store it so that it can be
//  passed to used on next recv call.
if (options.type == ZMQ_XPUB &amp;&amp; (unique || verbose))
    pending.push_back (blob_t (data, size));
</screen>

<para>The thing builds nicely first time. Which makes me a little suspicious, but being lazy and jet-lagged I don't immediately make a test case to actually try out the change. The process doesn't demand that, even if usually I'd do it just to catch that inevitable 10% of mistakes we all make. I do however document this new option on the <literal>doc/zmq_setsockopt.txt</literal> man page. In the worst case I added a patch that wasn't really useful. But I certainly didn't break anything.</para>

<para>I don't implement a matching <literal>zmq_getsockopt</literal>, since "minimal" means what it says. There's no obvious use case for getting the value of an option that you presumably just set, in code. Symmetry isn't a valid reason to double the size of a patch. I did have to document the new option since the process says, "All Public Contracts SHOULD be documented."</para>

<para>Committing the code, I push the patch to my forked repository (the 'origin'):</para>

<screen>git commit -a -m "Fixed issue #443"
git push origin master
</screen>

<para>Switching to the GitHub web interface, I go to my libzmq fork, and press the big "Pull Request" button at the top. GitHub asks me for a title, so I enter "Added ZMQ_XPUB_VERBOSE option". I'm not sure why it asks this since I made a neat commit message but hey, let's go with the flow here.</para>

<para>This makes a nice little pull request with two commits. The one I'd made a month ago on the release notes, to prepare for the 3.2.1 release (a month passes so quickly when you spend most of it in airports), and my fix for issue #443 (37 new lines of code). GitHub lets you continue to make commits after you've kicked off a pull request. They get queued up, and merged in one go. That is easy but the maintainer may refuse the whole bundle based on one patch that doesn't look valid.</para>

<para>Since Dan is waiting (at least in my highly optimistic imagination) for this fix, I go back to the zeromq-dev list and tell him I've made the patch, with a link to the commit. The faster I get feedback, the better. It's 1am in South Korea as I make this patch, so early evening in Europe, and morning in the States. You learn to count timezones when you work with people across the world. Ian is in a conference, Mikko is getting on a plane, and Chuck is probably in the office, but three hours later, Ian merges the pull request.</para>

<para>After Ian merges the pull request, I re-synchronize my fork with the upstream libzmq repository. First, I add a 'remote' that tells git where this repository sits (I do this just once in the directory where I'm working):</para>

<screen>git remote add upstream git://github.com/zeromq/libzmq.git
</screen>

<para>And then I pull changes back from the upstream master and check the git log to double-check:</para>

<screen>git pull --rebase upstream master
git log
</screen>

<para>And that is pretty much it, in terms of how much git one needs to learn and use to contribute patches to libzmq. Six git commands and some clicking on web pages. Most importantly to me as a naturally lazy, stupid, and easily confused developer, I don't have to learn git's internal models, and never have to do anything involving those infernal engines of structural complexity we call "git branches". Next up, the attempted assassination of git branches. Let's live dangerously!</para>

</sect1>
<sect1>
<title>Git Branches Considered Harmful</title>
<para>One of git's most popular features is how easy it makes branches. Almost all projects that use git use branches, and the selection of the "best" branching strategy is like a rite of passage for an open source project. Vincent Driessen's <ulink url="http://nvie.com/posts/a-successful-git-branching-model/">git-flow</ulink> is maybe the best known. It has 'base' branches (master, develop), 'feature' branches, 'release' branches, 'hotfix' branches, and 'support' branches. Many teams have adopted git-flow, which even has git extensions to support it. I'm a great believer in popular wisdom, but sometimes you have to recognize mass delusion for what it is.</para>

<para>Here is a section of C4 that might have shocked you when you first read it:</para>

<blockquote>
  <para>The project SHALL NOT use topic branches for any reason. Personal forks MAY use topic branches.</para>
</blockquote>
<para>To be clear, it's <emphasis>public branches in shared repositories</emphasis> that I'm talking about. Using branches for private work, e.g. to work on different issues, appears to work well enough, though it's more complexity than I personally enjoy. To channel Stallman again: <emphasis>your freedom to create complexity ends one inch from our shared workspace.</emphasis></para>

<para>Like the rest of C4, the rules on branches are not accidental. They came from our experience making &Oslash;MQ, starting when Martin Sustrik and I rethought how to make stable releases. We both love and appreciate simplicity (some people seem to have a remarkable tolerance for complexity). We chatted for a while... I asked him, "I'm going to start making a stable release, would it be OK for me to make a branch in the git you're working in?" Martin didn't like the idea. "OK, if I fork the repository, I can move patches from your repo to that one". That felt much better to both of us.</para>

<para>The response from many in the &Oslash;MQ community was shock and horror. People felt we were being lazy and making contributors work harder to find the "right" repository. Still, this seemed simple, and indeed it worked smoothly. The best part was that we each worked as we wanted to. Whereas before, the &Oslash;MQ repository had felt horribly complex (and it wasn't even anything like git-flow), this felt simple. And it worked. The only downside was that we lost a single unified history. Now, perhaps historians will feel robbed, but I honestly can't see that the historical minutiae of who changed what, when, including every branch and experiment, are worth any significant pain or friction.</para>

<para>People have gotten used to the "multiple repositories" approach in ZeroMQ and we've started using that in other projects quite successfully. My own opinion is that history will judge git branches and patterns like git-flow as a complex solution to imaginary problems inherited from the days of Subversion and monolithic repositories.</para>

<para>More profoundly, and perhaps this is why the majority seems to be "wrong": I think the the branches vs. forks argument is really a deeper design vs. evolve argument about how to make software optimally. I'll address that deeper argument in the next section. For now, I'll try to be scientific about my irrational hate of branches, by looking at a number of criteria, and compare branches and forks in each one.</para>

<sect2>
<title>Simplicity vs. Complexity</title>
<para><emphasis>The simpler, the better.</emphasis></para>

<para>There is no inherent reason branches are more complex than forks. However, git-flow uses <emphasis>five types</emphasis> of branch, whereas C4 uses two types of fork (development, and stable) and one branch (master). Circumstantial evidence is thus that branches lead to more complexity than forks. For new users, it is definitely, and we've measured this in practice, easier to learn to work with many repositories and no branches except master.</para>

</sect2>
<sect2>
<title>Change Latency</title>
<para><emphasis>The smaller and more rapid the delivery, the better.</emphasis></para>

<para>Development branches seem to correlate strongly with large, slow, risky deliveries. "Sorry, I have to merge this branch before we can test the new version" signals a breakdown in process. It's certainly not how C4 works, which is by focusing tightly on individual problems and their minimal solutions. Allowing branches in development raises change latency. Forks have a different outcome: it's up to the forker to ensure his changes merge cleanly, and to keep them simple so they won't be rejected.</para>

</sect2>
<sect2>
<title>Learning Curve</title>
<para><emphasis>The smoother the learning curve, the better.</emphasis></para>

<para>Evidence definitely shows that learning to use git branches is complex. For some people this is OK. For most developers, every cycle spent learning git is a cycle lost on more productive things. I've been told several times, by different people, that I do not like branches because I "never properly learned git". That is fair but it is a criticism of the tool, not the human.</para>

</sect2>
<sect2>
<title>Cost of Failure</title>
<para><emphasis>The lower the cost of failure, the better.</emphasis></para>

<para>Branches demand more perfection from developers since mistakes potentially affect others. This raises the cost of failure. Forks make failure extremely cheap since literally nothing that happens in a fork can affect others not using that fork.</para>

</sect2>
<sect2>
<title>Upfront Coordination</title>
<para><emphasis>The less need for upfront coordination, the better.</emphasis></para>

<para>You can do a hostile fork. You cannot do a hostile branch. Branches depend on upfront coordination, which is expensive and fragile. One person can veto the desires of a whole group. In the &Oslash;MQ community for example we were unable to agree on a git branching model for a year. We solved that by using forking instead. The problem went away.</para>

</sect2>
<sect2>
<title>Scalability</title>
<para><emphasis>The more you can scale a project, the better.</emphasis></para>

<para>The strong assumption in all branch strategies is that the repository <emphasis>is</emphasis> the project. But there is a limit to how many people you can get in agreement to work together in one repository. As I explained, the cost of upfront coordination can become fatal. A more realistic project scales by allowing anyone to start their own repositories, and ensuring these can work together. A project like &Oslash;MQ has dozens of repositories. Forking looks more scalable than branching.</para>

</sect2>
<sect2>
<title>Surprise and Expectations</title>
<para><emphasis>The less surprising, the better.</emphasis></para>

<para>People expect branches and find forks to be uncommon and thus confusing. This is the one aspect where branches win. If you use branches, a single patch will have the same commit hash tag, whereas across forks the patch will have different hash tags. That makes it harder to track patches as they cross forks, true. But seriously, <emphasis>having to track hexadecimal hash tags is not a feature</emphasis>. It's a bug. Sometimes better ways of working just are surprising at first.</para>

</sect2>
<sect2>
<title>Economics of Participation</title>
<para><emphasis>The more tangible the rewards, the better.</emphasis></para>

<para>People like to own their work, and get credit for it. This is much easier with forks than with branches. Forks create more competition, in a healthy way, while branches suppress competition and force people to collaborate and share credit. This sounds positive but in my experience it de-motivates people. A branch isn't a product you can "own", whereas a fork can be.</para>

</sect2>
<sect2>
<title>Robustness in Conflict</title>
<para><emphasis>The more a model can survive conflict, the better.</emphasis></para>

<para>Like it or not, people fight over ego, status, beliefs, and theories of the world. Challenge is a necessary part of science. If your organizational model depends on agreement, you won't survive the first real fight. Branches do not survive real arguments and fights. Whereas forks can be hostile, and still benefit all parties. And this is indeed how free software works.</para>

</sect2>
<sect2>
<title>Guarantees of Isolation</title>
<para><emphasis>The stronger the isolation between production code and experiment, the better.</emphasis></para>

<para>People make mistakes. I've seen experimental code pushed to mainline production by error. I've seen people make bad panic changes under stress. But the real fault is in allowing two entirely separate generations of product to exist in the same protected space. If you can push to random-branch-x you can push to master. Branches do not guarantee isolation of production critical code. Forks do.</para>

</sect2>
<sect2>
<title>Visibility</title>
<para><emphasis>The more visible our work, the better.</emphasis></para>

<para>Forks have watchers, issues, a README, a wiki. Branches have none of these. People try forks, build them, break them, patch them. Branches sit there until someone remembers to work on them. Forks have downloads and tarballs. Branches do not. When we look for self-organization, the more visible and declarative the problems, the faster and more accurately we can work.</para>

</sect2>
<sect2>
<title>Conclusions</title>
<para>In this section I've listed a series of arguments, most of which came from fellow team members. Here's how it seems to break down: git veterans insist that branches are the way to work, whereas newcomers tend to feel intimidated when asked to navigate git branches. Git is not an easy tool to master. What we've discovered, accidentally, is that when you stop using branches <emphasis>at all</emphasis>, git becomes trivial to use. It literally comes down to six commands (clone, remote, commit, log, push, and pull). Furthermore, a branch-free process actually works, we've used it for a couple of years now, and no visible downside except surprise to the veterans, and growth of "single" projects over multiple repositories.</para>

<para>If you can't use forks, perhaps because your firm doesn't trust github's private repositories, then you perhaps topic branches (one per issue) will work. You'll still suffer the costs of getting upfront consensus, low competitiveness, and risk of human error.</para>

</sect2>
</sect1>
<sect1>
<title>The Myth of Intelligent Design</title>
<para>The dominant theory of design is that you take smart, creative people and money, and produce amazing products. The smarter the people, the better the results. I'm going to claim that theory is bogus, a myth based on magical thinking that treats the "invention" as a product of individual "inventor" minds. As an alternative I'll present the Theory of Heuristic Innovation, which states roughly that we do not invent solutions, we discover them, and that discovery process can be highly automated.</para>

<para>Presenting &Oslash;MQ at the Mix-IT conference in Lyon in early 2012, I was asked several times for the "road-map". My answer was, There is no road-map, and road-maps are bad for several reasons. First, they make promises we can rarely keep, which causes problems for our users. Second, they claim territory and make it harder for others to participate. Lastly, they preempt the thinking process of the community. The audience didn't really like my answer. So un-French. Software engineers don't like the notion that powerful, effective solutions can come into existence without an intelligent designer actively thinking things through. And yet no-one in that room would question evolution. A strange irony, and one I wanted to explore further as it underpins the direction the &Oslash;MQ community has taken over the last year or so.</para>

<para>In the dominant theory, brilliant individuals reflect on large problem sets and then carefully and precisely create a solution. Sometimes they will have "eureka" moments where they "get" brilliantly simple answers to whole large problem sets. The inventor, and the process of invention are rare, precious, and can command a monopoly. History is full of such heroic individuals. We owe them our modern world.</para>

<para>Looking closer, however, the facts don't match. History doesn't show lone inventors. It shows lucky people who steal or claim ownership of ideas that are being worked on by many. It shows brilliant people striking lucky once, and then spending decades on fruitless and pointless quests. The best known large-scale inventors like Thomas Edison were in fact just very good at systematic broad research done by large teams. It's like claiming that Steve Jobs invented every device made by Apple. It is a nice myth, good for marketing, but utterly useless as practical science.</para>

<para>Recent history, much better documented and less easy to manipulate, shows this well. The Internet is surely one of the most innovative and fast-moving areas of technology, and one of the best documented. It has no inventor. Instead it has a massive economy of people who have carefully and progressively solved a long series of immediate problems, documented their answers, and made those available to all. The innovative nature of the Internet comes not from a small, select band of Einsteins. It comes from RFCs anyone can use and improve, made by hundreds and thousands of smart, but not uniquely smart, individuals. It comes from open source software anyone can use and improve. It comes from sharing, scale of community, and the continuous accretion of good solutions and disposal of bad ones.</para>

<para>Here thus is my "Theory of Heuristic Innovation":</para>

<orderedlist>
  <listitem><para>There is an infinite problem/solution terrain.</para></listitem>
  <listitem><para>This terrain changes over time according to external conditions.</para></listitem>
  <listitem><para>We can only accurately perceive problems we are close to.</para></listitem>
  <listitem><para>We can rank the cost/benefit economics of problems using a market for solutions.</para></listitem>
  <listitem><para>There is an optimal solution to any solvable problem.</para></listitem>
  <listitem><para>We can approach this optimal solution heuristically, and mechanically.</para></listitem>
  <listitem><para>Our intelligence can make this process faster but does not replace it.</para></listitem>
</orderedlist>
<para>It's an approximation. Feel free to send me patches. There are a few takeaways from this:</para>

<itemizedlist>
  <listitem><para><emphasis>Individual creativity matters less than process.</emphasis> Smarter people may work faster but they may work in the wrong direction. It's the collective vision of reality that keeps us honest and relevant.</para></listitem>
  <listitem><para><emphasis>We don't need road-maps if we have a good process.</emphasis> Functionality will emerge and evolve over time as solutions compete for market share.</para></listitem>
  <listitem><para><emphasis>We don't invent solutions, so much as discover them.</emphasis> All sympathies to the creative soul. It's just an information processing machine that likes to polish its own ego and collect karma.</para></listitem>
  <listitem><para><emphasis>Intelligence is a social effect, though it feels personal.</emphasis> A person cut-off from others eventually stops thinking. We can neither collect problems nor measure solutions without other people.</para></listitem>
  <listitem><para><emphasis>The size and diversity of the community is a key factor.</emphasis> Larger, more diverse communities collect more relevant problems, and solve them more accurately, and do this faster, than a small expert group.</para></listitem>
</itemizedlist>
<para>People have pointed out that hill-climbing algorithms (what this is, essentially) have known limitations. One gets stuck on local peaks, mainly. But this is nonetheless how life itself works: collecting tiny incremental improvements over long periods of time. There is no intelligent designer. We reduce the risk of local peaks by spreading out widely across the landscape but it is somewhat moot. The limitations aren't optional, they are physical laws. The theory says, <emphasis>this is how innovation really works, so better embrace it and work with it, than try to work on the basis of belief</emphasis>.</para>

<para>And in fact once you see all innovation as more or less successful hill-climbing, you realize why some teams and companies and products get stuck in a never-never land of diminishing prospects. They simply don't have the diversity and collective intelligence to find better hills to climb. When Nokia killed their open source projects, they cut their own throat.</para>

</sect1>
<sect1>
<title>Burnout</title>
<para>The &Oslash;MQ community has been and still is heavily dependent on pro-bono individual efforts. I'd like to think that everyone was compensated in some way for their contributions, and I believe that with &Oslash;MQ, contributing means gaining expertise in an extraordinarily valuable technology, which means improved professional options.</para>

<para>However not all projects will be so lucky and if you work with or in open source you should understand the risk of burnout that volunteers face. This applies to all pro-bono communities. In this section I'll explain what causes burnout, how to recognize it, how to prevent it, and (if it happens) how to try to treat it. Disclaimer: I'm not a psychiatrist and this article is based on my own experiences of working in pro-bono contexts for the last 20 years, including free software projects, and NGOs such as the <ulink url="http://www.ffii.org">FFII</ulink>.</para>

<para>In a pro-bono context we're expected to work without direct or obvious economic incentive. That is, we sacrifice family life, professional advancement, free time, and health in order to accomplish some goal we have decided to accomplish. In any project, we need some kind of reward to make it worth continuing each day. In most pro-bono projects the rewards are very indirect, superficially not economical at all. Mostly, we do things because people say, "hey, great!" Karma is a powerful motivator.</para>

<para>However, we are economic beings, and sooner or later, if a project costs us a great deal and does not bring economic rewards of some kind (money, fame, a new job,...) we start to suffer. At a certain stage it seems our subconscious simply gets disgusted, and says, "enough is enough!" and refuses to go any further. If we try to force ourselves, we can literally get sick.</para>

<para>This is what I call "burnout", though the term is also used for other kinds of exhaustion. Too much investment on a project, with too little economic reward, for too long. We are great at manipulating ourselves, and others, and this is often part of the process that leads to burnout. We tell ourselves that it's for a good cause, that the other guy is doing OK, so we should be able to as well.</para>

<para>When I got burnt out on open source projects like Xitami, I remember clearly how I felt. I simply stopped working on it, refused to answer any more emails, and told people to forget about it. You can tell when someone's burnt out. They go off-line, and everyone starts saying, "he's acting strange... depressed, or tired..."</para>

<para>Diagnosis is simple. Has someone worked a lot on a project that was not paying back in any way? Did she make exceptional sacrifices? Did he lose or abandon his job or studies to do the project? If you're answering "yes", it's burnout.</para>

<para>There are three simple techniques I've developed over the years to reduce the risk of burnout in the teams I work with:</para>

<itemizedlist>
  <listitem><para><emphasis>No-one is irreplaceable.</emphasis> Working solo on a critical or popular project -- the concentration of responsibility on one person who cannot set their own limits -- is probably the main factor. It's a management truism: if someone in your organization is irreplaceable, get rid of him or her.</para></listitem>
  <listitem><para><emphasis>We need day jobs to pay the bills.</emphasis> This can be hard but seems necessary. Getting money from somewhere else makes it much easier to sustain a sacrificial project.</para></listitem>
  <listitem><para><emphasis>Teach people about burnout.</emphasis> This should IMO be a basic course in colleges and universities, as pro-bono work becomes a more common way for young people to experiment professionally.</para></listitem>
</itemizedlist>
<para>When someone is working alone on a critical project, you <emphasis>know</emphasis> they are going blow their fuses sooner or later. It's actually fairly predictable: something like 18-36 months depending on the individual and how much economic stress they face in their private lives. I've not seen anyone burn-out after half a year, nor last five years in a unrewarding project.</para>

<para>There is a simple cure for burnout which works in at least some cases: get paid decently for your work. However this pretty much destroys the freedom of movement (across that infinite problem landscape) that the volunteer enjoys.</para>

</sect1>
<sect1>
<title>Patterns for The Game</title>
<para>I'll end this code-free chapter with a series of patterns for success in software engineering. They aim to capture the essence of what divides glorious success from tragic failure. They were described as "religious maniacal dogma" by a manager, and "anything else would be effing insane" by a colleague, in a single day. For me, they are science. But treat the Lazy Perfectionist and others as tools to use, sharpen, and throw away if something better comes along.</para>

<sect2>
<title>The Lazy Perfectionist</title>
<para><emphasis>Never design anything that's not a precise minimal answer to a problem we can identify and have to solve.</emphasis></para>

<para>The Lazy Perfectionist spends his idle time observing others and identifying problems that are worth solving. He looks for agreement on those problems, always asking, "what is the <emphasis>real</emphasis> problem". Then he moves, precisely and minimally, to build, or get others to build, a usable answer to one problem. He uses, or gets others to use those solutions. And he repeats this until there are no problems left to solve, or time or money runs out.</para>

</sect2>
<sect2>
<title>The Benevolent Tyrant</title>
<para><emphasis>The control of a large force is the same principle as the control of a few men: it is merely a question of dividing up their numbers.</emphasis> -- Sun Tzu</para>

<para>The Benevolent Tyrant divides large problems into smaller ones and throws them at groups to focus on. He brokers contracts between these groups, in the form of APIs and unprotocols. The Benevolent Tyrant constructs a supply chain that starts with problems, and results in usable solutions. He is ruthless about how the supply chain works, but does not tell people on what to work, nor how to do their work.</para>

</sect2>
<sect2>
<title>The Earth and Sky</title>
<para><emphasis>The ideal team consists of two sides: one writing code, and one providing feedback.</emphasis></para>

<para>The Earth and Sky work together as a whole, in close proximity, but they communicate formally through an issue tracking. Sky seeks out problems, from others and from their own use of the product, and feeds these to Earth. Earth rapidly answers with testable solutions. Earth and Sky can work through dozens of issues in a day. Sky talks to other users, and Earth talks to other developers. Earth and Sky may be two people, or two small groups.</para>

</sect2>
<sect2>
<title>The Open Door</title>
<para><emphasis>The accuracy of knowledge comes from diversity.</emphasis></para>

<para>The Open Door accepts contributions from almost anyone. He does not argue quality or direction, instead allowing others to argue that and so get more engaged. He calculates that even a troll will bring more diverse opinion to the group. He lets the group form its opinion about what goes into stable code, and he enforces this opinion with help of a Benevolent Tyrant.</para>

</sect2>
<sect2>
<title>The Laughing Clown</title>
<para><emphasis>Perfection precludes participation.</emphasis></para>

<para>The Laughing Clown, often acting as the Happy Failure, makes no claim to high competence. Instead his antics and bumbling attempts provoke others into rescuing him from his own tragedy. Somehow however, he always identifies the right problems to solve. People are so busy proving him wrong they don't realize they're doing valuable work.</para>

</sect2>
<sect2>
<title>The Mindful General</title>
<para><emphasis>Make no plans. Set goals, develop strategies and tactics.</emphasis></para>

<para>The Mindful General operates in unknown territory, solving problems that are hidden until they are nearby. Thus he makes no plans, but seeks opportunities, then exploits them rapidly and accurately. He develops tactics and strategies in the field, and teaches these to his men so they can move independently, and together.</para>

</sect2>
<sect2>
<title>The Social Engineer</title>
<para><emphasis>If you know the enemy and know yourself, you need not fear the result of a hundred battles.</emphasis> -- Sun Tzu</para>

<para>The Social Engineer reads the hearts and minds of those he works with and for. He asks, of everyone, "what makes this person angry, insecure, argumentative, calm, happy?" He studies their moods and dispositions. With this knowledge he can encourage those who are useful, and discourage those who are not. The Social Engineer never acts on his own emotions.</para>

</sect2>
<sect2>
<title>The Constant Gardener</title>
<para><emphasis>He will win whose army is animated by the same spirit throughout all its ranks.</emphasis> -- Sun Tzu</para>

<para>The Constant Gardener grows a process from a small seed, step by step as more people come into the project. He makes every change for a precise reason, with agreement from everyone. He never imposes a process from above but lets others come to consensus, then he enforces that consensus. In this way everyone owns the process together and by owning it, they are attached to it.</para>

</sect2>
<sect2>
<title>The Rolling Stone</title>
<para><emphasis>After crossing a river, you should get far away from it.</emphasis> -- Sun Tzu</para>

<para>The Rolling Stone accepts his own mortality and transience. He has no attachment to his past work. He accepts that all that we make is destined for the trash can, it is just a matter of time. With precise, minimal investments, he can move rapidly away from the past and stay focused on the present and near future. Above all he has no ego and no pride to be hurt by the actions of others.</para>

</sect2>
<sect2>
<title>The Pirate Gang</title>
<para><emphasis>Code, like all knowledge, works best as collective -- not private -- property.</emphasis></para>

<para>The Pirate Gang organizes freely around problems. It accepts authority insofar as authority provides goals and resources. The Pirate Gang owns and shares all it makes: every work is fully remixable by others in the Pirate Gang. The gang moves rapidly as new problems emerge, and is quick to abandon old solutions if those stop being relevant. No persons or groups can monopolize any part of the supply chain.</para>

</sect2>
<sect2>
<title>The Flash Mob</title>
<para><emphasis>Water shapes its course according to the nature of the ground over which it flows.</emphasis> -- Sun Tzu</para>

<para>The Flash Mob comes together in space and time as needed, then disperses as soon as they can. Physical closeness is essential for high-bandwidth communications. But over time it creates technical ghettos, where Earth gets separated from Sky. The Flash Mob tends to collect a lot of frequent flier miles.</para>

</sect2>
<sect2>
<title>The Canary Watcher</title>
<para><emphasis>Pain is not, generally, a Good Sign.</emphasis></para>

<para>The Canary Watcher measures the quality of an organization by the their own pain level, and the observed pain levels of those he works with. He brings new participants into existing organizations so they can express the raw pain of the innocent. He may use alcohol to get others to verbalize their pain points. He asks others, and himself, "are you happy in this process, and if not, why not?" When an organization causes pain in himself or others, he treats that as a problem to be fixed. People should feel joy in their work.</para>

</sect2>
<sect2>
<title>The Hangman</title>
<para><emphasis>Never interrupt others when they are making mistakes.</emphasis></para>

<para>The Hangman knows that we learn only by making mistakes, and he gives others copious rope with which to learn. He only pulls the rope gently, when it's time. A little tug to remind the other of their precarious position. Allowing others to learn by failure gives the good reason to stay, and the bad excuse to leave. The Hangman is endlessly patient, because there is no shortcut to the learning process.</para>

</sect2>
<sect2>
<title>The Historian</title>
<para><emphasis>Keeping the public record may be tedious, but it's the only way to prevent collusion.</emphasis></para>

<para>The Historian forces discussion into the public view, to prevent collusion to own areas of work. The Pirate Gang depends on full and equal communications that do not depend on momentary presence. No-one really reads the archives, but the simply possibility stops most abuses. The Historian encourages the right tool for the job: email for transient discussions, IRC for chatter, wikis for knowledge, issue tracking for recording opportunities.</para>

</sect2>
<sect2>
<title>The Provocateur</title>
<para><emphasis>When a man knows he is to be hanged in a fortnight, it concentrates his mind wonderfully.</emphasis> -- Samuel Johnson</para>

<para>The Provocateur creates deadlines, enemies, and the occasional impossibility. Teams work best when they don't have time for the crap. Deadlines bring people together and focus the collective mind. An external enemy can move a passive team into action. The Provocateur never takes the deadline too seriously. The product is <emphasis>always</emphasis> ready to ship. But he gently reminds the team of the stakes: fail, and we all look for other jobs.</para>

</sect2>
<sect2>
<title>The Mystic</title>
<para><emphasis>When people argue or complain, just write them a Sun Tzu quotation</emphasis> -- Mikko Koppanen</para>

<para>The Mystic never argues directly. He knows that to argue with an emotional person only creates more emotion. Instead he side-steps the discussion. It's hard to be angry at a Chinese general, especially when he has been dead for 2,400 years. The Mystic plays Hangman when people insist on the right to get it wrong.</para>

</sect2>
</sect1>
</chapter>
<chapter id="moving-pieces">
<title>A Universe of Moving Pieces</title>
<para>So far in this book I've aimed to take you though a journey of understanding &Oslash;MQ in its many aspects. By now you may have started to build your own products using the techniques I explained, and others you've figured out yourself. You will start to face questions about to make these products work in the real world.</para>

<para>But what is that "real world"? My view is that it is becoming a world of ever increasing numbers of moving pieces. Some people use the phrase the "Internet of Things", suggesting that we'll see a new category of devices that are more numerous but rather stupider than our current smart phones and tablets and laptops and servers. However, I don't think the data points this way at all. Yes, more and more devices, but they're not stupid at all. They're smart and powerful and getting more so all the time.</para>

<para>The mechanism at work is something I call "Cost Gravity" and it has the effect of cutting the cost of technology by half every 18-24 months. Or, put another way, our global computing capacity doubles every two years, over and over and over. The future is filled with trillions of devices that are fully powerful multi-core computers: they don't run some cut-down "operating system for things" but full operating systems and full applications.</para>

<para>And this is the world we're aiming at with &Oslash;MQ. When we talk of "scale" we don't mean hundreds of computers, or even thousands. Think of clouds of tiny smart and perhaps self-replicating machines surrounding every person, filling every space, covering every wall, filling the cracks and eventually, becoming so much a part of us that we get them before birth and they follow us to death.</para>

<para>These clouds of tiny machines talk to each other, all the time, over short-range wireless links, using the Internet Protocol. They create mesh networks, pass information and tasks around like nervous signals. They augment our memory, vision, every aspect of our communications, and physical functions. And it's &Oslash;MQ that powers their conversations and events and exchanges of work and information.</para>

<para>Now, to make even a thin imitation of this come true today, we need to solve a set of technical problems (how do peers discover each other, how do they talk to existing networks like the Web, how do they protect the information they carry, how do we track and monitor them, to get some idea of what they're doing). Then we need to do what most engineers forget about: package this solution into a framework that is dead easy for ordinary developers to use.</para>

<para>This is what we'll attempt in this chapter: to build a framework for distributed applications, as an API, protocols, and implementations. It's not a small challenge but I've claimed often that &Oslash;MQ makes such problems simple, so let's see if that's still true.</para>

<para>We'll cover:</para>

<itemizedlist>
  <listitem><para>Building a basic framework for distributed computing.</para></listitem>
</itemizedlist>
<sect1>
<title>Design for The Real World</title>
<para>Whether we're connecting a roomful of mobile devices over WiFi, or a cluster of virtual boxes over simulated Ethernet, we will hit the same kinds of problems. These are:</para>

<itemizedlist>
  <listitem><para><emphasis>Discovery</emphasis> - how do we learn about other nodes on the network? Do we use a discovery service, centralized mediation, or some kind of broadcast beacon?</para></listitem>
  <listitem><para><emphasis>Presence</emphasis> - how do we track when other nodes come and go? Do we use some kind of central registration service, or heartbeating or beacons?</para></listitem>
  <listitem><para><emphasis>Connectivity</emphasis> - how do we actually connect one node to another? Do we use local networking, wide-area networking, or do we use a central message broker to do the forwarding?</para></listitem>
  <listitem><para><emphasis>Point-to-point messaging</emphasis> - how do we send a message from one node to another? Do we send this to the node's network address, or do we use some indirect addressing via a centralized message broker?</para></listitem>
  <listitem><para><emphasis>Group messaging</emphasis> - how do we send a message from one node to a group of others? Do we work via centralized message broker, or do we use a publish-subscribe model like &Oslash;MQ?</para></listitem>
  <listitem><para><emphasis>Testing and simulation</emphasis> - how do we simulate large numbers of nodes so we can test performance properly? Do we have to buy two dozen Android tablets, or can we use pure software simulation?</para></listitem>
  <listitem><para><emphasis>Distributed Logging</emphasis> - how do we track what this cloud of nodes is doing so we can detect performance problems and failures? Do we create a main logging service, or do we allow every device to log the world around it?</para></listitem>
  <listitem><para><emphasis>File transfer</emphasis> - how do we send files from one node to another? Do we use server-centric protocols like FTP or HTTP, or do we use decentralized protocols like FILEMQ?</para></listitem>
  <listitem><para><emphasis>State synchronization</emphasis> - how do we ensure that many nodes receive the same unique stream of events? Do we send events via single central point, or do we use a distributed eventually consistent model?</para></listitem>
  <listitem><para><emphasis>Security</emphasis> - how do we protect the confidentiality of information, and make sure people are who they claim to be? Do we use a centralised trust network, or do we use use some kind of distributed key management?</para></listitem>
  <listitem><para><emphasis>Bridging</emphasis> - how do we connect our networks across the Internet? Do we use the cloud as our central point for all messaging or do we create bridges that join groups to other groups?</para></listitem>
</itemizedlist>
<para>If we can solve these dozen problems reasonably well, we get something like a framework for what I might call "Really Cool Distributed Applications", or as my grandkids call it, "the software our world runs on".</para>

<para>You should have guessed from my rhetorical questions that there are two broad directions we can go. One is to centralize everything. The other is to distribute everything. I'm going to bet on decentralization. If you want centralization, you don't really need &Oslash;MQ; there are other options you can use.</para>

<para>So very roughly, here's the story. One, the number of moving pieces increases exponentially over time (doubles every 24 months). Two, these pieces stop using wires since dragging cables everywhere gets <emphasis>really</emphasis> boring. Three, future applications run across clusters of these pieces using the Benevolent Tyrant pattern from The &Oslash;MQ Community<xref linkend="the-community"/>. Four, today it's really difficult, nay still rather impossible, to build such applications. Five, let's make it cheap and easy using all the techniques and tools we've built up. Six, partay!</para>

</sect1>
<sect1>
<title>The Secret Life of WiFi</title>
<para>The future is clearly wireless, and while many big businesses live by concentrating data in their clouds, the future doesn't look quite so centralized. The devices at the edges of our networks get smarter every year, not dumber. They're hungry for work and information to digest and profit from. And they don't drag cables around, except once a night for power. It's all wireless, and more and more, 802.11-branded WiFi of different alphabetical flavors.</para>

<sect2>
<title>Why Mesh isn't Here Yet</title>
<para>As such a vital part of our future, WiFi has a big problem that's not often discussed but which anyone betting on it needs to be aware of. The phone companies of the world have built themselves nice profitable mobile phone cartels in nearly every country with a functioning government, based on convincing governments that without monopoly rights to airwaves and ideas, the world would fall apart. Technically, we call this "regulatory capture" and "patents", but in fact it's just a form of blackmail and corruption. If you, the state, give me, a business, the right to overcharge and tax the market, and ban all real competitors, I'll give you 5%. Not enough? How about 10%? OK, 15% plus snacks. If you refuse, we pull service.</para>

<para>But WiFi snuck past this, borrowing unlicensed airspace and riding on the back of the open and unpatented and remarkably innovative Internet protocol stack. So today we have the curious situation where it costs me several Euro a minute to call from Seoul to Brussels if I use the state-backed infrastructure that we've subsidized over decades, but nothing at all if I can find an unregulated WiFi access point. Oh, and I can do video, and send files, and photos, and download entire home movies all for the same amazing price point of precisely zero point zero zero (in any currency you like). God help me if I try to send just one photo home using the service I actually pay for. That would cost me more than the camera I took it on.</para>

<para>It is the price we pay for having tolerated the "trust us, we're the experts" patent system for so long. But more than that, it's a massive economic incentive to chunks of the technology sector -- and especially chipset makers who own patents on the anti-Internet GSM, GPRS, 3G, and LTE stacks, and who treat the telcos as prime clients -- to actively throttle WiFi development. And of course it's these firms that bulk out the IEEE committees that define WiFi.</para>

<para>The reason for this rant against lawyer-driven "innovation" is to steer your thinking into "what if WiFi was really free?" Because this will happen one day, not too far off, and it's worth betting on. We'll see several things happen. First, much more aggressive use of airspace especially for near-distance communications where there is no risk of interference. Secondly, big capacity improvements as we learn to use more airspace in parallel. Thirdly, acceleration of the standardization process. Lastly, broader support in devices for really interesting connectivity.</para>

<para>Right now streaming a movie from your phone to your TV is considered "leading edge". This is ridiculous. Let's get truly ambitious. How about a stadium of people watching a game, sharing photos and HD video with each other in real time, creating an ad-hoc event that literally saturates the airspace with a digital frenzy. I should be able to collect terabytes of imagery from those around me, in an hour. Why does this have to go through Twitter or Facebook and that tiny expensive mobile data connection? How about a home with hundreds of devices all talking to each other over mesh, so when someone rings the doorbell, the porch lights stream video through to your phone or TV? How about a car that can talk to your phone and play your dubstep playlist <emphasis>without you plugging in wires</emphasis>.</para>

<para>Why, in 2012, and to get more serious, is our digital society in the hands of central points that are monitored, censored, logged, used to track who we talk to, collect evidence against us, and then shut down when the authorities decide we have too much free speech? The loss of privacy we're living through is only a problem when it's one-sided, but then the problem is calamitous. A truly wireless world would bypass all central censorship. It's how the Internet was designed, and it's quite feasible. Technically.</para>

</sect2>
<sect2>
<title>Some Physics</title>
<para>Naive developers of distributed software treat the network as infinitely fast and perfectly reliable. While this is approximately true for simple applications over Ethernet, WiFi rapidly proves the difference between magical thinking and science. That is, WiFi breaks so easily and dramatically under stress that I sometimes wonder how anyone would dare use it for real work. The ceiling moves up, as WiFi gets better, but never fast enough to stop us hitting it.</para>

<para>To understand how WiFi performs technically you need to understand a basic law of physics: the power required to connect two points increases according to the square of the distance. People who grow up in larger houses have exponentially louder voices, as I learned in Dallas. For a WiFi network this means that as two radios get further apart, they have to either use more power, or lower their signal rate.</para>

<para>There's only so much power you can pull out of a battery before users treat the device as hopelessly broken. So though a WiFi network may be rated at some speed, the real bit rate between the access point (AP) and a client depends on how far apart the two are. As you move your WiFi-enabled phone away from the AP, the two radios trying to talk to each other will first increase their power but then reduce their bit rate.</para>

<para>This effect has some consequences we need to be aware of if we want to build robust distributed applications that don't dangle wires behind them like puppets:</para>

<itemizedlist>
  <listitem><para>If you have a group of devices talking to an AP, when the AP is talking to the slowest device, the <emphasis>whole network has to wait</emphasis>. It's like having to repeat a joke at a party to the designated driver, who has no sense of humor, is still fully and tragically sober, and has in any case a poor grasp of the language.</para></listitem>
  <listitem><para>If you use unicast TCP and send a message to multiple devices, the AP must send the packets to each device separately, Yes, you knew this, it's also how Ethernet works. But now understand that one distant (or low-powered) device means everything waits for that slowest device to catch up.</para></listitem>
  <listitem><para>If you use multicast or broadcast (which work the same, in most cases), the AP will send single packets to the whole network at once, which is awesome, but it will do it at the slowest possible bit rate (usually 1Mbps). You can adjust this rate manually in some APs. That just reduces the reach of your AP. You can also buy more expensive APs that have a little more intelligence and will figure out the highest bit rate they can safely use. You can also use enterprise APs with IGMP (Internet Group Management Protocol) support and &Oslash;MQ's PGM transport to send only to subscribed clients. I'd not however bet on such APs being widely available, ever.</para></listitem>
</itemizedlist>
<para>As you try to put more devices onto an AP, performance rapidly gets worse to the point where adding one more device can break the whole network, for everyone. Many APs solve this by randomly disconnecting clients when they reach some limit, four to eight devices for a mobile hotspot, 30-50 devices for a consumer AP, perhaps 100 devices for an enterprise AP.</para>

</sect2>
<sect2>
<title>What's the Current Status?</title>
<para>Despite its uncomfortable role as enterprise technology that somehow escaped into the wild, WiFi is already useful for more than getting a free Skype call. It's not ideal but it works well enough to let us solve some interesting problems. Let me give you a rapid status report.</para>

<para>First, point-to-point versus access point-to-client. Traditional WiFi is all AP-client. Every packet has to go from client A to AP, thence to client B. You cut your bandwidth by 50% but that's only half the problem. I explained about the inverse power law. If A and B are very close together but both far from the AP, they'll both be using a low bit rate. Imagine your AP is in the garage, and you're in the living room trying to stream video from your phone to your TV. Good luck!</para>

<para>There is an old "ad-hoc" mode that lets A and B talk to each other but it's way too slow for anything fun, and of course, it's disabled on all mobile chipsets. Actually, it's disabled in the top-secret drivers that the chipset makers kindly provide to hardware makers. There is a new "Tunneled Direct Link Setup" (TDLS) protocol that lets two devices create a direct link, using an AP for discovery but not for traffic. And there's a "5G" WiFi standard (it's a marketing term, so goes in quotes) that boosts link speeds to a gigabit. TDLS and 5G together make HD movie streaming from your phone to your TV a plausible reality. I assume TDLS will be restricted in various ways so as to placate the telcos.</para>

<para>Lastly, we saw standardization of the 802.11s mesh protocol in 2012, after a remarkably speedy ten years or so of work. Mesh removes the access point completely, at least in the imaginary future where it exists and is widely used. Devices talk to each other directly, and maintain little routing tables of neighbors that let them forward packets. Imagine the AP software embedded into every device but smart enough (it's not as impressive as it sounds) to do multiple hops.</para>

<para>No-one who is making money from the mobile data extortion racket wants to see 802.11s available, because city-wide mesh is such a nightmare for the bottom line, so it's happening as slowly as possible. The only large organization with the power (and, I assume the surface-to-surface missiles) to get mesh technology into wide use is the US Army. But mesh will emerge and I'd bet on 802.11s being widely available in consumer electronics by 2020 or so.</para>

<para>Second, if we don't have point-to-point, how far can we trust APs today? Well, if you go to a Starbucks in the USA and try the &Oslash;MQ Hello World example using two laptops connected via the free WiFi, you'll find they cannot connect. Why? Well, the answer is in the name: "attwifi". AT&amp;T is a good old incumbent telco that hates WiFi and presumably provides the service cheaply to Starbucks and others so that independents can't get into the market. But any access point you buy will support client-to-AP-to-client access, and outside the USA I've never found a public AP locked-down the AT&amp;T way.</para>

<para>Third, performance. The AP is clearly a bottleneck; you cannot get better than half of its advertised speed even if you put A and B literally beside the AP. Worse, if there are other APs in the same airspace, they'll shout each other out. In my home, WiFi barely works at all because the neighbors two houses down have an AP which they've amplified. Even on a different channel it interferes with our home WiFi. In the cafe where I'm sitting now there are over a dozen networks. Realistically, as long as we're dependent on AP-based WiFi, we're subject to random interference and unpredictable performance.</para>

<para>Fourth, battery life. There's no inherent reason that WiFi, when idle, is hungrier than Bluetooth, for example. They use the same radios and low-level framing. The main difference is tuning and in the protocols. For wireless power-saving to work well, devices have to mostly sleep, and beacon out to other devices only once every so often. For this to work, they need to synchronize their clocks. This happens properly for the mobile phone part, which is why my old flip phone can run five days on a charge. When WiFi is working, it will use more power. Current power amplifier technology is also inefficient, meaning you draw a lot more energy from your battery than you pump into the air (the waste turns into a hot phone). Power amplifiers are improving as people focus more on mobile WiFi.</para>

<para>Lastly, mobile access points. If we can't trust centralized APs, and if our devices are smart enough to run full operating systems, can't we make them work as APs? I'm <emphasis>so glad</emphasis> you asked that question. Yes, we can, and it works quite nicely. Especially since you can switch this on and off in software, on a modern OS like Android. Again, the villains of the peace are the US telcos, who mostly detest this feature and kill it or cripple it on the phones they control. Smarter telcos realize that it's a way to amplify their "last mile" and bring higher-value products to more users, but crooks don't compete on smarts.</para>

</sect2>
<sect2>
<title>Conclusions</title>
<para>WiFi is not Ethernet and although I believe future &Oslash;MQ applications will have a very important decentralized wireless presence, it's not going to be an easy road. Much of the basic reliability and capacity that you expect from Ethernet is missing. When you run a distributed application over WiFi you have to allow for frequent timeouts, random latencies, arbitrary disconnections, whole interfaces going down and coming up, and so on.</para>

<para>The technological evolution of wireless networking is best described as "slow and joyless". Applications and frameworks that try to exploit decentralized wireless are mostly absent or poor. The only existing open source framework for proximity networking is <ulink url="https://www.alljoyn.org">AllJoyn</ulink>, from Qualcomm. But with &Oslash;MQ we proved that the inertia and decrepit incompetence of existing players was no reason for us to sit still. When we accurately understand problems, we can solve them. What we imagine, we can make real.</para>

</sect2>
</sect1>
<sect1>
<title>Discovery</title>
<para>One of the great things about short-range wireless is the proximity. WiFi maps closely to the physical space, which maps closely to how we naturally organize. In fact the Internet is quite abstract and this confuses a lot of people who kind of "get" it but in fact don't really. With WiFi we have technical connectivity that is potentially super-tangible. You see what you get and you get what you see. Tangible means easy to understand and that should mean love from users instead of the typical frustration and quiet hate.</para>

<para>Proximity is the key. We have a bunch of WiFi radios in room, happily beaconing to each other. For lots of applications it makes sense that they can find each other and start chatting, without any user input. After all, most real world data isn't private, it's just highly localized.</para>

<para>As a first step towards &Oslash;MQ-based proximity networking, let's look at how to do discovery. There exist libraries that do this. I don't like them. They seem too complex and too specific and somehow to date from a prehistoric era before people realized that distributed computing could be <emphasis>fundamentally simple</emphasis>.</para>

<sect2>
<title>Preemptive Discovery over Raw Sockets</title>
<para>I'm in a hotel room in Gangnam, Seoul, with a 4G wireless hotspot, a Linux laptop, and an couple of Android phones. The phones and laptop are talking to the hotspot. The <literal>ifconfig</literal> command says my IP address is 192.168.1.2. Let me try some <literal>ping</literal> commands. DHCP servers tend to dish out addresses in sequence, so my phones are probably close by, numerically speaking:</para>

<screen>$ ping 192.168.1.1
PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data.
64 bytes from 192.168.1.1: icmp_req=1 ttl=64 time=376 ms
64 bytes from 192.168.1.1: icmp_req=2 ttl=64 time=358 ms
64 bytes from 192.168.1.1: icmp_req=4 ttl=64 time=167 ms
^C
--- 192.168.1.1 ping statistics ---
3 packets transmitted, 2 received, 33% packet loss, time 2001ms
rtt min/avg/max/mdev = 358.077/367.522/376.967/9.445 ms
</screen>

<para>Found one! 150-300 msec round-trip latency... that's a surprisingly high figure, something to keep in mind for later. Now I ping myself, just to try to double check things:</para>

<screen>$ ping 192.168.1.2
PING 192.168.1.2 (192.168.1.2) 56(84) bytes of data.
64 bytes from 192.168.1.2: icmp_req=1 ttl=64 time=0.054 ms
64 bytes from 192.168.1.2: icmp_req=2 ttl=64 time=0.055 ms
64 bytes from 192.168.1.2: icmp_req=3 ttl=64 time=0.061 ms
^C
--- 192.168.1.2 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 1998ms
rtt min/avg/max/mdev = 0.054/0.056/0.061/0.009 ms
</screen>

<para>The response time is a bit faster now, which is what we'd expect. Let's try the next couple of addresses:</para>

<screen>$ ping 192.168.1.3
PING 192.168.1.3 (192.168.1.3) 56(84) bytes of data.
64 bytes from 192.168.1.3: icmp_req=1 ttl=64 time=291 ms
64 bytes from 192.168.1.3: icmp_req=2 ttl=64 time=271 ms
64 bytes from 192.168.1.3: icmp_req=3 ttl=64 time=132 ms
^C
--- 192.168.1.3 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2001ms
rtt min/avg/max/mdev = 132.781/231.914/291.851/70.609 ms
</screen>

<para>That's the second phone, with the same kind of latency as the first one. Let's continue, see if there are any other devices connected to the hotspot:</para>

<screen>$ ping 192.168.1.4
PING 192.168.1.4 (192.168.1.4) 56(84) bytes of data.
^C
--- 192.168.1.4 ping statistics ---
3 packets transmitted, 0 received, 100% packet loss, time 2016ms
</screen>

<para>And that is it. Now, <literal>ping</literal> uses raw IP sockets to send ICMP_ECHO messages. The useful thing about ICMP_ECHO is that it gets a response from any IP stack that has not been deliberately had echo switched off. That's still a common practice on corporate websites who fear the old "ping of death" exploit where malformed messages could crash the machine.</para>

<para>I call this <emphasis>pre-emptive discovery</emphasis> since it doesn't take any cooperation from the device. We don't rely on any cooperation from the phones to see them sitting there; as long as they're not actively ignoring us, we can see them.</para>

<para>You might ask why this is useful. We don't know that the peers responding to ICMP_ECHO run &Oslash;MQ, that they are interested in talking to us, that they have any services we can use, or even what kind of device they are. However, knowing that there's <emphasis>something</emphasis> on address 192.168.1.3 is already useful. We also know how far away the device is, relatively, we know how many devices are on the network, and we know the rough state of the network (as in, good, poor, or terrible).</para>

<para>It isn't even hard to create ICMP_ECHO messages and send them. A few dozen lines of code, and we could use &Oslash;MQ multithreading to do this in parallel for addresses stretching out above and below our own IP address. Could be kind of fun.</para>

<para>However, sadly, there's a fatal flaw in my idea of using ICMP_ECHO to discover devices. To open a raw IP socket requires root privileges on a POSIX box. It stops rogue programs getting data meant for others. We can get the power to open raw sockets on Linux by giving sudo privileges to our command (ping has the so-called 'sticky bit' set). On a mobile OS like Android, it requires root access, i.e. rooting the phone or tablet. That's out of the question for most people and so ICMP_ECHO is out of reach for most devices.</para>

<para><emphasis>Expletive deleted!</emphasis> Let's try something in user space. The next step most people take is UDP multicast or broadcast. Let's follow that trail.</para>

</sect2>
<sect2>
<title>Cooperative Discovery using UDP Broadcasts</title>
<para>Multicast tends to be seen as more modern and "better" than broadcast. In IPv6, broadcast doesn't work at all: you have to always use broadcast. Nonetheless, all IPv4 local network discovery protocols end up using UDP broadcast anyhow. The reasons: broadcast and multicast end up working much the same, except broadcast is simpler and less risky. Multicast is seen by network admins as kind of dangerous, as it can leak over network segments.</para>

<para>If you never used UDP, you'll discover it's quite a nice protocol. In some ways it reminds us of &Oslash;MQ, sending whole messages to peers using a two different patterns: one-to-one, and one-to-many. The main problems with UDP are that (a) the POSIX socket API was designed for universal flexibility not simplicity, (b) UDP messages are limited for practical purposes to about 512 bytes, and (c) when you start to use UDP for real data, you find that a lot of messages get dropped, especially as infrastructure tends to favor TCP over UDP.</para>

<para>Here is a minimal ping program that uses UDP instead of ICMP_ECHO:</para>

<example id="udpping1-c">
<title>UDP discovery, model 1 (udpping1.c)</title>
<programlisting language="c">
//
//  UDP ping command
//  Model 1, does UDP work inline
//
#include &lt;czmq.h&gt;
#define PING_PORT_NUMBER 9999
#define PING_MSG_SIZE    1
#define PING_INTERVAL    1000  //  Once per second

static void
derp (char *s)
{
    perror (s);
    exit (1);
}

int main (void)
{
    zctx_t *ctx = zctx_new ();

    //  Create UDP socket
    int fd;
    if ((fd = socket (AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1)
        derp ("socket");

    //  Ask operating system to let us do broadcasts from socket
    int on = 1;
    if (setsockopt (fd, SOL_SOCKET, SO_BROADCAST, &amp;on, sizeof (on)) == -1)
        derp ("setsockopt (SO_BROADCAST)");

    //  Bind UDP socket to local port so we can receive pings
    struct sockaddr_in si_this = { 0 };
    si_this.sin_family = AF_INET;
    si_this.sin_port = htons (PING_PORT_NUMBER);
    si_this.sin_addr.s_addr = htonl (INADDR_ANY);
    if (bind (fd, &amp;si_this, sizeof (si_this)) == -1)
        derp ("bind");
    
    byte buffer [PING_MSG_SIZE];
    
</programlisting>

</example>
<para>We use zmq_poll to wait for activity on the UDP socket, since this function works on non-&Oslash;MQ file handles. We send a beacon once a second, and we collect and report beacons that come in from other nodes: 
</para>

<example id="udpping1-c-1">
<title>UDP discovery, model 1 (udpping1.c) - main ping loop</title>
<programlisting language="c">
    zmq_pollitem_t pollitems [] = {{ NULL, fd, ZMQ_POLLIN, 0 }};
    //  Send first ping right away
    uint64_t ping_at = zclock_time ();
    
    while (!zctx_interrupted) {
        long timeout = (long) (ping_at - zclock_time ());
        if (timeout &lt; 0)
            timeout = 0;
        if (zmq_poll (pollitems, 1, timeout * ZMQ_POLL_MSEC) == -1)
            break;              //  Interrupted

        //  Someone answered our ping
        if (pollitems [0].revents &amp; ZMQ_POLLIN) {
            struct sockaddr_in si_that;
            socklen_t si_len;
            ssize_t size = recvfrom (fd, buffer, PING_MSG_SIZE, 0, &amp;si_that, &amp;si_len);
            if (size == -1)
                derp ("recvfrom");
            printf ("Found peer %s:%d\n",
                inet_ntoa (si_that.sin_addr), ntohs (si_that.sin_port));
        }
        if (zclock_time () &gt;= ping_at) {
            //  Broadcast our beacon
            puts ("Pinging peers...");
            buffer [0] = '!';
            struct sockaddr_in si_that = si_this;
            inet_aton ("255.255.255.255", &amp;si_that.sin_addr);
            if (sendto (fd, buffer, PING_MSG_SIZE, 0, &amp;si_that, sizeof (struct sockaddr_in)) == -1)
                derp ("sendto");
            ping_at = zclock_time () + PING_INTERVAL;
        }
    }
    close (fd);
    zctx_destroy (&amp;ctx);
    return 0;
}
</programlisting>

</example>
<para>This code uses a single socket to broadcast 1-byte messages and receive anything that other nodes are broadcasting. When I run it, it shows just one node, which is itself:</para>

<screen>Pinging peers...
Found peer 192.168.1.2:9999
Pinging peers...
Found peer 192.168.1.2:9999
</screen>

<para>If I switch off all networking and try again, sending a message fails, as I'd expect:</para>

<screen>Pinging peers...
sendto: Network is unreachable
</screen>

<para>Working on the basis of <emphasis>solve the problems currently aiming at your throat</emphasis>, let's fix the most urgent issues in this first model. These issues are:</para>

<itemizedlist>
  <listitem><para>Using the 255.255.255.255 broadcast address is a bit dubious. On the one hand, this broadcast address means precisely "send to all nodes on the local network, and don't forward". However, if you have several interfaces (wired Ethernet, WiFi) then broadcasts will go out on your default route only, and via just one interface. What we want to do is either send our broadcast on each interface's broadcast address, or find the WiFi interface and its broadcast address.</para></listitem>
  <listitem><para>Like many aspects of socket programming, getting information on network interfaces is not portable. Do we want to write non-portable code in our applications? No, this is better hidden in a library.</para></listitem>
  <listitem><para>There's no handling for errors except "abort", which is too brutal for transient problems like "your WiFi is switched off". The code should distinguish between soft errors (ignore and retry) and hard errors (assert).</para></listitem>
  <listitem><para>The code needs to know its own IP address and ignore beacons that it sent out. Like finding the broadcast address, this requires inspecting the available interfaces.</para></listitem>
</itemizedlist>
<para>The simplest answer to these issues is to push the UDP code into a separate library that provided a clean API, like this:</para>

<programlisting language="c">
//  Constructor
static udp_t *
    udp_new (int port_nbr);

//  Destructor
static void
    udp_destroy (udp_t **self_p);

//  Returns UDP socket handle
static int
    udp_handle (udp_t *self);

//  Send message using UDP broadcast
static void
    udp_send (udp_t *self, byte *buffer, size_t length);

//  Receive message from UDP broadcast
static ssize_t
    udp_recv (udp_t *self, byte *buffer, size_t length);
</programlisting>

<para>Here is the refactored UDP ping program that calls this library, which is much cleaner and nicer:</para>

<example id="udpping2-c">
<title>UDP discovery, model 2 (udpping2.c)</title>
<programlisting language="c">
//
//  UDP ping command
//  Model 2, uses separate UDP library
//
#include &lt;czmq.h&gt;
#include "udplib.c"

#define PING_PORT_NUMBER 9999
#define PING_MSG_SIZE    1
#define PING_INTERVAL    1000  //  Once per second

int main (void)
{
    zctx_t *ctx = zctx_new ();
    udp_t *udp = udp_new (PING_PORT_NUMBER);
    
    byte buffer [PING_MSG_SIZE];
    zmq_pollitem_t pollitems [] = {{ NULL, udp_handle (udp), ZMQ_POLLIN, 0 }};
    
    //  Send first ping right away
    uint64_t ping_at = zclock_time ();
    
    while (!zctx_interrupted) {
        long timeout = (long) (ping_at - zclock_time ());
        if (timeout &lt; 0)
            timeout = 0;
        if (zmq_poll (pollitems, 1, timeout * ZMQ_POLL_MSEC) == -1)
            break;              //  Interrupted

        //  Someone answered our ping
        if (pollitems [0].revents &amp; ZMQ_POLLIN)
            udp_recv (udp, buffer, PING_MSG_SIZE);
        
        if (zclock_time () &gt;= ping_at) {
            puts ("Pinging peers...");
            buffer [0] = '!';
            udp_send (udp, buffer, PING_MSG_SIZE);
            ping_at = zclock_time () + PING_INTERVAL;
        }
    }
    udp_destroy (&amp;udp);
    zctx_destroy (&amp;ctx);
    return 0;
}
</programlisting>

</example>
<para>The library, udplib, hides a lot of the unpleasant code (which will become uglier we make this work on more systems). I'm not going to print that code here. You can read it <ulink url="https://github.com/imatix/zguide/blob/master/examples/C/udplib.c">in the repository</ulink>.</para>

<para>Now, there are more problems sizing us up and wondering if they can make lunch out of us. First, IPv4 versus IPv6 and multicast vs. broadcast. In IPv6, broadcast doesn't exist at all; one uses multicast. From my experience with WiFi, IPv4 multicast and broadcast work identically except that multicast breaks in some situations where broadcast works fine. Some access points do not forward multicast packets. When you have a device (e.g. a tablet) that acts as a mobile AP, then it's possible it won't get multicast packets. Meaning, it won't see other peers on the network.</para>

<para>The simplest plausible solution is simply to ignore IPv6 for now, and use broadcast. A perhaps smarter solution would be to use multicast, and deal with asymmetric beacons if they happen.</para>

<para>We'll stick with stupid and simple for now. There's always time to make it more complex.</para>

</sect2>
<sect2>
<title>Multiple Nodes on One Device</title>
<para>So we can discover nodes on the WiFi network, as long as they're sending out beacons as we expect. So I try to test with two processes. But when I run udpping2 twice, the second instance complains "'Address already in use' on bind" and exits. Oh, right. UDP and TCP both return an error if you try to bind two different sockets to the same port. This is right. The semantics of two readers on one socket would be weird to say the least. Odd/even bytes? You get all the 1s, I get all the 0's?</para>

<para>However, a quick check of stackoverflow and some memory of a socket option called SO_REUSEADDR turns up gold. If I use that, I can bind several processes to the same UDP port, and they will all receive any message arriving on that port. It's almost as if the guys who designed this were reading my mind! (That's way more plausible than maybe I'm reinventing the wheel.)</para>

<para>A quick test shows that SO_REUSADDR works as promised. This is great because the next thing I want to do is design an API and then start dozens of nodes to see them discovering each other. It would be really cumbersome to have to test each node on a separate device. And when we get to testing how real traffic behaves on a large, flaky network, the two alternatives are simulation or temporary insanity.</para>

<para>And I speak from experience: we were, this summer, testing on dozens of devices at once. It takes about an hour to set-up a full test run, and you need a space shielded from WiFi interference if you want any kind of reproducibility (unless your test case is "prove that interference kills WiFi networks faster than Orval can kill a thirst".</para>

<para>If I was a wizz Android developer with a free weekend I'd immediately (as in, it would take me two days) port this code to my phone and get it sending beacons to my PC. But sometimes lazy is more profitable. I <emphasis>like</emphasis> my Linux laptop. I like being able to start a dozen threads from one process, and have each thread acting like an independent node. I like not having to work in a real Faraday cage when I can simulate one on my laptop.</para>

</sect2>
<sect2>
<title>Designing the API</title>
<para>I'm going to run N nodes on a device, and they are going to have to discover each other, and also discover a bunch of other nodes out there on the local network. I can use UDP for local discovery as well as remote discovery. It's arguably not as efficient as using, e.g., the &Oslash;MQ inproc:// transport, but has the great advantage that the exact same code will work in simulation and in real deployment.</para>

<para>If I have multiple nodes on one device, we clearly can't use the IP address and port number as node address. I need some logical node identifier. Arguably, the node identifier only has to be unique within the context of the device. My mind fills with complex stuff I could make, like supernodes that sit on real UDP ports and forward messages to internal nodes. I hit my head on the table until the idea of <emphasis>inventing new concepts</emphasis> leaves it.</para>

<para>Experience tells us that WiFi does things like disappear and reappear while applications are running. Users click on things. Which does interesting things like change the IP address halfway through a session. We cannot depend on IP addresses, nor on established connections (in the TCP fashion). We need some long-lasting addressing mechanism that survives interfaces and connections being torn down, and then recreated.</para>

<para>Here's the simplest solution I can see: we give every node a UUID, and specify that nodes, represented by their UUIDs, can appear or reappear at certain IP address:port endpoints, and then disappear again. We'll deal with recovery from lost messages later. A UUID is 16 bytes. So if I have 100 nodes on a WiFi network that's (double it for other random stuff) 3,200 bytes a second of beacon data that the air has to carry just for discovery and presence. Seems acceptable.</para>

<para>Back to concepts. We do need some names for our API. At the least we need a way to distinguish between the node object that is "us", and node objects that are our peers.  We'll be doing things like creating an "us" and then asking it how many peers it knows about and who they are. The term "peer" is clear enough.</para>

<para>From the developer point of view, a node (the application) needs a way to talk to the outside world. Let's borrow a term from networking and call this an "interface". The interface represents us to the rest of the world and presents the rest of the world to us, as a set of other peers. It automatically does whatever discovery it has to. When we want to talk to a peer, we get the interface to do that for us. And when a peer talks to us, it's the interface that delivers us the message.</para>

<para>This seems like a clean API design. How about the internals?</para>

<itemizedlist>
  <listitem><para>The interface has to be multithreaded, so that one thread can do I/O in the background, while the foreground API talks to the application. We used this design in the Clone and Freelance client APIs.</para></listitem>
  <listitem><para>The interface background thread does the discovery business; bind to the UDP port, send out UDP beacons, and receive beacons.</para></listitem>
  <listitem><para>We need to at least send UUIDs in the beacon message so that we can distinguish our own beacons from those of our peers.</para></listitem>
  <listitem><para>We need to track peers that appear, and that disappear. For this I'll use a hash table that stores all known peers, and expire peers after some timeout.</para></listitem>
  <listitem><para>We need a way to report peers and events to the caller. Here we get into a juicy question. How does a background I/O thread tell a foreground API thread that stuff is happening? Callbacks maybe? <emphasis>Heck no.</emphasis> We'll use &Oslash;MQ messages, of course.</para></listitem>
</itemizedlist>
<para>The third iteration of the UDP ping program is even simpler and more beautiful than the second. The main body, in C, is just ten lines of code.</para>

<example id="udpping3-c">
<title>UDP discovery, model 3 (udpping3.c)</title>
<programlisting language="c">
//
//  UDP ping command
//  Model 3, uses abstract network interface
//
#include &lt;czmq.h&gt;
#include "interface.c"

int main (void)
{
    interface_t *interface = interface_new ();
    while (true) {
        zmsg_t *msg = interface_recv (interface);
        if (!msg)
            break;              //  Interrupted
        zmsg_dump (msg);
    }
    interface_destroy (&amp;interface);
    return 0;
}
</programlisting>

</example>
<para>The interface code should be familiar if you've studied how we make multithreaded API classes:</para>

<example id="interface-c">
<title>UDP ping interface (interface.c)</title>
<programlisting language="c">
//  Interface class for Chapter 8
//  This implements an "interface" to our network of nodes

#include &lt;czmq.h&gt;
#include &lt;uuid/uuid.h&gt;
#include "udplib.c"


//  =====================================================================
//  Synchronous part, works in our application thread

//  ---------------------------------------------------------------------
//  Structure of our class

typedef struct {
    zctx_t *ctx;                //  Our context wrapper
    void *pipe;                 //  Pipe through to agent
} interface_t;

//  This is the thread that handles our real interface class
static void
    interface_agent (void *args, zctx_t *ctx, void *pipe);
</programlisting>

</example>
<para>Here are the constructor and destructor for the interface class. Note that the class has barely any properties, it is just an excuse to start the background thread, and a wrapper around zmsg_recv(): 
</para>

<example id="interface-c-1">
<title>UDP ping interface (interface.c) - constructor and destructor</title>
<programlisting language="c">

interface_t *
interface_new (void)
{
    interface_t
        *self;

    self = (interface_t *) zmalloc (sizeof (interface_t));
    self-&gt;ctx = zctx_new ();
    self-&gt;pipe = zthread_fork (self-&gt;ctx, interface_agent, NULL);
    return self;
}

void
interface_destroy (interface_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        interface_t *self = *self_p;
        zctx_destroy (&amp;self-&gt;ctx);
        free (self);
        *self_p = NULL;
    }
}
</programlisting>

</example>
<para>Here we wait for a message from the interface. This returns us a zmsg_t object, or NULL if interrupted: 
</para>

<example id="interface-c-2">
<title>UDP ping interface (interface.c) - receive message</title>
<programlisting language="c">

static zmsg_t *
interface_recv (interface_t *self)
{
    assert (self);
    zmsg_t *msg = zmsg_recv (self-&gt;pipe);
    return msg;
}


//  =====================================================================
//  Asynchronous part, works in the background
</programlisting>

</example>
<para>This structure defines each peer that we discover and track: 
</para>

<example id="interface-c-3">
<title>UDP ping interface (interface.c) - peer class</title>
<programlisting language="c">

typedef struct {
    uuid_t uuid;                //  Peer's UUID as binary blob
    char *uuid_str;             //  UUID as printable string
    uint64_t expires_at;
} peer_t;

#define PING_PORT_NUMBER 9999
#define PING_INTERVAL    1000  //  Once per second
#define PEER_EXPIRY      5000  //  Five seconds and it's gone

//  Convert binary UUID to freshly allocated string

static char *
s_uuid_str (uuid_t uuid)
{
    char hex_char [] = "0123456789ABCDEF";
    char *string = zmalloc (sizeof (uuid_t) * 2 + 1);
    int byte_nbr;
    for (byte_nbr = 0; byte_nbr &lt; sizeof (uuid_t); byte_nbr++) {
        string [byte_nbr * 2 + 0] = hex_char [uuid [byte_nbr] &gt;&gt; 4];
        string [byte_nbr * 2 + 1] = hex_char [uuid [byte_nbr] &amp; 15];
    }
    return string;
}
</programlisting>

</example>
<para>We have a constructor and destructor for the peer class: 
</para>

<example id="interface-c-4">
<title>UDP ping interface (interface.c) - peer constructor and destructor</title>
<programlisting language="c">

static peer_t *
peer_new (uuid_t uuid)
{
    peer_t *self = (peer_t *) zmalloc (sizeof (peer_t));
    memcpy (self-&gt;uuid, uuid, sizeof (uuid_t));
    self-&gt;uuid_str = s_uuid_str (self-&gt;uuid);
    return self;
}

//  Destroy peer object

static void
peer_destroy (peer_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        peer_t *self = *self_p;
        free (self-&gt;uuid_str);
        free (self);
        *self_p = NULL;
    }
}
</programlisting>

</example>
<para>These methods return the peer's UUID in binary format or as a printable string: 
</para>

<example id="interface-c-5">
<title>UDP ping interface (interface.c) - peer methods</title>
<programlisting language="c">

static byte *
peer_uuid (peer_t *self)
{
    assert (self);
    return self-&gt;uuid;
}

static char *
peer_uuid_str (peer_t *self)
{
    assert (self);
    return self-&gt;uuid_str;
}

//  Just resets the peers expiry time; we call this method
//  whenever we get any activity from a peer.

static void
peer_is_alive (peer_t *self)
{
    assert (self);
    self-&gt;expires_at = zclock_time () + PEER_EXPIRY;
}

//  Peer hash calls this handler automatically whenever we delete
//  peer from agent peers, or destroy that hash table.

static void
peer_freefn (void *argument)
{
    peer_t *peer = (peer_t *) argument;
    peer_destroy (&amp;peer);
}
</programlisting>

</example>
<para>This structure holds the context for our agent, so we can pass that around cleanly to methods which need it: 
</para>

<example id="interface-c-6">
<title>UDP ping interface (interface.c) - agent class</title>
<programlisting language="c">

typedef struct {
    zctx_t *ctx;                //  CZMQ context
    void *pipe;                 //  Pipe back to application
    udp_t *udp;                 //  UDP object
    uuid_t uuid;                //  Our UUID as binary blob
    zhash_t *peers;             //  Hash of known peers, fast lookup
} agent_t;
</programlisting>

</example>
<para>Now the constructor and destructor for our agent. Each interface has one agent object, which implements its background thread: 
</para>

<example id="interface-c-7">
<title>UDP ping interface (interface.c) - agent constructor and destructor</title>
<programlisting language="c">

static agent_t *
agent_new (zctx_t *ctx, void *pipe)
{
    agent_t *self = (agent_t *) zmalloc (sizeof (agent_t));
    self-&gt;ctx = ctx;
    self-&gt;pipe = pipe;
    self-&gt;udp = udp_new (PING_PORT_NUMBER);
    self-&gt;peers = zhash_new ();
    uuid_generate (self-&gt;uuid);
    return self;
}

static void
agent_destroy (agent_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        agent_t *self = *self_p;
        zhash_destroy (&amp;self-&gt;peers);
        udp_destroy (&amp;self-&gt;udp);
        free (self);
        *self_p = NULL;
    }
}
...
</programlisting>

</example>
<para>This is how we handle a beacon coming into our UDP socket; this may be from other peers or an echo of our own broadcast beacon: 
</para>

<example id="interface-c-8">
<title>UDP ping interface (interface.c) - handle beacon</title>
<programlisting language="c">


static int
agent_handle_beacon (agent_t *self)
{
    uuid_t uuid;
    ssize_t size = udp_recv (self-&gt;udp, uuid, sizeof (uuid_t));

    //  If we got a UUID and it's not our own beacon, we have a peer
    if (size == sizeof (uuid_t)
    &amp;&amp;  memcmp (uuid, self-&gt;uuid, sizeof (uuid))) {
        char *uuid_str = s_uuid_str (uuid);
        
        //  Find or create peer via its UUID string
        peer_t *peer = (peer_t *) zhash_lookup (self-&gt;peers, uuid_str);
        if (peer == NULL) {
            peer = peer_new (uuid);
            zhash_insert (self-&gt;peers, uuid_str, peer);
            zhash_freefn (self-&gt;peers, uuid_str, peer_freefn);
            
            //  Report peer joined the network
            zstr_sendm (self-&gt;pipe, "JOINED");
            zstr_send (self-&gt;pipe, uuid_str);
        }
        //  Any activity from the peer means it's alive
        peer_is_alive (peer);
        free (uuid_str);
    }
    return 0;
}
</programlisting>

</example>
<para>This method checks one peer item for expiry; if the peer hasn't sent us anything by now, it's 'dead' and we can delete it: 
</para>

<example id="interface-c-9">
<title>UDP ping interface (interface.c) - reap peers</title>
<programlisting language="c">

static int
agent_reap_peer (const char *key, void *item, void *argument)
{
    agent_t *self = (agent_t *) argument;
    peer_t *peer = (peer_t *) item;
    if (zclock_time () &gt;= peer-&gt;expires_at) {
        //  Report peer left the network
        zstr_sendm (self-&gt;pipe, "LEFT");
        zstr_send (self-&gt;pipe, peer_uuid_str (peer));
        zhash_delete (self-&gt;peers, peer_uuid_str (peer));
    }
    return 0;
}
</programlisting>

</example>
<para>This is the main loop for the background agent. It uses zmq_poll to monitor the front-end pipe (commands from the API) and the back-end UDP handle (beacons): 
</para>

<example id="interface-c-10">
<title>UDP ping interface (interface.c) - agent main loop</title>
<programlisting language="c">

static void
interface_agent (void *args, zctx_t *ctx, void *pipe)
{
    //  Create agent instance to pass around
    agent_t *self = agent_new (ctx, pipe);
    
    //  Send first beacon immediately
    uint64_t ping_at = zclock_time ();
    zmq_pollitem_t pollitems [] = {
        { self-&gt;pipe, 0, ZMQ_POLLIN, 0 },
        { 0, udp_handle (self-&gt;udp), ZMQ_POLLIN, 0 }
    };
    
    while (!zctx_interrupted) {
        long timeout = (long) (ping_at - zclock_time ());
        if (timeout &lt; 0)
            timeout = 0;
        if (zmq_poll (pollitems, 2, timeout * ZMQ_POLL_MSEC) == -1)
            break;              //  Interrupted

        //  If we had activity on the pipe, go handle the control
        //  message. Current code never sends control messages.
        if (pollitems [0].revents &amp; ZMQ_POLLIN)
            agent_control_message (self);

        //  If we had input on the UDP socket, go process that
        if (pollitems [1].revents &amp; ZMQ_POLLIN)
            agent_handle_beacon (self);

        //  If we passed the 1-second mark, broadcast our beacon
        if (zclock_time () &gt;= ping_at) {
            udp_send (self-&gt;udp, self-&gt;uuid, sizeof (uuid_t));
            ping_at = zclock_time () + PING_INTERVAL;
        }
        //  Delete and report any expired peers
        zhash_foreach (self-&gt;peers, agent_reap_peer, self);
    }
    agent_destroy (&amp;self);
}
</programlisting>

</example>
<para>When I run this in two windows, it reports one peer joining the network. I kill that peer and a few seconds later it tells me the peer left:</para>

<screen>--------------------------------------
[006] JOINED
[032] 418E98D4B7184844B7D5E0EE5691084C
--------------------------------------
[004] LEFT
[032] 418E98D4B7184844B7D5E0EE5691084C
</screen>

<para>What's nice about a &Oslash;MQ-message based API is that I can wrap this any way I like. For instance, turning it into callbacks if I really want those. I can also trace all activity on the API very easily.</para>

<para>Some notes about tuning. On Ethernet, five seconds (the expiry time I used in this code) seems like a lot. On a badly stressed WiFi network you can get ping latencies of 30 seconds or more. If you use a too-aggressive value for the expiry, you'll disconnect nodes that are still there. On the other side, end user applications expect a certain liveliness. If it takes 30 seconds to report that a node has gone, users will get annoyed.</para>

<para>A decent strategy is to detect and report disappeared nodes rapidly, but only delete them after a longer interval. Visually, a node would be green when it's alive, then gray for a while as it went out of reach, then finally disappear. We're not doing this now, but will do it in the real implementation of the as-yet-unnamed framework we're making.</para>

<para>As we will also see later, we have to treat any input from a node, not just UDP beacons, as a sign of life. UDP may get squashed when there's a lot of TCP traffic. This is perhaps the main reason we're not using an existing UDP discovery library: we have to integrate this tightly with our &Oslash;MQ messaging for it to work.</para>

</sect2>
<sect2>
<title>More about UDP</title>
<para>So we have discovery and presence working over UDP IPv4 broadcasts. It's not ideal, but it works for the local networks we have today. However we can't use UDP for real work, not without additional work to make it reliable. There's a joke about UDP but sometimes you'll get it, and sometimes you won't.</para>

<para>We'll stick to TCP for all one-to-one messaging. There is one more use-case for UDP after discovery, which is multicast file distribution. I'll explain why and how, then shelve that for another day. The why is simple: what we call "social networks" is just augmented culture. We create culture by sharing, and this means more and more, sharing works that we make or remix. Photos, documents, contracts, tweets. The clouds of devices we're aiming towards do more of this, not less.</para>

<para>Now, there are two principal patterns for sharing content. One is the "pubsub" pattern where one node sends out content to a set of other nodes, at the same time. Second is the "late joiner" pattern, where a node arrives somewhat later and wants to catch up to the conversation. We can deal with the late joiner using TCP unicast. But doing TCP unicast to a group of clients at the same time has some disadvantages. First, it can be slower than multicast. Second, it's unfair since some will get the content before others.</para>

<para>Before you jump off to design a UDP multicast protocol, realize that it's not a simple calculation. When you send a multicast packet, the WiFi access point uses a low bit rate, to ensure that even the furthest devices will get it safely. Most normal APs don't do the obvious optimization, which is to measure the distance of the furthest device and use that bit rate. Instead they just use a fixed value. So if you have a few devices, close to the AP, multicast will be insanely slow. But if you have a roomful of devices which all want to get the next chapter of the textbook, multicast can be insanely effective.</para>

<para>The curves cross around 6-12 devices depending on the network. You could in theory measure the curves in real-time and create an adaptive protocol. That would be cool but probably too hard for even the smartest of us.</para>

<para>If you do sit down and sketch out a UDP multicast protocol, realize that you need a channel for recovery, to get lost packets. You'd probably want to do this over TCP, using &Oslash;MQ. For now, however, we'll forget about multicast UDP, and assume all traffic goes over TCP.</para>

</sect2>
</sect1>
<sect1>
<title>Spinning off a Library Project</title>
<para>At this stage however, the code is growing larger than an example should be, so it's time to create a proper GitHub project. It's a rule: build your projects in public view, and tell people about them as you go, so your marketing and community building starts on day 1. I'll walk through what this involves. I explained in The &Oslash;MQ Community<xref linkend="the-community"/> about growing communities around projects. We need a few things:</para>

<itemizedlist>
  <listitem><para>A name.</para></listitem>
  <listitem><para>A slogan.</para></listitem>
  <listitem><para>A public github repository.</para></listitem>
  <listitem><para>A README that links to the C4 process.</para></listitem>
  <listitem><para>License files.</para></listitem>
  <listitem><para>An issue tracker.</para></listitem>
  <listitem><para>Two maintainers.</para></listitem>
  <listitem><para>A first bootstrap version.</para></listitem>
</itemizedlist>
<para>The name and slogan first. The trademarks of the 21st century are domain names. So the first thing I do when spinning off a project is to look for a domain name that might work. Quite randomly, one of our old messaging products was called "Zyre" and I have the domain names for it. So, the "ZeroMQ Realtime Experience" project, which is a terribly forced construction but more or less accurate. We are aiming to create a framework for real time experiences (sharing games, photos, stories) over &Oslash;MQ.</para>

<para>I'm somewhat shy about pushing new projects into the &Oslash;MQ community too aggressively, and normally would start a project in either my personal account or the iMatix organization. But we've learned that moving projects after they become popular is counter-productive. My predictions of a future filled with moving pieces are either valid, or wrong. If this chapter is valid, we might as well launch this as a &Oslash;MQ project from the start. If it's wrong, we can delete the repository later or let it sink to the bottom of a long list of forgotten starts.</para>

<para>Start with the basics. The protocol (UDP and &Oslash;MQ/TCP) will be ZRE and the project will be ZyRE, with different capitalization to reduce confusion with the old project. I need a second maintainer, so invite my friend Dong Min (the Korean hacker behind JeroMQ, a pure-Java &Oslash;MQ stack) to join. He's been working on very similar ideas so is enthusiastic. We discuss this and we get the idea of building ZyRE on top of JeroMQ as well as on top of CZMQ and libzmq. This would make it a lot easier to run ZyRE on Android. It would also give us two fully separate implementations from the start, always a good thing for a protocol.</para>

<para>So we take the FileMQ project I built in The Human Scale<xref linkend="the-human-scale"/> as a template for a new GitHub project. The GNU autoconf tools are quite decent but have a painful syntax. It's easiest to copy existing project files, and modify them. The FileMQ project builds a library, has test tools, license files, man pages, and so on. It's not too large so it's a good starting point.</para>

<para>I put together a README to summarize the goals of the project and point to C4. The issue tracker is enabled by default on new GitHub projects, so once we've pushed the UDP ping code as a first version, we're ready to go. However it's always good to recruit more maintainers, so I create an issue "Call for maintainers" that says:</para>

<blockquote>
  <para>If you'd like to help click that lovely green "Merge Pull Request" button, and get eternal karma, add a comment confirming that you've read and understand the C4 process at http://rfc.zeromq.org/spec:16.</para>
</blockquote>
<para>Finally, I change the issue tracker labels. GitHub by default offers the usual variety of issue types but with C4 we don't use them. Instead we need just two labels ("Urgent", in red, and "Ready", in black).</para>

</sect1>
<sect1>
<title>Point-to-point Messaging</title>
<para>I'm going to take the last UDP ping program and build a point-to-point messaging layer on top of that. Our goal is that we can detect peers as they join and leave the network, that we can send messages to them, and that we can get replies. It is a non-trivial problem to solve and takes Min and me two days to get a "hello world" version working.</para>

<para>We had to solve a number of issues:</para>

<itemizedlist>
  <listitem><para>What information to send in the UDP beacon, and how to format it.</para></listitem>
  <listitem><para>What &Oslash;MQ socket types to use to interconnect nodes.</para></listitem>
  <listitem><para>What &Oslash;MQ messages to send, and how to format them.</para></listitem>
  <listitem><para>How to send a message to a specific node.</para></listitem>
  <listitem><para>How to know the sender of any message so we could send a reply.</para></listitem>
  <listitem><para>How to recover from lost UDP beacons.</para></listitem>
  <listitem><para>How to avoid overloading the network with beacons.</para></listitem>
</itemizedlist>
<para>I'll explain these in enough detail that you understand why we made each choice we did, with some code fragments to illustrate. We tagged this code as <ulink url="https://github.com/zeromq/zyre/zipball/v0.1.0">version 0.1.0</ulink> so you can look at the code: most of the hard work is done in zre_interface.c.</para>

<sect2>
<title>UDP Beacon Framing</title>
<para>Sending UUIDs across the network is the bare minimum for a logical addressing scheme. However we have a few more aspects to get working before this will work in real use:</para>

<itemizedlist>
  <listitem><para>We need some protocol identification so that we can check for, and reject invalid packets.</para></listitem>
  <listitem><para>We need some version information so that we can change this protocol over time.</para></listitem>
  <listitem><para>We need to tell other nodes how to reach us via TCP, i.e. a &Oslash;MQ port they can talk to us on.</para></listitem>
</itemizedlist>
<para>Let's start with the beacon message format. We probably want a fixed protocol header that will never change in future versions, and a body that depends on the version(<xref linkend="figure-72"/>).</para>

<figure id="figure-72">
    <title>ZRE discovery message</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig72.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>The version can be a 1-byte counter starting at 1. The UUID is 16 bytes, and the port is a 2-byte port number, since UDP nicely tells us the sender's IP address for every message we receive. This gives us a 22-byte frame.</para>

<para>The C language (and a few others like Erlang) make it simple to read and write binary structures. We define the beacon frame structure:</para>

<programlisting language="c">
#define BEACON_PROTOCOL     "ZRE"
#define BEACON_VERSION      0x01

typedef struct {
    byte protocol [3];
    byte version;
    uuid_t uuid;
    uint16_t port;
} beacon_t;
</programlisting>

<para>Which makes sending and receiving beacons quite simple. Here is how we send a beacon, using the zre_udp class to do the non-portable network calls:</para>

<programlisting language="c">
//  Beacon object
beacon_t beacon;

//  Format beacon fields
beacon.protocol [0] = 'Z';
beacon.protocol [1] = 'R';
beacon.protocol [2] = 'E';
beacon.version = BEACON_VERSION;
memcpy (beacon.uuid, self-&gt;uuid, sizeof (uuid_t));
beacon.port = htons (self-&gt;port);

//  Broadcast the beacon to anyone who is listening
zre_udp_send (self-&gt;udp, (byte *) &amp;beacon, sizeof (beacon_t));
</programlisting>

<para>When we receive a beacon we need to guard against bogus data. We're not going to be paranoid against, for example, denial-of-service attacks. We just want to make sure we're not going to crash when a bad ZRE implementation sends us erroneous frames.</para>

<para>To validate a frame we check its size and header. If those are OK, we assume the body is usable. When we get a UUID that isn't ourselves (recall, we'll get our own UDP broadcasts back), we can treat this as a peer:</para>

<programlisting language="c">
//  Get beacon frame from network
beacon_t beacon;
ssize_t size = zre_udp_recv (self-&gt;udp, (byte *) &amp;beacon, sizeof (beacon_t));

//  Basic validation on the frame
if (size != sizeof (beacon_t)
||  beacon.protocol [0] != 'Z'
||  beacon.protocol [1] != 'R'
||  beacon.protocol [2] != 'E'
||  beacon.version != BEACON_VERSION)
    return 0;               //  Ignore invalid beacons

//  If we got a UUID and it's not our own beacon, we have a peer
if (memcmp (beacon.uuid, self-&gt;uuid, sizeof (uuid_t))) {
    char *identity = s_uuid_str (beacon.uuid);
    s_require_peer (self, identity,
        zre_udp_from (self-&gt;udp), ntohs (beacon.port));
    free (identity);
}
</programlisting>

</sect2>
<sect2>
<title>True Peer Connectivity (Harmony Pattern)</title>
<para>Since &Oslash;MQ is designed to make distributed messaging easy, people often ask how to interconnect a set of true peers (as compared to obvious clients and servers). It is a thorny question and &Oslash;MQ doesn't really provide a single clear answer.</para>

<para>TCP, which is the most commonly-used transport in &Oslash;MQ, is not symmetric; one side must bind and one must connect and though &Oslash;MQ tries to be neutral about this, it's not. When you connect, you create an outgoing message pipe. When you bind, you do not. When there is no pipe, you cannot write messages (&Oslash;MQ will return EAGAIN).</para>

<para>Developers who study &Oslash;MQ and then try to create N-to-N connections between sets of equal peers often try a ROUTER-to-ROUTER flow. It's obvious why: each peer needs to address a set of peers, which requires ROUTER. It usually ends with a plaintive email to the list.</para>

<para>My conclusion after trying several times from different angles is that ROUTER-to-ROUTER does not work. At a minimum, because one peer must bind and one must connect, meaning the architecture is not symmetrical. But also because you simply can't tell when you are allowed to safely send a message to a peer. It's Catch-22: you can talk to a peer after it's talked to you. But the peer can't talk to you until you've talked to it. One side or the other will be losing messages and thus has to retry, which means the peers cannot be equal.</para>

<para>I'm going to explain the Harmony pattern, which solves this problem, and which we use in ZyRE.</para>

<para>We want a guarantee that when a peer "appears" on our network, we can talk to it safely, without &Oslash;MQ dropping messages. For this, we have to use a DEALER or PUSH socket which <emphasis>connects out to the peer</emphasis> so that even if that connection takes some non-zero time, there is immediately a pipe, and &Oslash;MQ will accept outgoing messages.</para>

<para>A DEALER socket cannot address multiple peers individually. But if we have one DEALER per peer, and we connect that DEALER to the peer, we can safely send messages to a peer as soon as we've connected to it.</para>

<para>Now, the next problem is to know who sent us a particular message. We need a reply address, that is the UUID of the node who sent any given message. DEALER can't do this unless we prefix every single message with that 16-byte UUID, which would be wasteful. ROUTER does, if we set the identity properly before connecting to the router.</para>

<para>And so the Harmony pattern comes down to:</para>

<itemizedlist>
  <listitem><para>One ROUTER socket that we bind to a transient port, which we broadcast in our beacons.</para></listitem>
  <listitem><para>One DEALER socket <emphasis>per peer</emphasis> that we connect to the peer's ROUTER socket.</para></listitem>
  <listitem><para>Reading from our ROUTER socket.</para></listitem>
  <listitem><para>Writing to the peer's DEALER socket.</para></listitem>
</itemizedlist>
<para>Next problem is that discovery isn't neatly synchronized. We can get the first beacon from a peer <emphasis>after</emphasis> we start to receive messages from it. A message comes in on the ROUTER socket and has a nice UUID attached to it. But no physical IP address and port. We have to force discovery over TCP. To do this, our first command to any new peer we connect to is an OHAI command with our IP address and port. This ensure that the receiver connects back to us before trying to send us any command.</para>

<para>Breaking this down into steps:</para>

<itemizedlist>
  <listitem><para>If we receive a UDP beacon we connect to the peer.</para></listitem>
  <listitem><para>We read messages from our ROUTER socket, and each message comes with the UUID of the sender.</para></listitem>
  <listitem><para>If it's an OHAI message we connect back to that peer if not already connected to it.</para></listitem>
  <listitem><para>If it's any other message, we <emphasis>must</emphasis> already be connected to the peer (a good place for an assertion).</para></listitem>
  <listitem><para>We send messages to each peer using a dedicated per-peer DEALER socket, which <emphasis>must</emphasis> be connected.</para></listitem>
  <listitem><para>When we connect to a peer we also tell our application that the peer exists.</para></listitem>
  <listitem><para>Every time we get a message from a peer, we treat that as a heartbeat (it's alive).</para></listitem>
</itemizedlist>
<para>If we were not using UDP but some other discovery mechanism, I'd still use the Harmony pattern for a true peer network: one ROUTER for input from all peers, and one DEALER per peer for output. Bind the ROUTER, connect the DEALER, and start each conversation with an OHAI equivalent that provides the return IP address and port. You would need some external mechanism to bootstrap each connection.</para>

</sect2>
<sect2>
<title>Detecting Disappearances</title>
<para>Heartbeating sounds simple but it's not. UDP packets get dropped when there's a lot of TCP traffic, so if we depend on UDP beacons we'll get false disconnections. TCP traffic can be delayed for five, ten, 30 seconds if the network is really busy. So if we kill peers when they go quiet, we'll have false disconnections.</para>

<para>Since UDP beacons aren't reliable, it's tempting to add in TCP beacons. After all, TCP will deliver them reliably. One little problem. Imagine you have 100 nodes on a network, and each node sends a TCP beacon once a second. Each beacon is 22 bytes not counting TCP's framing overhead. That is 100 * 99 * 22 bytes per second, or 217,000 bytes/second just for heartbeating. That's about 1-2% of a typical WiFi network's ideal capacity, which sounds OK. But when a network is stressed, or fighting other networks for airspace, that extra 200K a second will break what's left. UDP broadcasts are at least low cost.</para>

<para>So what we do is switch to TCP heartbeats only when a specific peer hasn't sent us any UDP beacons in a while. And then, we send TCP heartbeats only to that one peer. If the peer continues to be silent, we conclude it's gone away. If the peer comes back, with a different IP address and/or port, we have to disconnect our DEALER socket and reconnect to the new port.</para>

<para>This gives us a set of states for each peer, though at this stage the code doesn't use a formal state machine:</para>

<itemizedlist>
  <listitem><para>Peer visible thanks to UDP beacon (we connect using IP address and port from beacon)</para></listitem>
  <listitem><para>Peer visible thanks to OHAI command (we connect using IP address and port from command)</para></listitem>
  <listitem><para>Peer seems alive (we got a UDP beacon or command over TCP recently)</para></listitem>
  <listitem><para>Peer seems quiet (no activity in some time, so we send a HUGZ command)</para></listitem>
  <listitem><para>Peer has disappeared (no reply to our HUGZ commands, so we destroy peer)</para></listitem>
</itemizedlist>
<para>There's one remaining scenario we didn't address in the code at this stage. It's possible for a peer to change IP addresses and ports without actually triggering a disappearance event. For example if the user switches off WiFi and then switches it back on, then the the access point can assign the peer a new IP address. We'll need to handle a disappeared WiFi interface on our node by unbinding the ROUTER socket and rebinding it when we can. Since this is not central to the design now, I decide to log an issue on the GitHub tracker and leave it for a rainy day.</para>

</sect2>
</sect1>
<sect1>
<title>Group Messaging</title>
<para>Group messaging is a common and very useful pattern. The concept is simple: instead of talking to a single node, you talk to a "group" of nodes. The group is just a name, a string that you agree on in the application. It's precisely like using the publish-subscribe prefixes in PUB and SUB sockets. In fact the only reason I say "group messaging" and not "pub-sub" is to prevent confusion, since we're not going to use PUB/SUB sockets for this.</para>

<para>PUB/SUB would almost work. But we've just done such a lot of work to solve the late joiner problem. Applications are inevitably going to wait for peers to arrive before sending messages to groups, so we have to build on the Harmony pattern rather than start again beside it.</para>

<para>Let's look at the operations we want to do on groups:</para>

<itemizedlist>
  <listitem><para>We want to join and leave groups.</para></listitem>
  <listitem><para>We want to know what other nodes are in any given group.</para></listitem>
  <listitem><para>We want to send a message to (all nodes in) a group.</para></listitem>
</itemizedlist>
<para>Which look familiar to anyone who's used Internet Relay Chat, except we have no server. Every node will need to keep track of what each group represents. This information will not always be fully consistent across the network but it will be close enough.</para>

<para>Our interface will track a set of groups (each an object). These are all the known groups with one or more member node, excluding ourselves. We'll track nodes as they leave and join groups. Since nodes can join the network at any time, we have to tell new peers what groups we're in. When a peer disappears, we'll remove it from all groups we know about.</para>

<para>This gives us some new protocol commands:</para>

<itemizedlist>
  <listitem><para>JOIN - we send this to all peers when we join a group.</para></listitem>
  <listitem><para>LEAVE - we send this to all peers when we leave a group.</para></listitem>
</itemizedlist>
<para>Plus, we add a 'groups' field to the first command we send (renamed from OHAI to HELLO at this point because I need a larger lexicon of command verbs).</para>

<para>Lastly, let's add a way for peers to double-check the accuracy of their group data. The risk is that we miss one of the above messages. Though we are using Harmony to avoid the typical message loss at startup, it's worth being paranoid. For now, all we need is a way to detect such a failure. We'll deal with recovery later, if the problem actually happens.</para>

<para>I'll use the UDP beacon for this. What we want is a rolling counter that simply tells how many join and leave operations ("transitions") there have been for a node. It starts at 0 and increments for each group we join or leave. We can use a minimal 1-byte value since that will catch all failures except the astronomically rare "we lost precisely 256 messages in a row" failure (this is the one that hits during the first demo). We will also put the transitions counter into the JOIN, LEAVE, and HELLO commands. And to try to provoke the problem, we'll test by joining/leaving several hundred groups, with a high-water mark set to 10 or so.</para>

<para>Time to choose verbs for the group messaging. We need a command that means "talk to one peer" and one that means "talk to many peers". After some attempts, my best choices are "WHISPER" and "SHOUT", and this is what the code uses. The SHOUT command needs to tell the user the group name, as well as the sender peer.</para>

<para>Since groups are like publish-subscribe, you might be tempted to use this to broadcast the JOIN and LEAVE commands as well, perhaps by creating a "global" group that all nodes join. My advice is to keep groups purely as user-space concepts for two reasons. First, how do you join the global group if you need the global group to send out a JOIN command? Second, it creates special cases ('reserved names') which are messy.</para>

<para>It's simpler just to send JOINs and LEAVEs explicitly to all connected peers, period.</para>

<para>I'm not going to work through the implementation of group messaging in detail since it's fairly pedantic and not exciting. The data structures for group and peer management aren't optimal but they're workable. We need:</para>

<itemizedlist>
  <listitem><para>A list of groups for our interface, which we can send to new peers in a HELLO command;</para></listitem>
  <listitem><para>A hash of groups for other peers, which we update with information from HELLO, JOIN, and LEAVE commands;</para></listitem>
  <listitem><para>A hash of peers for each group, which we update with the same three commands.</para></listitem>
</itemizedlist>
<para>At this stage I'm starting to get pretty happy with the binary serialization (our codec generator from The Human Scale<xref linkend="the-human-scale"/>), which handles lists and dictionaries as well as strings and integers.</para>

<para>This version is tagged in the repository as v0.2.0 and you can [<ulink url="https://github.com/zeromq/zyre/tags">download the tarball</ulink> if you want to check what the code looked like at this stage.</para>

</sect1>
<sect1>
<title>Testing and Simulation</title>
<sect2>
<title>On Assertions</title>
<para>The proper use of assertions is one of the hallmarks of a professional programmer.</para>

<para>Our confirmation bias as creators makes it hard to test our work properly. We tend to write tests to prove the code works, rather than trying to prove it doesn't. There are many reasons for this. We pretend to ourselves and others that we can be (could be) perfect, when in fact we consistently make mistakes. Bugs in code are seen as "bad", rather than "inevitable", so psychologically we want to see fewer of them, not uncover more of them. "He writes perfect code" is a compliment rather than a euphemism for "he never takes risks so his code is as boring and heavily used as cold spaghetti".</para>

<para>Some cultures teach us to aspire to perfection, and punish mistakes, in education and work, which makes this attitude worse. To accept that we're fallible, and then to learn how to turn that into profit rather than shame is one of the hardest intellectual exercises, in any profession. We leverage our fallibilities by working with others, and by challenging our own work sooner, not later.</para>

<para>One trick that makes it easier is to use assertions. Assertions are not a form of error handling. They are executable theories of fact. The code asserts, "at this point, such and such must be true" and if the assertion fails, the code kills itself.</para>

<para>The faster you can prove code incorrect, the faster and more accurately you can fix it. Believing that code works and proving that it behaves as expected is less science, and more magical thinking. It's far better to be able to say, "libzmq has five hundred assertions and despite all my efforts, not one of them fails".</para>

<para>So the ZyRE code base is scattered with assertions, and particularly a couple on the code that deals with the state of peers. This is the hardest aspect to get right: peers need to track each other and exchange state accurately, or things stop working. The algorithms depends on asynchronous messages flying around and I'm pretty sure the initial design has flaws. They always do.</para>

<para>And as I test the original ZyRE code by starting and stopping instances of zre_ping by hand, every so often I get an assertion failure. Running by hand doesn't reproduce these often enough, so let's make a proper tester tool.</para>

</sect2>
<sect2>
<title>On Up-front Testing</title>
<para>Being able to fully test the real behavior of individual components in the laboratory can make a 10x or 100x difference to the cost of your project. That confirmation bias engineers have to their own work makes upfront testing incredibly profitable, and late-stage testing incredibly expensive.</para>

<para>I'll tell you a short story about a project we worked on in the late 1990's. We provided the software, and other teams the hardware, for a factory automation project. Three or four teams brought their experts on-site, which was a remote factory (funny how the polluting factories are always in remote border country).</para>

<para>One of these teams, a firm specializing in industrial automation, built ticket machines: kiosks, and software to run on them. Nothing unusual: swipe a badge, choose an option, receive a ticket. They assembled two of these kiosks, on-site, each week bringing some more bits and pieces. Ticket printers, monitor screens, special keypads from Israel. The stuff had to be resistant against dust since the kiosks sat outside. Nothing worked. The screens were unreadable in the sun. The ticket printers continually jammed and misprinted. The internals of the kiosk were just sat on wooden shelving. The kiosk software crashed regularly. It was comedic except that the project really, <emphasis>really</emphasis> had to work and so we spent weeks and then months on-site helping the other teams debug their bits and pieces until it worked.</para>

<para>A year later, a second factory, and the same story. By this time the client was getting impatient. So when they came to the third and largest factory, a year later, we jumped up and said, "please let us make the kiosks and the software and everything".</para>

<para>So we made a detailed design for the software and hardware and found suppliers for all the pieces. It took us three months to search the Internet for each component, and another two months to get them assembled into stainless-steel bricks each weighing about twenty kilos. These bricks were 60cm square and 20cm deep, with a large flat-screen panel behind unbreakable glass, and two connectors: one for power, one for Ethernet. You loaded up the paper bin with enough for six months, then screwed the brick into a housing, and it automatically booted, found its DNS server, loaded its Linux OS and then application software. It connected to the real server, and showed the main menu. You got access to the configuration screens by swiping a special badge and then entering a code.</para>

<para>The software was portable so we could test that as we wrote it, and as we collected the pieces from our suppliers we kept one of each so we had a disassembled kiosk to play with. When we got our finished kiosks, they all worked immediately. We shipped them to the client, who plugged them into their housing, switched them on, and went to business. We spent a week or so on site, and in ten years, one kiosk broke (the screen died, and was replaced).</para>

<para>Lesson is, test up-front so that when you plug the thing in, you know precisely how it's going to behave. If you haven't tested it up-front, you're going to be spending weeks and months in the field, ironing out problems that should never have been there.</para>

</sect2>
<sect2>
<title>The ZyRE Tester</title>
<para>During manual testing I did hit an assertion rarely. It then disappeared. Since I don't believe in magic, that means the code is still wrong somewhere. So, next step is heavy-duty testing of the ZyRE 0.2.0 code to try to break its assertions, and get a good idea of how it will behave in the field.</para>

<para>We packaged the discovery and messaging functionality as an 'interface' object that the main program creates, works with, and then destroys. We don't use any global variables. This makes it easy to start large numbers of interfaces and simulate real activity, all within one process. And if there's one thing we've learned from writing lots of examples, it's that &Oslash;MQ's ability to orchestrate multiple threads in a single process is <emphasis>much</emphasis> easier to work with than multiple processes.</para>

<para>The first version of the tester consists of a main thread which starts and stops a set of child threads, each running one interface, each with a ROUTER, DEALER, and UDP socket ('R', 'D', and 'U' in the diagram)(<xref linkend="figure-73"/>).</para>

<figure id="figure-73">
    <title>ZyRE Tester Tool</title>
    <mediaobject>
        <imageobject>
            <imagedata fileref="images/fig73.eps" format="EPS" width="4.8in"/>
        </imageobject>
    </mediaobject>
</figure>

<para>The nice thing is that when I am connected to a WiFi access point, all ZyRE traffic (even between two interfaces in the same process) goes across the AP. This means I can fully stress test any WiFi infrastructure with just a couple of PCs running in a room. It's hard to emphasize how valuable this is: if we had built ZyRE as, say, a dedicated service for Android, we'd literally need dozens of Android tablets or phones to do any large-scale testing. Kiosks, and all that.</para>

<para>The focus is now on breaking the current code, trying to prove it wrong. There's <emphasis>no point</emphasis> at this stage in testing how well it runs, how fast it is, how much memory it uses, or anything else. We'll work up to trying (and failing) to break each individual functionality but first, we try to break some of the core assertions I've put into the code.</para>

<para>These are:</para>

<itemizedlist>
  <listitem><para>The first command that any node receives from a peer MUST be "HELLO". In other words, messages <emphasis>cannot</emphasis> be lost during the peer-to-peer connection process.</para></listitem>
  <listitem><para>The state each node each node calculates for its peers matches the state each peer calculates for itself. In other words, again, no messages are lost in the network.</para></listitem>
  <listitem><para>When my application sends a message to a peer, we have a connection to that peer. In other words, the application only "sees" a peer after we have established a &Oslash;MQ connection to it.</para></listitem>
</itemizedlist>
<para>With &Oslash;MQ, there are several cases we may lose messages. One is when the "late joiner" syndrome. Two is when we close sockets without sending everything. Three is when we overflow the high-water mark on a ROUTER or PUB socket. Four is when we use an unknown address with a ROUTER socket.</para>

<para>Now, I <emphasis>think</emphasis> Harmony gets around all these potential cases. But we're also adding UDP to the mix. So the first version of the tester simulates an unstable and dynamic network, where nodes come and go randomly. It's here that things will break.</para>

<para>Here is the main thread of the tester, which manages a pool of 100 threads, starting and stopping each one randomly. Every ~750 msecs it either starts or stops one random thread. We randomize the timing so that threads aren't all synchronized. After a few minutes we have an average of 50 threads happily chatting to each other like Korean teenagers in Gangnam subway station:</para>

<programlisting language="c">
int main (int argc, char *argv [])
{
    //  Initialize context for talking to tasks
    zctx_t *ctx = zctx_new ();
    zctx_set_linger (ctx, 100);

    //  Get number of interfaces to simulate, default 100
    int max_interface = 100;
    int nbr_interfaces = 0;
    if (argc &gt; 1)
        max_interface = atoi (argv [1]);

    //  We address interfaces as an array of pipes
    void **pipes = zmalloc (sizeof (void *) * max_interface);

    //  We will randomly start and stop interface threads
    while (!zctx_interrupted) {
        uint index = randof (max_interface);
        //  Toggle interface thread
        if (pipes [index]) {
            zstr_send (pipes [index], "STOP");
            zsocket_destroy (ctx, pipes [index]);
            pipes [index] = NULL;
            zclock_log ("I: Stopped interface (%d running)", --nbr_interfaces);
        }
        else {
            pipes [index] = zthread_fork (ctx, interface_task, NULL);
            zclock_log ("I: Started interface (%d running)", ++nbr_interfaces);
        }
        //  Sleep ~750 msecs randomly so we smooth out activity
        zclock_sleep (randof (500) + 500);
    }
    zctx_destroy (&amp;ctx);
    return 0;
}
</programlisting>

<para>Note that we maintain a 'pipe' to each child thread (CZMQ creates the pipe automatically when we use the zthread_fork() method). It's via this pipe that we tell child threads to stop, when it's time for them to leave. The child threads do the following (I'm switching to pseudo-code for clarity):</para>

<screen>create an interface
while true:
    poll on pipe to parent, and on interface
    if parent sent us a message:
        break
    if interface sent us a message:
        if message is ENTER:
            send a WHISPER to the new peer
        if message is EXIT:
            send a WHISPER to the departed peer
        if message is WHISPER:
            send back a WHISPER 1/2 of the time
        if message is SHOUT:
            send back a WHISPER 1/3 of the time
            send back a SHOUT 1/3 of the time
    once per second:
        join or leave one of 10 random groups
destroy interface
</screen>

</sect2>
<sect2>
<title>Test Results</title>
<para>Yes, we broke the code. Several times, in fact. This was satisfying. I'll work through the different things we found.</para>

<para>Getting nodes to agree on consistent group status was the most difficult. Every node needs to track the group membership of the whole network, as I already explained in the section "Group Messaging". Group messaging is a publish-subscribe pattern. JOINs and LEAVEs are analogous to 'subscribe' and 'unsubscribe' messages. It's essential none of these ever get lost, or we'll find nodes dropping randomly off groups.</para>

<para>So each node counts the total number of JOINs and LEAVEs it's ever done, and broadcasts this status (as 1-byte rolling counter) in its UDP beacon. Other nodes pick up the status, compare it to their own calculations, and if there's a difference, the code asserts.</para>

<para>First problem was that UDP beacons get delayed randomly, so they're useless for carrying the status. When a beacons arrives late, the status is inaccurate and we get a 'false negative'. To fix this we moved the status information into the JOIN and LEAVE commands. We also added it to the HELLO command. The logic then becomes:</para>

<itemizedlist>
  <listitem><para>Get initial status for a peer from its HELLO command.</para></listitem>
  <listitem><para>When getting a JOIN or LEAVE from a peer, increment the status counter.</para></listitem>
  <listitem><para>Check that the new status counter matches the value in the JOIN or LEAVE command</para></listitem>
  <listitem><para>If it doesn't, assert.</para></listitem>
</itemizedlist>
<para>Next problem we got was that messages were arriving unexpectedly on new connections. The Harmony pattern connects, then sends HELLO as the first command. This means the receiving peer should always get HELLO as the first command from a new peer. We were seeing PING, JOIN, and other commands arriving.</para>

<para>This turned out to be due to CZMQ's ephemeral port logic. An ephemeral port is just a dynamically assigned port that a service can get rather than asking for a fixed port number. A POSIX system usually assigns ephemeral ports in the range 0xC000 to 0xFFFF. CZMQ's logic is to look for a free port in this range, bind to that, and return the port number to the calller.</para>

<para>Which sounds fine, until you get one node stopping and another node starting, close together, and the new node getting the port number of the old node. Remember that &Oslash;MQ tries to re-establish a broken connection. So when the first node stopped, its peers would retry to connect. When the new node appears on that same port, suddenly all the peers connect to it, and start chatting like they're old buddies.</para>

<para>It's a general problem that affects any larger-scale dynamic &Oslash;MQ application. There are a number of plausible answers. One is to not reuse ephemeral ports, which is easier said than done when you have multiple processes on one system. Another solution would be to select a random port each time, which at least reduces the risk of hitting a just-freed port. This brings the risk of a garbage connection down to perhaps 1/1000 but it's still there. Perhaps the best solution is to accept that this can happen, understand the causes, and deal with it on the application level.</para>

<para>We have a stateful protocol that always starts with a HELLO command. We know that it's possible for peers to connect to us, thinking we're an existing node that went away and came back, and send us other commands. Step one is when we discover a new peer, to destroy any existing peer connected to the same endpoint. It's not a full answer but it's polite, at least. Step two is to ignore anything coming in from a new peer until that peer says HELLO.</para>

<para>This doesn't require any change to the protocol but it has to be specified in the protocol when we come to it: due to the way &Oslash;MQ connections work, it's possible to receive unexpected commands from a <emphasis>well-behaving</emphasis> peer and there is no way to return an error code, or otherwise tell that peer to reset its connection. Thus, a peer must discard any command from a peer until it receives HELLO.</para>

<para>In fact, if you draw this on a piece of paper and think it through, you'll see that you never get a HELLO from such a connection. The peer will send PINGs and JOINs and LEAVEs and then eventually time-out and close, as it fails to get any heartbeats back from us.</para>

<para>You'll also see that there's no risk of confusion, no way for commands from two peers to get mixed into a single stream on our DEALER socket.</para>

<para>When you are satisfied this works, we're ready to move on. This version is tagged in the repository as v0.3.0 and you can [<ulink url="https://github.com/zeromq/zyre/tags">download the tarball</ulink> if you want to check what the code looked like at this stage.</para>

<para>Note that doing heavy simulation of lots of nodes will probably cause your process to run out of file handles, giving an assertion failure in libzmq. I raised the per-process limit to 30,000 by running (on my Linux box):</para>

<screen>ulimit -n 30000
</screen>

</sect2>
<sect2>
<title>Tracing Activity</title>
<para>To debug the kinds of problems we saw here, we need extensive logging. There's a lot happening in parallel but every problem can be traced down to a specific exchange between two nodes, consisting of a set of events that happen in strict sequence. We know how to make very sophisticated logging but as usual it's wiser to make just what we need, no more. We have to capture:</para>

<itemizedlist>
  <listitem><para>Time and date for each event.</para></listitem>
  <listitem><para>In which node the event occurred.</para></listitem>
  <listitem><para>The peer node, if any.</para></listitem>
  <listitem><para>What the event was (e.g. which command arrived).</para></listitem>
  <listitem><para>Event data, if any.</para></listitem>
</itemizedlist>
<para>The very simplest technique is to print the necessary information to the console, with a timestamp. That's the approach I used. Then it's simple to find the nodes affected by a failure, filter the log file for only messages referring to them, and see exactly what happened.</para>

</sect2>
<sect2>
<title>Dealing with Blocked Peers</title>
<para>In any performance-sensitive &Oslash;MQ architecture you need to solve the problem of flow control. You cannot simply send unlimited messages to a socket and hope for the best. At the one extreme, you can exhaust memory. This is a classic failure pattern for a message broker: one slow client stops receiving messages; the broker starts to queue them, and eventually exhausts memory and the whole process dies. At the other extreme, the socket drops messages, or blocks, as you hit the high-water mark.</para>

<para>With ZyRE we want to distribute messages to a set of peers, and we want to do this fairly. Using a single ROTER socket for output would be problematic since any one blocked peer would block outgoing traffic to all peers. TCP does have good algorithms for spreading the network capacity across a set of connections. And we're using a separate DEALER socket to talk to each peer, so in theory each DEALER socket will send its queued messages in the background reasonably fairly.</para>

<para>The normal behavior of a DEALER socket that hits its high-water mark is to block. This is usually ideal, but it's a problem for us here. Our current interface design uses one thread that distributes messages to all peers. If one of those send calls were to block, all output would block.</para>

<para>There are a few options to avoid blocking. One is to use <literal>zmq_poll()</literal> on the whole set of DEALER sockets, and only write to sockets that are ready. I don't like this for a couple of reasons. First, the DEALER socket is hidden inside the peer class, and it is cleaner to allow each class to handle this opaquely. Second, what do we do with messages we can't yet deliver to a DEALER socket? Where do we queue them? Third, it seems to be side-stepping the issue. If a peer is really so busy it can't read its messages, something is wrong. Most likely, it's dead.</para>

<para>So no polling for output. The second option is to use one thread per peer. I quite like the idea of this, since it fits into the &Oslash;MQ design pattern of "do one thing in one thread". But this is going to create a <emphasis>lot</emphasis> of threads (square of the number of nodes we start) in the simulation, and we're already running out of file handles.</para>

<para>A third option is to use a non-blocking send. This is nicer and it's the solution I choose. We can then provide each peer with a reasonable outgoing queue (the HWM) and if that gets full, treat it as a fatal error on that peer. This will work for smaller messages. If we're sending large chunks -- e.g. for file transfer -- we'll need a credit-based flow control on top.</para>

<para>First step therefore is to prove to ourselves that we can turn the normal blocking DEALER socket into a non-blocking socket. This example creates a normal DEALER socket, connects it to some endpoint (so there's an outgoing pipe and the socket will accept messages), sets the high-water mark to four, and then sets the send timeout to zero:</para>

<example id="eagain-c">
<title>Checking EAGAIN on DEALER socket (eagain.c)</title>
<programlisting language="c">
//
//  Shows how to provoke EAGAIN when reaching HWM
//
#include &lt;czmq.h&gt;

int main (void) {
    zctx_t *ctx = zctx_new ();
    
    void *mailbox = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_set_sndhwm (mailbox, 4);
    zsocket_set_sndtimeo (mailbox, 0);
    zsocket_connect (mailbox, "tcp://localhost:9876");

    int count;
    for (count = 0; count &lt; 10; count++) {
        printf ("Sending message %d\n", count);
        int rc = zstr_sendf (mailbox, "message %d", count);
        if (rc == -1) {
            printf ("%s\n", strerror (errno));
            break;
        }
    }
    zctx_destroy (&amp;ctx);
    return 0;
}
</programlisting>

</example>
<para>When we run this, we send four messages successfully (they go nowhere, the socket just queues them), and then we get a nice EAGAIN error:</para>

<screen>Sending message 0
Sending message 1
Sending message 2
Sending message 3
Sending message 4
Resource temporarily unavailable
</screen>

<para>Next step is to decide what a reasonable high water mark would be for a peer. ZyRE is meant for human interactions, that is applications which chat at a low frequency. Perhaps two games, or a shared drawing program. I'd expect a hundred messages per second to be quite a lot. Our "peer is really dead" timeout is 10 seconds. So a high-water mark of 1,000 seems fair.</para>

<para>Rather than set a fixed HWM, or use the default (which randomly also happens to be 1,000) we calculate it as 100 * the timeout. Here's how we configure a new DEALER socket for a peer:</para>

<programlisting language="c">
//  Create new outgoing socket (drop any messages in transit)
self-&gt;mailbox = zsocket_new (self-&gt;ctx, ZMQ_DEALER);

//  Set our caller 'From' identity so that receiving node knows
//  who each message came from.
zsocket_set_identity (self-&gt;mailbox, reply_to);

//  Set a high-water mark that allows for reasonable activity
zsocket_set_sndhwm (self-&gt;mailbox, PEER_EXPIRED * 100);

//  Send messages immediately or return EAGAIN
zsocket_set_sndtimeo (self-&gt;mailbox, 0);

//  Connect through to peer node
zsocket_connect (self-&gt;mailbox, "tcp://%s", endpoint);
</programlisting>

<para>And finally, what do we do when we get an EAGAIN on a peer? We don't need to go through all the work of destroying the peer since the interface will do this automatically if it doesn't get any message from the peer within the expiry timeout. Just dropping the last message seems very weak - it will give the receiving peer gaps.</para>

<para>I'd rather a more brutal response. Brutal is good because it forces the design to a "good" or "bad" decision rather than a fuzzy "should work but to be honest there are a lot of edge cases so let's worry about it later". Destroy the socket, disconnect the peer, and stop sending anything to it. The peer will eventually have to reconnect and re-initialize any state. It's kind of an assertion that 100 messages a second is enough for anyone. So, in the zre_peer_send method:</para>

<programlisting language="c">
int
zre_peer_send (zre_peer_t *self, zre_msg_t **msg_p)
{
    assert (self);
    if (self-&gt;connected) {
        if (zre_msg_send (msg_p, self-&gt;mailbox) &amp;&amp; errno == EAGAIN) {
            zre_peer_disconnect (self);
            return -1;
        }
    }
    return 0;
}
</programlisting>

<para>Where the disconnect method looks like this:</para>

<programlisting language="c">
void
zre_peer_disconnect (zre_peer_t *self)
{
    //  If connected, destroy socket and drop all pending messages
    assert (self);
    if (self-&gt;connected) {
        zsocket_destroy (self-&gt;ctx, self-&gt;mailbox);
        free (self-&gt;endpoint);
        self-&gt;endpoint = NULL;
        self-&gt;connected = false;
    }
}
</programlisting>

</sect2>
</sect1>
<sect1>
<title>More Coming Soon</title>
<para>In the rest of this chapter we'll develop a distributed logging service as a ZyRE application, and we'll complete the rest of the ZyRE framework: file transfer, security, state synchronization.</para>

</sect1>
</chapter>
<chapter id="postface">
<title>Postface</title>
<sect1>
<title>Tales from Out There</title>
<para>I asked some of the contributors to the Guide to tell us what they were doing with &Oslash;MQ. Here are their stories.</para>

<sect2>
<title>Rob Gagnon's Story</title>
<para>"We use &Oslash;MQ to assist in aggregating thousands of events occurring every minute across our global network of telecommunications servers so that we can accurately report and monitor for situations that require our attention. &Oslash;MQ made the development of the system not only easier, but faster to develop, and more robust and fault-tolerant than we had originally planned in our original design.</para>

<para>"We're able to easily add and remove clients from the network without the loss of any message. If we need to enhance the server portion of our system, we can stop and restart it as well, without having to worry about stopping all of the clients first. The built-in buffering of &Oslash;MQ makes this all possible."</para>

</sect2>
<sect2>
<title>Tom van Leeuwen's Story</title>
<para>"I was looking for creating some kind of service bus connecting all kinds of services together. There were already some products that implemented a broker, but they did not have the functionality I wanted/needed. By accident I stumbled upon &Oslash;MQ which is awesome. It's very lightweight, lean, simple and easy to follow since the zguide is very complete and reads very well. I've actually implemented the Titanic pattern and the Majordomo broker with some additions (client/worker authentication and workers sending a catalog explaining what they provide and how they should be addressed).</para>

<para>"The beautiful thing about &Oslash;MQ is the fact that it is a library and not an application. You can mold it however you like and it simply puts boring things like queuing, reconnecting, tcp sockets and such to the background, making sure you can concentrate on what is important for you. I've implemented all kinds of workers/clients and the broker in Ruby, because that is the main language we use for development, but also some php clients to connect to the bus from existing php webapps. We use this service bus for cloud services connecting all kinds of platform devices to a service bus exposing functionality for automation.</para>

<para>"&Oslash;MQ is very easy to understand and if you spend a day in the zguide, you'll have good knowledge of how it works. I'm a network engineer, not a software developer, but managed to create a very nice solution for our automation needs! &Oslash;MQ: Thank you very much!"</para>

</sect2>
<sect2>
<title>Michael Jakl's Story</title>
<para>"We use &Oslash;MQ for distributing millions of documents per day in our distributed processing pipeline. We started out with big message queuing brokers that had their own respective issues and problems. In the quest of simplifying our architecture, we chose &Oslash;MQ to do the wiring. So far it had a huge impact in how our architecture scales and how easy it is to change/move the components. The plethora of language bindings lets us choose the right tool for the job without sacrificing interoperability in our system. We don't use a lot of sockets (less than 10 in our whole application), but that's all we needed to split a huge monolithic application into small independent parts.</para>

<para>"All in all, &Oslash;MQ lets me keep my sanity and helps my customers to stay within budget."</para>

</sect2>
<sect2>
<title>Vadim Shalts's Story</title>
<para>"I am team leader in the company ActForex, which develops software for financial markets. Due to the nature of our domain, we need to process large volumes of prices quickly. In addition, it's extremely critical to minimize latency in processing orders and prices. Achieve a high throughput is not enough. Everything must be handled in a soft real-time with a predictable ultra low latency per price. The system consists of multiple components which exchanging messages. Each price can take a lot of processing stages, each of which increases total latency. As a consequence, low and predictable latency of messaging between components becomes a key factor of our architecture.</para>

<para>"We investigated different solutions to find suitable for our needs. We tried different message brokers (RabbitMQ, ActiveMQ Apollo, Kafka), but failed to reach a low and predictable latency with any of them. In the end, we have chosen ZeroMQ used in conjunction with ZooKeeper for service discovery. Complex coordination with ZeroMQ requires a relatively large effort and a good understanding, as a result of the natural complexity of multi-threading. We found that external agent like ZooKeeper is better choice for service discovery and coordination while ZeroMQ can be used primary for simple messaging. ZeroMQ perfectly fit into our architecture. It allowed us to achieve the desired latency using minimal efforts. It saved us from a bottleneck in the processing of messages and made processing time very stable and predictable.</para>

<para>"I can decidedly recommend ZeroMQ for solutions where low latency is important."</para>

</sect2>
</sect1>
<sect1>
<title>How the Guide Happened</title>
<para>When I set out to write the Guide, we were still debating the pros and cons of forks and pull requests in the &Oslash;MQ community. Today, for what it's worth, this argument seems settled: the "liberal" policy which we adopted for libzmq in early 2012 broke our dependency on a single prime author, and opened the floor to dozens of new contributors. More profoundly, it allowed us to move to a gently organic evolutionary model, very different from the older forced-march model.</para>

<para>The reason I was confident this would work was that our work on the Guide had, for a year or more, shown the way. True, the text is my own work, which is perhaps as it should be. Writing is not programming. When we write, we tell a story and one doesn't want different voices telling one tale, it feels strange.</para>

<para>For me the real long-term value of the Guide is the repository of examples: about 65,000 lines of code in 24 different languages. It's partly about making &Oslash;MQ accessible to more people. People already refer to the Python and PHP example repositories -- two of the most complete -- when they want to tell others how to learn &Oslash;MQ. But it's also about learning programming languages.</para>

<para>Here's a loop of code in Tcl:</para>

<programlisting language="">
while {1} {
    # Process all parts of the message
    zmq message message
    frontend recv_msg message
    set more [frontend getsockopt RCVMORE]
    backend send_msg message [expr {$more?"SNDMORE":""}]
    message close
    if {!$more} {
        break ; # Last message part
    }
}
</programlisting>

<para>And the same loop in Lua:</para>

<programlisting language="lua">
while true do
    --  Process all parts of the message
    local msg = frontend:recv()
    if (frontend:getopt(zmq.RCVMORE) == 1) then
        backend:send(msg, zmq.SNDMORE)
    else
        backend:send(msg, 0)
        break;      --  Last message part
    end
end
</programlisting>

<para>And this particular example (rrbroker) is in C#, C++, CL, Clojure, Erlang, F#, Go, Haskell, Haxe, Java, Lua, Node.js, Perl, PHP, Python, Ruby, Scala, Tcl, and of course C. This code base, all licensed as open source under the MIT/X11, may form the basis for other books, or projects.</para>

<para>But what this collection of translations says most profoundly is this: the language you choose is a detail, even a distraction. The power of &Oslash;MQ lies in the patterns it gives you and lets you build, and these transcend the comings and goings of languages. My goal as a software and social architect is to build structures that can last generations. There seems no point in aiming for mere decades.</para>

</sect1>
<sect1>
<title>Removing Friction</title>
<para>I'll explain the technical tool chain we used in terms of the friction we removed. With the Guide we're telling a story and the goal is to reach as many people as possible, as cheaply and smoothly as we can.</para>

<para>The core idea was to host the Guide on github and make it easy for anyone to contribute. It turned out to be more complex than that, however.</para>

<para>Let's start with the division of labor. I'm a good writer and can produce endless amounts of decent text quickly. But what was impossible for me was to provide the examples in other languages. Since the core &Oslash;MQ API is in C, it seemed logical to write the original examples in C. Also, C is a neutral choice; it's perhaps the only language that doesn't create strong emotions.</para>

<para>How to encourage people to make translations of the examples? We tried a few approaches and finally what worked best was to offer a "choose your language" link on every single example, in the text, which took people either to the translation, or to a page explaining how they could contribute. The way it usually works is that as people learn &Oslash;MQ in their preferred language, they contribute a handful of translations, or fixes to the existing ones.</para>

<para>At the same time I noticed a few people quite determinedly translating <emphasis>every single</emphasis> example. This was mainly binding authors who realized that the examples were a great way to encourage people to use their bindings. For their efforts, I extended the scripts to produce language-specific versions of the Guide. Instead of including the C code, we'd include the Python, or PHP code. Lua and Haxe also got their dedicated Guides.</para>

<para>Once we have an idea of who works on what, we know how to structure the work itself. It's clear that to write and test an example, what you want to work on is <emphasis>source code</emphasis>. So we import this source code when we build the Guide, and that's how we make language-specific versions.</para>

<para>I like to write in a plain text format. It's fast and works well with source control systems like git. Since the main platform for our websites is Wikidot, I write using Wikidot's very readable markup format.</para>

<para>At least in the first chapters, it was important to draw pictures to explain the flow of messages between peers. I found Ditaa, a lovely tool that chews up line-drawings and spits out elegant graphics. Having the graphics in the text, as text, makes it remarkably easy to work.</para>

<para>By now you'll realize that the Guide toolchain is highly customized, though it uses a lot of external tools. All are available on Ubuntu, which is a mercy, and the whole toolchain is in the Guide repository in the bin subdirectory.</para>

<para>Let's walk through the editing and publishing process. Here is how we produce the online version:</para>

<screen>bin/mkguide
</screen>

<para>Which works as follows:</para>

<itemizedlist>
  <listitem><para>The original text sits in a series of text files (one per chapter).</para></listitem>
  <listitem><para>The examples sit in the examples subdirectory, classified per language.</para></listitem>
  <listitem><para>We take the text, and processes this into a set of Wikidot-ready files. It does this for each of the languages that get their own Guide version.</para></listitem>
  <listitem><para>We extract the graphics and calls Ditaa on each one to produce image files, which it stores in the images subdirectory.</para></listitem>
  <listitem><para>We extract inline listings (which are not translated) and stores these in the listings subdirectory.</para></listitem>
  <listitem><para>We use pygmentize on each example and listing to create a marked-up page in Wikidot format.</para></listitem>
  <listitem><para>We upload all changed files to the Guide wiki using the Wikidot API.</para></listitem>
</itemizedlist>
<para>Doing this from scratch takes a while. So we store the SHA1 signatures of every image, listing, example, and text file, and only process and upload changes, and that makes it easy to publish a new version of the Guide when people make new contributions.</para>

<para>To produce the PDF and Epub formats we do this:</para>

<screen>bin/mkpdfs
</screen>

<para>Which works as follows:</para>

<itemizedlist>
  <listitem><para>We use the mkbook script on all the input files to produce a DocBook output.</para></listitem>
  <listitem><para>We push the DocBook format through docbook2ps and ps2pdf to create clean PDFs, in each language.</para></listitem>
  <listitem><para>We push the DocBook format though db2epub to create Epub books, and in each language.</para></listitem>
  <listitem><para>We upload the PDFs to the Guide wiki using the Wikidot API.</para></listitem>
</itemizedlist>
<para>It's important, when you create a community project, to lower the "change latency", i.e. the time it takes for people to see their work live. Or at least, to see that you've accepted their pull request. If that is more than a day or two, you've often lost your contributor's interest.</para>

</sect1>
<sect1>
<title>Licensing</title>
<para>I want people to reuse the Guide in their own work: in presentations, articles, and even other books. However, the deal is that if they remix my work, others can remix theirs. I'd like credit, and have no argument against others making money from their remixes. Thus, the Guide is licensed under cc-by-sa.</para>

<para>For the examples, we started with GPL, but it rapidly became clear this wasn't workable. The point of examples is to give people reusable code fragments so they will use &Oslash;MQ more widely, and if these are GPL that won't happen. We switched to MIT/X11, even for the larger and more complex examples that conceivably would work as LGPL.</para>

<para>However when we started turning the examples into stand-alone projects (as with Majordomo), we used the LGPL. Again, remixability trumps dissemination. Licenses are tools, use them with intent, not ideology.</para>

</sect1>
</chapter>
</book>
